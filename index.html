<!DOCTYPE html>
<html lang="zh-CN">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes">
        <meta name="description" content="专业的BOM表格对比分析工具，支持Excel和HTML文件导入对比">
        <meta name="keywords" content="BOM,表格对比,Excel,数据分析">
        <title>表格 BOM 对比分析</title>

        <!-- Preload critical resources -->
        <link rel="preload" href="https://cdn.tailwindcss.com" as="script">
        <link rel="preload" href="https://unpkg.com/vue@3/dist/vue.global.prod.js" as="script">

        <!-- Tailwind CSS v3 CDN -->
        <script src="https://cdn.tailwindcss.com"></script>
        <!-- Font Awesome 6 CDN with fallback -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
            onerror="this.onerror=null; this.href='https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css'">
        <!-- ExcelJS CDN (defer避免阻塞渲染) -->
        <script defer src="https://cdn.jsdelivr.net/npm/exceljs@4.4.0/dist/exceljs.min.js"></script>
        <!-- Vue 3 全局构建 CDN with fallback -->
        <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"
            onerror="this.onerror=null; this.src='https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.prod.js'"></script>
        <style>
            /* ========== 现代化基础样式 ========== */
            :root {
                --primary-blue: #2563eb;
                --primary-green: #059669;
                --primary-red: #dc2626;
                --primary-orange: #ea580c;
                --bg-gradient: linear-gradient(135deg, #f0f9ff 0%, #ffffff 50%, #fef7f7 100%);
                --shadow-soft: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
                --shadow-card: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
                --border-radius: 12px;
                --transition-smooth: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            }

            /* 浮动式滚动条（不占用页面布局空间） */
            html {
                overflow-y: overlay;
                /* 滚动条浮在内容上方 */
                scrollbar-gutter: stable;
                /* 为滚动条预留稳定空间 */
            }

            /* 如果不支持 overlay，则隐藏滚动条 */
            @supports not (overflow-y: overlay) {
                html {
                    overflow-y: auto;
                    scrollbar-width: none;
                    /* Firefox */
                    -ms-overflow-style: none;
                    /* Internet Explorer 10+ */
                }

                html::-webkit-scrollbar {
                    display: none;
                    /* WebKit */
                }
            }

            /* 优雅的滚动条（支持更多浏览器） */
            ::-webkit-scrollbar {
                width: 12px;
                height: 12px;
            }

            ::-webkit-scrollbar-track {
                background: transparent;
                /* 透明背景，不影响页面布局 */
            }

            ::-webkit-scrollbar-thumb {
                background: rgba(156, 163, 175, 0.3);
                border-radius: 6px;
                border: 2px solid transparent;
                background-clip: content-box;
                transition: var(--transition-smooth);
            }

            ::-webkit-scrollbar-thumb:hover {
                background: rgba(107, 114, 128, 0.6);
                background-clip: content-box;
            }

            /* 滚动条角落处理 */
            ::-webkit-scrollbar-corner {
                background: transparent;
            }

            /* Firefox 浮动式滚动条 */
            * {
                scrollbar-width: thin;
                scrollbar-color: rgba(156, 163, 175, 0.3) transparent;
            }

            /* 如果不支持 overlay，则对所有元素隐藏滚动条 */
            @supports not (overflow-y: overlay) {
                * {
                    scrollbar-width: none;
                    /* Firefox */
                    -ms-overflow-style: none;
                    /* Internet Explorer 10+ */
                }

                *::-webkit-scrollbar {
                    display: none;
                    /* WebKit */
                }
            }

            /* 确保页面内容不因滚动条出现而偏移 */
            body {
                overflow-y: overlay;
                scrollbar-gutter: stable;
            }

            /* 如果不支持 overlay，body 也隐藏滚动条 */
            @supports not (overflow-y: overlay) {
                body {
                    overflow-y: auto;
                    scrollbar-width: none;
                    -ms-overflow-style: none;
                }

                body::-webkit-scrollbar {
                    display: none;
                }
            }

            /* 过渡动画 */
            .fade-enter-active,
            .fade-leave-active {
                transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            }

            .fade-enter-from,
            .fade-leave-to {
                opacity: 0;
                transform: translateY(-8px);
            }

            .fadeout-leave-active {
                transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            }

            .fadeout-leave-to {
                opacity: 0;
                transform: translateY(-8px);
            }

            /* 滑动过渡 */
            .slide-down-enter-active,
            .slide-down-leave-active {
                transition: max-height 0.5s cubic-bezier(0.4, 0, 0.2, 1);
                overflow: hidden;
            }

            .slide-down-enter-from {
                max-height: 0;
                opacity: 0;
            }

            .slide-down-enter-to {
                max-height: 9999px;
                opacity: 1;
            }

            .slide-down-leave-from {
                max-height: 9999px;
                opacity: 1;
            }

            .slide-down-leave-to {
                max-height: 0;
                opacity: 0;
            }

            /* 滑动过渡 - 自适应高度版本 */
            .slide-up-enter-active {
                transition: height 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.4s ease-in-out;
                overflow: hidden;
            }

            .slide-up-leave-active {
                transition: height 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.4s ease-in-out;
                overflow: hidden;
            }

            .slide-up-enter-from {
                height: 0;
                opacity: 0;
            }

            .slide-up-enter-to {
                height: auto;
                opacity: 1;
            }

            .slide-up-leave-from {
                height: auto;
                opacity: 1;
            }

            .slide-up-leave-to {
                height: 0;
                opacity: 0;
            }

            /* 内容淡入淡出 - 独立控制 */
            .content-fade-enter-active {
                transition: opacity 0.3s ease-in-out 0.2s;
                /* 延迟0.2s开始，让容器先展开一点 */
            }

            .content-fade-leave-active {
                transition: opacity 0.2s ease-in-out;
                /* 快速淡出，在容器收回前完成 */
            }

            .content-fade-enter-from {
                opacity: 0;
            }

            .content-fade-enter-to {
                opacity: 1;
            }

            .content-fade-leave-from {
                opacity: 1;
            }

            .content-fade-leave-to {
                opacity: 0.3;
                /* 保持微弱可见度，避免完全消失 */
            }

            /* 预览卡片切换动画 - 统一的过渡效果 */
            .preview-list-move,
            .preview-list-enter-active,
            .preview-list-leave-active {
                transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            }

            /* 预览卡片基础样式 */
            .preview-card {
                /* 移除宽度和flex-basis的transition，避免与Vue transition-group冲突 */
                transition: opacity 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            }

            /* 新文件进入：从右侧滑入 */
            .preview-list-enter-from {
                opacity: 0;
                transform: translateX(120%) scale(0.9);
            }

            .preview-list-enter-to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }

            /* 被挤掉的文件向左滑出 */
            .preview-list-leave-from {
                opacity: 1;
                transform: translateX(0) scale(1);
            }

            .preview-list-leave-to {
                opacity: 0;
                transform: translateX(-120%) scale(0.9);
            }

            /* 被移除的元素绝对定位，不影响布局 */
            .preview-list-leave-active {
                position: absolute;
                z-index: 0;
                width: calc((100% - 1.5rem) / 2);
                /* 保持原始宽度 */
            }

            /* 移动中的元素保持在上层 */
            .preview-list-move {
                z-index: 1;
            }

            /* 预览容器样式 - 确保动画空间 */
            .preview-container {
                position: relative;
                min-height: 200px;
                /* 确保有足够空间进行动画 */
                overflow: hidden;
                /* 隐藏滑出的元素 */
            }

            /* 现代化的按钮样式 */
            .btn-modern {
                transition: var(--transition-smooth);
                transform: translateY(0);
                box-shadow: var(--shadow-card);
            }

            .btn-modern:hover {
                transform: translateY(-2px);
                box-shadow: var(--shadow-soft);
            }

            .btn-modern:active {
                transform: translateY(0);
            }

            /* 增强的卡片样式 */
            .card-modern {
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.2);
                box-shadow: var(--shadow-card);
                transition: var(--transition-smooth), height 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            }

            .card-modern:hover {
                box-shadow: var(--shadow-soft);
                transform: translateY(-2px);
            }

            /* 文件列表容器hover效果 */
            .file-list-container {
                background: rgba(255, 255, 255, 0.8);
                border-radius: var(--border-radius);
                box-shadow: var(--shadow-card);
                transition: var(--transition-smooth);
            }

            .file-list-container:hover {
                background: rgba(255, 255, 255, 0.95);
                box-shadow: var(--shadow-soft);
                transform: translateY(-2px);
            }

            /* 文件列表项hover效果 */
            .file-item {
                transition: var(--transition-smooth);
                border-radius: var(--border-radius);
            }

            .file-item:hover {
                box-shadow: var(--shadow-soft);
                transform: translateY(-1px);
            }

            .file-item.selected {
                background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
                border: 1px solid #3b82f6;
                box-shadow: var(--shadow-card);
                transform: translateY(-1px);
            }

            .file-item.selected:hover {
                box-shadow: var(--shadow-soft);
                transform: translateY(-2px);
            }

            /* 预览卡片hover效果 */
            .preview-card {
                background: white;
                border-radius: var(--border-radius);
                box-shadow: var(--shadow-card);
                transition: var(--transition-smooth);
            }

            .preview-card:hover {
                box-shadow: var(--shadow-soft);
                transform: translateY(-3px);
            }

            /* 表格容器 - 移除hover效果 */
            .table-container {
                border-radius: var(--border-radius);
                overflow: hidden;
            }

            /* 筛选下拉菜单hover效果 */
            .filter-dropdown {
                transition: var(--transition-smooth);
                border-radius: var(--border-radius);
                box-shadow: var(--shadow-card);
            }

            .filter-dropdown:hover {
                box-shadow: var(--shadow-soft);
                transform: translateY(-1px);
            }

            /* 表格增强样式 */
            .table-modern {
                border-collapse: separate;
                border-spacing: 0;
                overflow: hidden;
                border-radius: var(--border-radius);
                box-shadow: var(--shadow-card);
            }

            .table-modern th {
                background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
                position: sticky;
                top: 0;
                z-index: 10;
            }

            .table-modern tbody tr:hover {
                background-color: rgba(59, 130, 246, 0.05);
                transform: scale(1.002);
                transition: var(--transition-smooth);
            }

            /* 改进的兼容性 */
            .touch-friendly {
                touch-action: manipulation;
                -webkit-tap-highlight-color: transparent;
            }

            /* 可访问性增强 */
            .focus-visible:focus {
                outline: 2px solid var(--primary-blue);
                outline-offset: 2px;
            }

            /* 性能优化 */
            .gpu-accelerated {
                transform: translateZ(0);
                will-change: transform;
            }

            /* 响应式优化 */
            @media (max-width: 768px) {
                .mobile-optimized {
                    padding: 12px;
                    font-size: 14px;
                }

                .btn-mobile {
                    min-height: 44px;
                    /* iOS建议的最小触摸目标 */
                    padding: 12px 16px;
                }
            }

            /* 老浏览器回退 */
            @supports not (backdrop-filter: blur(10px)) {
                .card-modern {
                    background: rgba(255, 255, 255, 0.98);
                }
            }
        </style>
    </head>

    <body class="min-h-screen bg-gradient-to-br from-blue-50 via-white to-rose-50">
        <div id="app" class="container mx-auto px-2 py-6 max-w-none w-[95vw]">
            <!-- 现代化的主容器 -->
            <main class="card-modern rounded-2xl p-8 gpu-accelerated" role="main">
                <!-- 标题区 - 增强可访问性 -->
                <header class="flex flex-col gap-4 mb-10 relative">
                    <div class="flex items-end gap-4 flex-wrap">
                        <h1
                            class="text-3xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent flex items-center gap-3">
                            <span
                                class="p-3 bg-gradient-to-br from-green-400 to-blue-500 rounded-xl text-white shadow-lg">
                                <i class="fa-solid fa-table" aria-hidden="true"></i>
                            </span>
                            表格 BOM 对比分析工具
                        </h1>
                        <span class="text-lg text-gray-600 font-medium">{{ subtitle }}</span>
                    </div>
                    <p class="text-gray-700 leading-relaxed">
                        🚀 专业的BOM表格对比分析工具，支持导入多份数据，并可对最多两份数据进行即时对比。
                        <strong class="text-amber-600">⚠️ 注意：导入的文件必须解密才可用。</strong>
                    </p>

                    <!-- 状态徽章区 -->
                    <div class="absolute right-0 top-0 flex flex-col items-end gap-2" aria-live="polite">
                        <transition name="fadeout">
                            <div v-if="sheetBadge.show"
                                :class="['text-sm font-medium text-white px-4 py-2 rounded-full shadow-lg', sheetBadge.bgClass]"
                                role="status">
                                {{ sheetBadge.text }}
                            </div>
                        </transition>
                        <transition name="fadeout">
                            <div v-if="faBadge.show"
                                :class="['text-sm font-medium text-white px-4 py-2 rounded-full shadow-lg', faBadge.bgClass]"
                                role="status">
                                {{ faBadge.text }}
                            </div>
                        </transition>
                    </div>
                </header>
                <!-- 文件导入区 - 增强的拖拽体验 -->
                <section class="mb-8" aria-labelledby="file-import-heading">
                    <h2 id="file-import-heading"
                        class="block mb-4 text-lg font-bold text-gray-800 flex items-center gap-2">
                        <i class="fa-solid fa-cloud-upload-alt text-blue-500" aria-hidden="true"></i>
                        文件导入
                    </h2>
                    <div class="flex items-center gap-4 flex-wrap">
                        <input id="fileInput" type="file" multiple accept=".xlsx,.xls,.html,.htm" @change="handleFiles"
                            class="sr-only" aria-describedby="file-help" />
                        <label for="fileInput"
                            class="btn-modern px-6 py-3 rounded-xl bg-gradient-to-r from-blue-500 to-blue-600 text-white hover:from-blue-600 hover:to-blue-700 cursor-pointer font-semibold flex items-center gap-2 touch-friendly focus-visible"
                            tabindex="0" @keydown.enter="$refs.fileInput?.click()"
                            @keydown.space.prevent="$refs.fileInput?.click()">
                            <i class="fa-solid fa-folder-open" aria-hidden="true"></i>
                            选择文件
                        </label>
                        <div class="flex flex-col gap-1">
                            <span class="text-sm font-medium text-gray-600">支持格式：Excel (.xlsx, .xls) 和 HTML (.html,
                                .htm)</span>
                            <span id="file-help" class="text-xs text-gray-500">💡 支持批量导入，可同时选择多个文件</span>
                        </div>
                    </div>
                    <div v-if="loading"
                        class="mt-4 flex items-center gap-3 p-4 bg-blue-50 rounded-xl border border-blue-200"
                        role="status" aria-live="polite">
                        <div class="animate-spin w-5 h-5 border-2 border-blue-500 border-t-transparent rounded-full">
                        </div>
                        <span class="text-blue-700 font-medium">正在解析文件，请稍候...</span>
                    </div>
                </section>
                <!-- 文件列表区（滑动进入/离开 1s） -->
                <transition name="slide-down">
                    <div v-if="fileList.length" class="mb-8 file-list-container p-4">
                        <div class="font-semibold mb-2 text-gray-700 flex items-center gap-2">
                            <div class="flex items-center gap-2 min-w-0">
                                <i class="fa-solid fa-list"></i>
                                <span class="whitespace-nowrap">已导入文件（共 {{ fileList.length }} 个）：</span>
                                <span class="truncate"
                                    :class="['text-sm', multiCompareMode ? 'text-red-600' : 'text-gray-500']">
                                    {{ multiCompareMode ? '勾选多份文件导出分别对比结果' : '勾选文件即可预览（最多并列2个）' }}
                                </span>
                            </div>
                            <div class="flex-1"></div>
                            <div class="ml-4 flex items-center gap-2">
                                <!-- 多文件对比导出按钮（右侧，位于“全选”左侧） -->
                                <button type="button" :class="multiCompareMode
                                    ? 'px-2 py-1 text-xs rounded bg-red-600 text-white hover:bg-red-700'
                                    : 'px-2 py-1 text-xs rounded bg-blue-600 text-white hover:bg-blue-700'"
                                    @click="toggleMultiCompare">
                                    {{ multiCompareMode ? '取消多选' : '多文件对比导出' }}
                                </button>
                                <!-- 全选按钮：占位隐藏以避免抖动 -->
                                <button type="button" :class="[
                                    'px-2 py-1 text-xs rounded border',
                                    multiCompareMode ? 'border-red-300 text-red-600 hover:bg-red-50' : 'invisible pointer-events-none border-transparent'
                                ]" @click="selectAllFiles">
                                    全选
                                </button>
                            </div>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
                            <label v-for="(file, idx) in fileList" :key="file.name"
                                class="file-item flex items-center gap-2 cursor-pointer bg-blue-50 hover:bg-blue-100 rounded px-2 py-1"
                                :class="{ 'selected': selectedFiles.includes(file.name) }">
                                <input type="checkbox" :checked="selectedFiles.includes(file.name)"
                                    @change="onFileCheckboxChange(file.name, $event.target.checked, file.status)"
                                    :disabled="file.status === 'error'" class="accent-blue-500" />
                                <span class="truncate"><i
                                        class="fa-solid fa-file-excel text-green-500 mr-1"></i>{{ file.name }}</span>
                                <span class="text-xs text-gray-400">({{ file.rows }} 行)</span>
                                <span class="ml-2">
                                    <i v-if="file.status === 'pending'"
                                        class="fa-solid fa-spinner fa-spin text-blue-400"></i>
                                    <i v-else-if="file.status === 'success'"
                                        class="fa-solid fa-check text-green-500"></i>
                                    <i v-else-if="file.status === 'error'"
                                        class="fa-solid fa-circle-exclamation text-red-500" title="解析失败"></i>
                                </span>
                                <span v-if="file.status === 'error'"
                                    class="text-xs text-red-500 ml-2">{{ file.errorMsg }}</span>
                                <button type="button" @click.stop="removeFile(idx)"
                                    class="ml-2 px-2 py-1 text-xs text-red-500 hover:text-white hover:bg-red-500 rounded transition"><i
                                        class="fa-solid fa-trash"></i> 删除</button>
                            </label>
                        </div>
                        <div class="mt-2 text-xs" :class="multiCompareMode ? 'text-red-600' : 'text-gray-500'">
                            {{ multiCompareMode ? '勾选多份文件导出分别对比结果' : '勾选文件进行预览（最多并列2个）' }}
                        </div>
                    </div>
                </transition>
                <!-- 对比任务开关 + 图例 + 导出按钮 -->
                <div class="mb-4 flex items-center justify-between gap-4 flex-wrap">
                    <div class="flex items-center gap-3 flex-wrap">
                        <button type="button" @click="toggleCompare"
                            :disabled="(selectedFiles.length !== 2 && !compareMode) || compareBusy"
                            class="px-3 py-1.5 rounded text-sm font-medium shadow transition flex items-center gap-2"
                            :class="compareBusy ? 'bg-gray-400 text-white cursor-wait' : (compareMode ? 'bg-red-600 text-white hover:bg-red-700' : (selectedFiles.length !== 2 ? 'bg-gray-200 text-gray-400 cursor-not-allowed' : 'bg-blue-600 text-white hover:bg-blue-700'))">
                            <i v-if="compareBusy" class="fa-solid fa-spinner fa-spin"></i>
                            <i v-else :class="compareMode ? 'fa-solid fa-toggle-on' : 'fa-solid fa-toggle-off'"></i>
                            <span>{{ compareBusy ? '分析中...' : (compareMode ? '关闭对比' : '启动对比') }}</span>
                        </button>
                        <span v-if="selectedFiles.length !== 2" class="text-xs text-gray-400">需选择2个文件</span>
                        <!-- 色块图例 -->
                        <div class="flex items-center gap-3 text-xs text-gray-600">
                            <span class="inline-flex items-center gap-2"><span
                                    class="w-3 h-3 inline-block rounded bg-red-600"></span>该行未在对表中找到</span>
                            <span class="inline-flex items-center gap-2"><span
                                    class="w-3 h-3 inline-block rounded bg-orange-500"></span>该行虽未找到，但供应商零件号匹配</span>
                            <span class="inline-flex items-center gap-2"><span
                                    class="w-3 h-3 inline-block rounded bg-blue-600"></span>该行在对表找到，但数量不同</span>
                            <span class="inline-flex items-center gap-2"><span
                                    class="w-3 h-3 inline-block rounded bg-green-600"></span>该行与对表中数据一致</span>
                        </div>
                    </div>
                    <div>
                        <button type="button" @click="exportCompare" :class="[
                            'px-3 py-1.5 rounded text-sm font-medium shadow transition bg-emerald-600 text-white hover:bg-emerald-700',
                            (selectedFiles.length > 0 && sheetReady) ? '' : 'invisible pointer-events-none'
                        ]" :aria-hidden="!(selectedFiles.length > 0 && sheetReady)"
                            :tabindex="(selectedFiles.length > 0 && sheetReady) ? 0 : -1" title="导出数据">
                            <i class="fa-solid fa-file-arrow-down mr-1"></i>
                            导出数据
                        </button>
                    </div>
                </div>
                <!-- 并列预览区 - 优化动画效果 -->
                <transition name="slide-up" @before-enter="onBeforeEnter" @enter="onEnter" @after-enter="onAfterEnter"
                    @before-leave="onBeforeLeave" @leave="onLeave" @after-leave="onPreviewContainerAfterLeave">
                    <div v-if="containerVisible" ref="previewWrap" class="w-full">
                        <div class="w-full preview-container">
                            <transition-group name="preview-list" tag="div"
                                class="flex w-full flex-wrap gap-6 relative">
                                <div v-for="(fileName, idx) in displayedSelectedFiles" :key="fileName"
                                    class="preview-card p-4" :style="cardStyle(idx, fileName)">
                                    <div
                                        v-if="getTable(fileName) && Array.isArray(getTable(fileName).columns) && Array.isArray(getTable(fileName).data)">
                                        <div class="flex items-center justify-between mb-2">
                                            <span class="font-semibold text-blue-600"><i
                                                    class="fa-solid fa-file-excel text-green-500 mr-1"></i>{{ fileName }}</span>
                                            <div class="flex items-center gap-2">
                                                <div v-if="compareMode" class="flex items-center gap-1">
                                                    <label class="text-xs text-gray-500 mr-2">点击右侧色块筛选</label>
                                                    <button type="button" :class="badgeClass(fileName, 'red')"
                                                        title="点击筛选仅在对表中未找到的行"
                                                        @click.stop="toggleColorFilter(fileName, 'red')">{{ categoryCounts(fileName).red }}</button>
                                                    <button type="button" :class="badgeClass(fileName, 'orange')"
                                                        title="点击筛选未找到但仅在对表中供应商零件号匹配的行"
                                                        @click.stop="toggleColorFilter(fileName, 'orange')">{{ categoryCounts(fileName).orange }}</button>
                                                    <button type="button" :class="badgeClass(fileName, 'blue')"
                                                        title="点击筛选仅在对表中数量不同的行"
                                                        @click.stop="toggleColorFilter(fileName, 'blue')">{{ categoryCounts(fileName).blue }}</button>
                                                    <button type="button" :class="badgeClass(fileName, 'green')"
                                                        title="点击筛选仅在对表中数量相同的行"
                                                        @click.stop="toggleColorFilter(fileName, 'green')">{{ categoryCounts(fileName).green }}</button>
                                                </div>
                                                <span v-if="hasActiveFilters(fileName)"
                                                    class="text-xs text-blue-600">筛选后
                                                    {{ filteredRows(fileName).length }} 行</span>
                                                <span class="text-xs text-gray-700">共
                                                    {{ getTable(fileName).data.length }}
                                                    行</span>
                                            </div>
                                        </div>
                                        <div class="overflow-auto table-container">
                                            <table class="min-w-full text-sm border border-gray-200 rounded-lg">
                                                <thead>
                                                    <tr class="bg-blue-50">
                                                        <th v-for="col in getTable(fileName).columns" :key="col"
                                                            class="px-2 py-1 font-medium text-gray-700 border-b relative">
                                                            <div class="flex items-center gap-2">
                                                                <span class="truncate" :title="col">{{ col }}</span>
                                                                <button type="button"
                                                                    class="text-gray-500 hover:text-blue-600 filter-btn"
                                                                    :data-filter-key="fileName + '__' + col"
                                                                    @click.stop="toggleFilterDropdown(fileName, col, $event)"
                                                                    :title="isColumnFiltered(fileName, col) ? '已筛选' : '筛选'">
                                                                    <i class="fa-solid fa-filter"></i>
                                                                    <span v-if="isColumnFiltered(fileName, col)"
                                                                        class="inline-block w-1.5 h-1.5 rounded-full bg-blue-600 ml-1"></span>
                                                                </button>
                                                            </div>
                                                            <!-- 下拉筛选面板 -->
                                                            <teleport to="body">
                                                                <div v-if="isDropdownOpen(fileName, col)"
                                                                    class="filter-dropdown filter-panel fixed z-[10000] bg-white border rounded shadow-lg w-64 p-2"
                                                                    :style="dropdownStyle(fileName, col)">
                                                                    <div class="mb-2">
                                                                        <input type="text"
                                                                            class="w-full border rounded px-2 py-1 text-xs"
                                                                            placeholder="搜索..."
                                                                            v-model="getFilterState(fileName, col).search">
                                                                    </div>
                                                                    <div class="flex items-center gap-2 mb-2">
                                                                        <button type="button"
                                                                            class="text-xs px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded"
                                                                            @click.stop="selectAllValues(fileName, col)">全选</button>
                                                                        <button type="button"
                                                                            class="text-xs px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded"
                                                                            @click.stop="clearAllValues(fileName, col)">清空</button>
                                                                    </div>
                                                                    <div
                                                                        class="max-h-56 overflow-auto border rounded p-1 text-sm">
                                                                        <label
                                                                            v-for="val in filteredDistinctValues(fileName, col)"
                                                                            :key="val"
                                                                            class="flex items-center gap-2 px-1 py-0.5 hover:bg-gray-50 cursor-pointer">
                                                                            <input type="checkbox"
                                                                                :checked="isValueChecked(fileName, col, val)"
                                                                                @change="onToggleValue(fileName, col, val, $event.target.checked)">
                                                                            <span class="truncate"
                                                                                :title="val || '(空)'">{{ val || '(空)' }}</span>
                                                                        </label>
                                                                    </div>
                                                                    <div class="flex justify-end gap-2 mt-2">
                                                                        <button
                                                                            class="text-xs px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded"
                                                                            @click.stop="closeDropdown(fileName, col)">取消</button>
                                                                        <button
                                                                            class="text-xs px-2 py-1 bg-blue-600 text-white hover:bg-blue-700 rounded"
                                                                            @click.stop="applyFilter(fileName, col)">确定</button>
                                                                    </div>
                                                                </div>
                                                            </teleport>
                                                        </th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr v-for="(row, rIdx) in filteredRows(fileName)" :key="rIdx"
                                                        :class="['transition hover:bg-blue-100', compareMode ? rowBgClass(fileName, row) : '']">
                                                        <td v-for="col in getTable(fileName).columns" :key="col"
                                                            class="px-2 py-1 border-b">
                                                            {{ (row && typeof row === 'object' && col in row) ? row[col] : '' }}
                                                        </td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </div>
                                        <!-- 导线数量差值（仅在对比模式） -->
                                        <div v-if="compareMode" class="mt-3 border-t pt-2">
                                            <div class="text-sm font-medium text-gray-700 mb-1 flex items-center gap-2">
                                                <i class="fa-solid fa-code-compare text-blue-500"></i>导线数量差值
                                            </div>
                                            <div v-if="wiresDiff(fileName).length === 0" class="text-xs text-gray-400">
                                                无差异或无导线类型
                                            </div>
                                            <div v-else class="overflow-auto">
                                                <table class="min-w-full text-xs border border-gray-200 rounded">
                                                    <thead>
                                                        <tr class="bg-gray-50">
                                                            <th class="px-2 py-1 border-b text-left">零件号</th>
                                                            <th class="px-2 py-1 border-b text-left">类型</th>
                                                            <th class="px-2 py-1 border-b text-right">本表数量</th>
                                                            <th class="px-2 py-1 border-b text-right">对表数量</th>
                                                            <th class="px-2 py-1 border-b text-right">差值(本-对)</th>
                                                        </tr>
                                                    </thead>
                                                    <tbody>
                                                        <tr v-for="(d, i) in wiresDiff(fileName)" :key="i">
                                                            <td class="px-2 py-1 border-b">{{ d.pn }}</td>
                                                            <td class="px-2 py-1 border-b">{{ d.type }}</td>
                                                            <td class="px-2 py-1 border-b text-right">{{ d.q1 }}
                                                            </td>
                                                            <td class="px-2 py-1 border-b text-right">{{ d.q2 }}
                                                            </td>
                                                            <td class="px-2 py-1 border-b text-right"
                                                                :class="d.diff === 0 ? 'text-gray-500' : (d.diff > 0 ? 'text-green-600' : 'text-red-600')">
                                                                {{ d.diff }}
                                                            </td>
                                                        </tr>
                                                    </tbody>
                                                </table>
                                            </div>
                                        </div>
                                    </div>
                                    <div v-else class="text-red-500 text-sm">表格数据不存在或已被删除</div>
                            </transition-group>
                        </div>
                    </div>
                </transition>
                <!-- 视口回到顶部按钮（Teleport 到 body，确保贴可视区右下角） -->
                <teleport to="body">
                    <div
                        :class="['fixed bottom-0 right-0 z-[9999] transform transition-all duration-300', showTop ? 'translate-x-0 opacity-100' : 'translate-x-24 opacity-0 pointer-events-none']">
                        <button @click="scrollToTop" aria-label="回到顶部" title="回到顶部"
                            class="w-8 h-8 rounded-lg bg-blue-600 text-white shadow-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-300 flex items-center justify-center">
                            <i class="fa-solid fa-arrow-up text-xs"></i>
                        </button>
                    </div>
                </teleport>
                <script>
                    const { createApp, ref, reactive, onMounted, onUnmounted, watch, nextTick } = Vue;
                    createApp({
                        setup() {
                            // ======================== 核心状态与常量 ========================
                            const tables = reactive([]);
                            const fileList = reactive([]);
                            const selectedFiles = ref([]);

                            // 通用常量定义
                            const HEADER_TOKENS = new Set(['零件号', '供应商零件号', '客户零件号']);
                            const COLUMN_NAMES = {
                                PART_NUMBER: '零件号',
                                SUPPLIER_PART_NUMBER: '供应商零件号',
                                CUSTOMER_PART_NUMBER: '客户零件号',
                                QUANTITY: '数量',
                                TYPE: '类型'
                            };
                            const WIRE_TYPES = new Set(['WIRE', '线束', '导线']);
                            const COLOR_TO_PRIORITY = { red: 0, orange: 1, blue: 2, green: 3 };

                            // ======================== 通用工具函数 ========================

                            // 数字转换函数（处理千位分隔符，空值转0）
                            function toNumber(v) {
                                if (v == null || v === '') return 0;
                                const n = parseFloat(String(v).replace(/,/g, ''));
                                return isNaN(n) ? 0 : n;
                            }

                            // 规范化键名函数（零件号专用）
                            function normalizeKey(key) {
                                if (key == null) return '';
                                let s = String(key);
                                s = s.replace(/[\u200B-\u200D\uFEFF\u00AD]/g, '');
                                s = s.replace(/[\s\u00A0]+/g, '').trim();
                                return s;
                            }

                            // 错误处理工具
                            function handleError(error, context = '') {
                                console.error(`Error ${context}:`, error);
                                const message = error?.message || String(error) || 'Unknown error';
                                alert(`操作失败${context ? ' (' + context + ')' : ''}: ${message}`);
                            }

                            // ======================== 通用字符串处理 ========================

                            // 安全的字符串提取（处理null/undefined，自动trim）
                            function safeString(value) {
                                return value != null ? String(value).trim() : '';
                            }

                            // 安全获取对象属性的字符串值
                            function getStringProp(obj, prop) {
                                return safeString(obj && obj[prop]);
                            }

                            // 检查字符串是否为空（null、undefined、空字符串、只包含空白）
                            function isEmpty(str) {
                                return !str || !String(str).trim();
                            }

                            // 安全执行函数（统一异常处理）
                            function safeExecute(fn, defaultValue = null, context = '') {
                                try {
                                    return fn();
                                } catch (err) {
                                    if (context) {
                                        console.warn(`Safe execution failed (${context}):`, err);
                                    }
                                    return defaultValue;
                                }
                            }

                            // 异步安全执行
                            async function safeExecuteAsync(fn, defaultValue = null, context = '') {
                                try {
                                    return await fn();
                                } catch (err) {
                                    if (context) {
                                        console.warn(`Async safe execution failed (${context}):`, err);
                                    }
                                    return defaultValue;
                                }
                            }

                            // ======================== 文件解析工具函数 ========================

                            // 生成唯一文件名（支持重复导入，自动添加后缀）
                            function generateUniqueFileName(originalName) {
                                let displayName = originalName;
                                let counter = 2;
                                while (fileList.some(f => f.name === displayName)) {
                                    displayName = `${originalName} (${counter})`;
                                    counter++;
                                }
                                return displayName;
                            }

                            // 检查是否为表头行（包含指定的令牌）
                            function isHeaderRow(cellData) {
                                const firstCellText = String(cellData[0] || '').trim();
                                return HEADER_TOKENS.has(firstCellText);
                            }

                            // 清理数据行（移除无效行）
                            function cleanDataRows(rows, columns) {
                                return rows.filter(row => {
                                    if (!row || typeof row !== 'object') return false;

                                    const firstCol = String(row[columns[0]] || '').trim();

                                    // 跳过空行、表头行、Design开头的行
                                    if (!firstCol || HEADER_TOKENS.has(firstCol) || firstCol.startsWith('Design')) {
                                        return false;
                                    }

                                    return true;
                                });
                            }

                            // 处理零件号填充和数据清理
                            function processPartNumbers(rows, columns) {
                                try {
                                    if (!columns.includes(COLUMN_NAMES.PART_NUMBER)) {
                                        columns.unshift(COLUMN_NAMES.PART_NUMBER);
                                    }

                                    const hasPN = columns.includes(COLUMN_NAMES.PART_NUMBER);
                                    const hasSPN = columns.includes(COLUMN_NAMES.SUPPLIER_PART_NUMBER);

                                    if (!hasPN && !hasSPN) return rows;

                                    return rows.filter((row, index) => {
                                        try {
                                            const pn0 = row[COLUMN_NAMES.PART_NUMBER];
                                            const spn0 = row[COLUMN_NAMES.SUPPLIER_PART_NUMBER];
                                            const pn = normalizeKey(pn0);
                                            const spn = normalizeKey(spn0);

                                            // 如果零件号和供应商零件号都为空，丢弃该行
                                            if (!pn && !spn) return false;

                                            // 如果零件号为空但供应商零件号有值，填充零件号
                                            if (!pn && spn) {
                                                row[COLUMN_NAMES.PART_NUMBER] = spn0;
                                            }

                                            return true;
                                        } catch (err) {
                                            console.warn(`处理第${index + 1}行零件号数据时出错:`, err.message);
                                            return false; // 跳过有问题的行
                                        }
                                    });
                                } catch (err) {
                                    throw new Error(`零件号处理失败: ${err.message}`);
                                }
                            }

                            // 处理导线类型的三段号规范化
                            function processWireTypes(rows, columns) {
                                const colPN = columns.find(c => c === COLUMN_NAMES.PART_NUMBER);
                                const colType = columns.find(c => c && c.includes(COLUMN_NAMES.TYPE));

                                if (!colPN || !colType) return;

                                const TYPE_SET = WIRE_TYPES;

                                rows.forEach(r => {
                                    const t = r && r[colType];
                                    const aVal = r && r[colPN];
                                    const aStr = (aVal == null ? '' : String(aVal)).trim();

                                    if (TYPE_SET.has(String(t).trim())) {
                                        const parts = aStr.split('-');
                                        if (parts.length === 3) {
                                            r[colPN] = parts[0] + '-' + parts[1];
                                        }
                                    }
                                });
                            }

                            // 按零件号聚合数据
                            function aggregateByPartNumber(rows, columns) {
                                try {
                                    const colPN = columns.find(c => c === COLUMN_NAMES.PART_NUMBER);
                                    const colQty = columns.find(c => c && c.includes(COLUMN_NAMES.QUANTITY));

                                    if (!colPN || !colQty) return rows;

                                    const map = new Map();
                                    rows.forEach((row, index) => {
                                        try {
                                            const key = String((row && row[colPN]) ?? '').trim();
                                            if (!key) {
                                                console.warn(`第${index + 1}行: 零件号为空，跳过聚合`);
                                                return;
                                            }

                                            if (!map.has(key)) {
                                                const base = { ...row };
                                                const qtyValue = toNumber(base[colQty]);
                                                if (isNaN(qtyValue)) {
                                                    console.warn(`第${index + 1}行: 数量值"${base[colQty]}"无法转换为数字，使用0替代`);
                                                    base[colQty] = 0;
                                                } else {
                                                    base[colQty] = qtyValue;
                                                }
                                                map.set(key, base);
                                            } else {
                                                const agg = map.get(key);
                                                const currentQty = toNumber(agg[colQty]);
                                                const addQty = toNumber(row[colQty]);
                                                agg[colQty] = currentQty + addQty;
                                            }
                                        } catch (err) {
                                            console.warn(`处理第${index + 1}行聚合时出错:`, err.message);
                                        }
                                    });

                                    return Array.from(map.values());
                                } catch (err) {
                                    throw new Error(`数据聚合失败: ${err.message}`);
                                }
                            }

                            // ======================== HTML解析工具函数 ========================

                            // 解析HTML中的表格数据
                            function parseHTMLTables(htmlText) {
                                const parser = new DOMParser();
                                const doc = parser.parseFromString(htmlText, 'text/html');
                                const tables = doc.querySelectorAll('table');

                                const allRows = [];
                                const detectedCols = [];

                                tables.forEach((table, idx) => {
                                    try {
                                        const tableRows = table.querySelectorAll('tr');
                                        const matrix = Array.from(tableRows).map(tr => {
                                            const tds = tr.querySelectorAll('td, th');
                                            const texts = Array.from(tds).map(td => (td.textContent || '').trim());
                                            const hasMerge = Array.from(tds).some(td => {
                                                const cs = parseInt(td.getAttribute('colspan') || '1', 10);
                                                const rs = parseInt(td.getAttribute('rowspan') || '1', 10);
                                                return (cs > 1 || rs > 1);
                                            });
                                            return { texts, hasMerge };
                                        });

                                        const hdrIdx = matrix.findIndex(r => r.texts[0] && HEADER_TOKENS.has(r.texts[0].trim()));
                                        if (hdrIdx === -1) return; // 非数据表

                                        const headers = matrix[hdrIdx].texts.map(s => String(s).trim());
                                        headers.forEach(c => {
                                            if (c && !detectedCols.includes(c)) detectedCols.push(c);
                                        });

                                        // 处理数据行
                                        for (let i = hdrIdx + 1; i < matrix.length; i++) {
                                            const r = matrix[i];
                                            const first = (r.texts[0] || '').trim();

                                            if (HEADER_TOKENS.has(first) || r.hasMerge || first.startsWith('Design')) {
                                                continue;
                                            }

                                            const rowData = {};
                                            headers.forEach((h, idx2) => {
                                                rowData[h] = r.texts[idx2] != null ? String(r.texts[idx2]).trim() : '';
                                            });
                                            allRows.push(rowData);
                                        }
                                    } catch (err) {
                                        console.warn('解析HTML表格失败，已跳过: 表索引', idx, err);
                                    }
                                });

                                return { rows: allRows, columns: detectedCols };
                            }

                            // ======================== Excel解析工具函数 ========================

                            // 解析Excel文件数据
                            async function parseExcelFile(fileBuffer, fileName) {
                                try {
                                    const workbook = new ExcelJS.Workbook();
                                    await workbook.xlsx.load(fileBuffer);

                                    const ws = workbook.worksheets[0];
                                    if (!ws) throw new Error('工作表为空');

                                    const grid = [];
                                    const mergedRanges = new Set();

                                    // 处理合并单元格
                                    ws.mergeCells && Object.keys(ws.mergeCells).forEach(range => {
                                        const match = range.match(/^([A-Z]+)(\d+):([A-Z]+)(\d+)$/);
                                        if (match) {
                                            const [, startCol, startRow, endCol, endRow] = match;
                                            const startColNum = columnToNumber(startCol);
                                            const endColNum = columnToNumber(endCol);
                                            for (let r = parseInt(startRow); r <= parseInt(endRow); r++) {
                                                for (let c = startColNum; c <= endColNum; c++) {
                                                    mergedRanges.add(`${r}-${c}`);
                                                }
                                            }
                                        }
                                    });

                                    // 读取所有单元格数据
                                    let maxRow = 0, maxCol = 0;
                                    ws.eachRow({ includeEmpty: true }, (row, rowNumber) => {
                                        maxRow = Math.max(maxRow, rowNumber);
                                        row.eachCell({ includeEmpty: true }, (cell, colNumber) => {
                                            maxCol = Math.max(maxCol, colNumber);
                                            if (!grid[rowNumber]) grid[rowNumber] = [];
                                            const val = cell.value;
                                            grid[rowNumber][colNumber] = val != null ? String(val).trim() : '';
                                        });
                                    });

                                    // 查找表头
                                    let headerRowIndex = -1;
                                    let headers = [];
                                    for (let r = 1; r <= maxRow; r++) {
                                        const row = grid[r] || [];
                                        const firstCell = row[1] || '';
                                        if (HEADER_TOKENS.has(firstCell.trim())) {
                                            headerRowIndex = r;
                                            headers = row.slice(1).map(cell => String(cell || '').trim()).filter(h => h);
                                            break;
                                        }
                                    }

                                    if (headerRowIndex === -1) {
                                        // 回退策略：使用列索引作为列名
                                        headers = [];
                                        for (let c = 1; c <= maxCol; c++) {
                                            headers.push(`列${c}`);
                                        }
                                        headerRowIndex = 0;
                                    }

                                    // 提取数据行
                                    const rows = [];
                                    for (let r = headerRowIndex + 1; r <= maxRow; r++) {
                                        const row = grid[r] || [];
                                        const firstCell = (row[1] || '').trim();

                                        // 跳过无效行
                                        const hasMergedCell = row.some((_, colIdx) =>
                                            colIdx > 0 && mergedRanges.has(`${r}-${colIdx}`)
                                        );

                                        if (!firstCell ||
                                            HEADER_TOKENS.has(firstCell) ||
                                            firstCell.startsWith('Design') ||
                                            hasMergedCell) {
                                            continue;
                                        }

                                        const rowData = {};
                                        headers.forEach((header, idx) => {
                                            rowData[header] = row[idx + 1] != null ? String(row[idx + 1]).trim() : '';
                                        });
                                        rows.push(rowData);
                                    }

                                    return { rows, columns: headers };
                                } catch (err) {
                                    throw new Error(`Excel解析失败: ${err.message}`);
                                }
                            }

                            // 列名转数字（A=1, B=2, etc）
                            function columnToNumber(col) {
                                let result = 0;
                                for (let i = 0; i < col.length; i++) {
                                    result = result * 26 + (col.charCodeAt(i) - 64);
                                }
                                return result;
                            }

                            // ======================== 数据处理流水线 ========================

                            // 对原始数据执行完整的处理流程
                            function processRawData(rawRows, rawColumns) {
                                try {
                                    // 1. 零件号填充和数据清理
                                    let rows = processPartNumbers(rawRows, rawColumns);
                                    let columns = [...rawColumns];

                                    // 2. 导线类型规范化
                                    processWireTypes(rows, columns);

                                    // 3. 按零件号聚合
                                    rows = aggregateByPartNumber(rows, columns);

                                    // 4. 排序（按零件号自然升序）
                                    const colPN = columns.find(c => c === COLUMN_NAMES.PART_NUMBER);
                                    if (colPN) {
                                        rows.sort((a, b) => {
                                            const aVal = String(a[colPN] || '').trim();
                                            const bVal = String(b[colPN] || '').trim();
                                            return aVal.localeCompare(bVal, undefined, {
                                                numeric: true,
                                                sensitivity: 'accent'
                                            });
                                        });
                                    }

                                    return { rows, columns };
                                } catch (err) {
                                    console.error('数据处理失败:', err);
                                    throw new Error(`数据清洗失败: ${err.message || '未知错误'}`);
                                }
                            }

                            // ======================== 导出工具函数 ========================

                            // Excel样式常量
                            const EXCEL_COLORS = {
                                LIGHT_GRAY: 'FFF0F0F0',
                                RED: 'FFFF9999',
                                ORANGE: 'FFFFCC99',
                                BLUE: 'FF99CCFF',
                                GREEN: 'FF99FF99'
                            };

                            // 创建纯色填充
                            function createSolidFill(color) {
                                return { type: 'pattern', pattern: 'solid', fgColor: { argb: color } };
                            }

                            // 应用边框到指定范围
                            function applyBordersToRange(worksheet, startRow, startCol, endRow, endCol) {
                                for (let r = startRow; r <= endRow; r++) {
                                    for (let c = startCol; c <= endCol; c++) {
                                        const cell = worksheet.getCell(r, c);
                                        cell.border = {
                                            top: { style: 'thin' },
                                            left: { style: 'thin' },
                                            bottom: { style: 'thin' },
                                            right: { style: 'thin' }
                                        };
                                    }
                                }
                            }

                            // 自动调整列宽
                            function autoFitColumns(worksheet) {
                                worksheet.columns.forEach(column => {
                                    let maxLength = 0;
                                    column.eachCell({ includeEmpty: true }, (cell) => {
                                        const length = cell.value ? String(cell.value).length : 0;
                                        maxLength = Math.max(maxLength, length);
                                    });
                                    column.width = Math.min(Math.max(maxLength + 2, 10), 50);
                                });
                            }

                            // 清理文件名用于Excel工作表
                            function sanitizeSheetName(name, usedNames) {
                                let cleaned = String(name).replace(/[\\\/:\*\?\[\]]/g, '_');
                                cleaned = cleaned.substring(0, 31); // Excel工作表名限制

                                let candidate = cleaned;
                                let counter = 1;
                                while (usedNames.has(candidate)) {
                                    const suffix = `_${counter}`;
                                    const maxBase = 31 - suffix.length;
                                    candidate = cleaned.substring(0, maxBase) + suffix;
                                    counter++;
                                }
                                usedNames.add(candidate);
                                return candidate;
                            }

                            // 清理文件名用于下载
                            function sanitizeFileName(name) {
                                return String(name).replace(/[\\\/:\*\?\[\]<>|"]/g, '_');
                            }

                            // 下载工作簿
                            async function downloadWorkbook(workbook, filename) {
                                const buffer = await workbook.xlsx.writeBuffer();
                                const blob = new Blob([buffer], {
                                    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                                });
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = sanitizeFileName(filename);
                                a.click();
                                URL.revokeObjectURL(url);
                            }
                            // 预览容器显示控制：与 selectedFiles 解耦
                            const containerVisible = ref(false);
                            const displayedSelectedFiles = ref([]);
                            const previewWrap = ref(null);
                            const subtitle = ref('V2.6 - Beta 网页版');
                            const loading = ref(false);
                            const compareMode = ref(false);
                            const multiCompareMode = ref(false);
                            const compareBusy = ref(false);
                            const sheetReady = ref(false);
                            const faReady = ref(false);
                            // 统一的提示徽标（各一个）：加载中为蓝色，加载完成切换为绿色并淡出
                            const sheetBadge = reactive({ show: true, bgClass: 'bg-blue-600', text: 'ExcelJS 加载中...' });
                            const faBadge = reactive({ show: true, bgClass: 'bg-blue-600', text: '图标库加载中...' });                            // 颜色筛选：每个文件最多选一种颜色分类（再次点击清除）
                            const colorFilters = reactive({}); // { [fileName]: 'red'|'orange'|'blue'|'green' }

                            // 切换某个文件的颜色分类筛选（同一文件仅可选一种；再次点击关闭）
                            function toggleColorFilter(fileName, color) {
                                if (!compareMode.value || displayedSelectedFiles.value.length !== 2) return;
                                colorFilters[fileName] = (colorFilters[fileName] === color) ? undefined : color;
                            }
                            // 根据是否选中返回色块按钮的样式类名
                            function badgeClass(fileName, color) {
                                const active = colorFilters[fileName] === color;
                                const base = 'text-[10px] px-1.5 py-0.5 rounded min-w-[1.75rem] text-center border transition';
                                const map = {
                                    red: active ? 'bg-red-600 text-white border-red-600' : 'bg-red-50 text-red-700 border-red-100',
                                    orange: active ? 'bg-orange-500 text-white border-orange-500' : 'bg-orange-50 text-orange-700 border-orange-100',
                                    blue: active ? 'bg-blue-600 text-white border-blue-600' : 'bg-blue-50 text-blue-700 border-blue-100',
                                    green: active ? 'bg-green-600 text-white border-green-600' : 'bg-green-50 text-green-700 border-green-100',
                                };
                                return base + ' ' + map[color];
                            }

                            // 检测 Font Awesome 字体加载（优先检测字体，而非CSS）
                            function detectFontAwesome() {
                                if (document.fonts && document.fonts.load) {
                                    const markReady = () => {
                                        if (!faReady.value) faReady.value = true;
                                        faBadge.bgClass = 'bg-green-600';
                                        faBadge.text = '图标库加载完毕';
                                        setTimeout(() => { faBadge.show = false; }, 2000);
                                        console.log('Font Awesome 字体已加载');
                                    };
                                    const poll = async () => {
                                        try {
                                            // 尝试检测 solid 900 字重
                                            const r1 = await document.fonts.load('900 1em "Font Awesome 6 Free"');
                                            if (r1 && r1.length > 0) return markReady();
                                            // 退化检测常规权重
                                            const r2 = await document.fonts.load('400 1em "Font Awesome 6 Free"');
                                            if (r2 && r2.length > 0) return markReady();
                                            // 品牌字库（可选）
                                            const r3 = await document.fonts.load('400 1em "Font Awesome 6 Brands"');
                                            if (r3 && r3.length > 0) return markReady();
                                        } catch { }
                                        setTimeout(poll, 200);
                                    };
                                    poll();
                                } else {
                                    // 后备：退回到link onload（极少数旧浏览器）
                                    try {
                                        const links = Array.from(document.getElementsByTagName('link'));
                                        const faLink = links.find(l => (l.href || '').includes('font-awesome') || (l.href || '').includes('all.min.css'));
                                        if (faLink) {
                                            const fallbackMark = () => { if (!faReady.value) faReady.value = true; faBadge.bgClass = 'bg-green-600'; faBadge.text = '图标库加载完毕'; setTimeout(() => { faBadge.show = false; }, 2000); };
                                            if (faLink.sheet) { fallbackMark(); }
                                            else { faLink.addEventListener('load', fallbackMark); }
                                        }
                                    } catch { }
                                }
                            }
                            detectFontAwesome();

                            // 轮询检测 ExcelJS 是否已加载
                            const checkTimer = setInterval(() => {
                                if (window && window.ExcelJS) {
                                    sheetReady.value = true;
                                    sheetBadge.bgClass = 'bg-green-600';
                                    sheetBadge.text = 'ExcelJS 加载完毕';
                                    setTimeout(() => { sheetBadge.show = false; }, 2000);
                                    clearInterval(checkTimer);
                                    console.log('ExcelJS 已加载');
                                }
                            }, 100);

                            // 回到顶部：显示/隐藏逻辑（不依赖具体滚动容器，捕获任何滚动）
                            const showTop = ref(false);
                            const atTop = () => {
                                const y = window.scrollY || document.documentElement.scrollTop || document.body.scrollTop || 0;
                                if (y > 0) return false;
                                // 检查常见可滚容器是否滚动
                                const scrollers = document.querySelectorAll('[class*="overflow-"], [style*="overflow"], table, tbody');
                                for (const el of scrollers) {
                                    try {
                                        const cs = getComputedStyle(el);
                                        const oy = cs.overflowY || cs.overflow;
                                        if (/(auto|scroll)/.test(oy) && el.scrollHeight > el.clientHeight && el.scrollTop > 0) {
                                            return false;
                                        }
                                    } catch { }
                                }
                                return true;
                            };
                            const updateBackTop = () => { showTop.value = !atTop(); };
                            const forceShowBackTop = () => {
                                // 不强制显示，延后一次判断，避免在顶端上滚时误显
                                if (typeof requestAnimationFrame === 'function') {
                                    requestAnimationFrame(updateBackTop);
                                } else {
                                    setTimeout(updateBackTop, 0);
                                }
                            };
                            // 回到页面顶部（平滑滚动）
                            function scrollToTop() { window.scrollTo({ top: 0, behavior: 'smooth' }); }
                            onMounted(() => {
                                window.addEventListener('scroll', updateBackTop, { passive: true });
                                document.addEventListener('scroll', updateBackTop, { passive: true, capture: true });
                                document.addEventListener('wheel', forceShowBackTop, { passive: true });
                                document.addEventListener('touchmove', forceShowBackTop, { passive: true });
                                // 点击外部关闭筛选面板
                                const onDocClick = (e) => {
                                    const path = e.composedPath ? e.composedPath() : [];
                                    const isPanel = path.some(el => el && el.classList && el.classList.contains('filter-panel'));
                                    const isBtn = path.some(el => el && el.classList && el.classList.contains('filter-btn'));
                                    if (isPanel || isBtn) return;
                                    Object.keys(filterUI).forEach(fn => {
                                        const cols = filterUI[fn] || {};
                                        Object.keys(cols).forEach(cn => { cols[cn].open = false; });
                                    });
                                    openDropdownKey.value = '';
                                };
                                document.addEventListener('click', onDocClick, { capture: true });
                                // 滚动/缩放时重算打开面板位置
                                const recompute = () => {
                                    const key = openDropdownKey.value;
                                    if (!key) return;
                                    const btn = document.querySelector(`.filter-btn[data-filter-key="${CSS.escape(key)}"]`);
                                    if (!btn) return;
                                    const rect = btn.getBoundingClientRect();
                                    dropdownPositions[key] = { top: rect.bottom + 4, left: rect.left };
                                };
                                window.addEventListener('resize', recompute, { passive: true });
                                window.addEventListener('scroll', recompute, { passive: true });
                                updateBackTop();
                                // 存到实例上以便卸载时移除
                                window.__bom_onDocClick = onDocClick;
                                window.__bom_recompute = recompute;
                            });
                            onUnmounted(() => {
                                window.removeEventListener('scroll', updateBackTop);
                                document.removeEventListener('scroll', updateBackTop, { capture: true });
                                document.removeEventListener('wheel', forceShowBackTop);
                                document.removeEventListener('touchmove', forceShowBackTop);
                                if (window.__bom_onDocClick) document.removeEventListener('click', window.__bom_onDocClick, { capture: true });
                                if (window.__bom_recompute) {
                                    window.removeEventListener('resize', window.__bom_recompute);
                                    window.removeEventListener('scroll', window.__bom_recompute);
                                }
                            });

                            // 控制预览容器的显示/隐藏与内容切换 - 优化版本：
                            // - 展开：容器先展开，内容延迟淡入
                            // - 收回：内容先淡出但保持半透明，容器再收回
                            watch(selectedFiles, (newVal, oldVal) => {
                                const n = (newVal || []).length;
                                const o = (oldVal || []).length;

                                // 计算预览文件列表（最多2个，遵循挤掉规则）
                                let previewFiles = [];
                                if (n > 0) {
                                    if (n <= 2) {
                                        // 1-2个文件：直接预览
                                        previewFiles = [...newVal];
                                    } else {
                                        // 超过2个文件：只预览最后2个（最新选择的2个）
                                        previewFiles = newVal.slice(-2);
                                    }
                                }

                                if (previewFiles.length > 0 && !containerVisible.value) {
                                    // 初次显示：立即渲染内容并展开外层
                                    displayedSelectedFiles.value = [...previewFiles];
                                    containerVisible.value = true;
                                    return;
                                }
                                if (previewFiles.length === 0) {
                                    // 无预览：立即清空预览内容，让预览列表动画生效
                                    compareMode.value = false;
                                    displayedSelectedFiles.value = []; // 立即清空，触发预览列表的退出动画
                                    if (containerVisible.value) {
                                        // 延迟一点再关闭容器，让预览列表动画先完成
                                        setTimeout(() => {
                                            containerVisible.value = false;
                                        }, 100);
                                    }
                                    return;
                                }
                                // 其他情况：直接更新预览内容
                                displayedSelectedFiles.value = [...previewFiles];
                            }, { deep: true });                            // 预览容器过渡离开后清空内部内容 - 优化版本
                            function onPreviewContainerAfterLeave() {
                                // 外层容器收回完毕后清空内容，为下次展开做准备
                                if ((selectedFiles.value || []).length === 0) {
                                    displayedSelectedFiles.value = [];
                                }
                            }

                            // 预览容器自适应高度过渡钩子函数
                            function onBeforeEnter(el) {
                                el.style.height = '0';
                                el.style.opacity = '0';
                            }

                            function onEnter(el, done) {
                                // 强制重绘
                                el.offsetHeight;

                                // 获取自然高度
                                el.style.height = 'auto';
                                const height = el.offsetHeight;

                                // 重置为0开始动画
                                el.style.height = '0';

                                // 下一帧开始动画
                                requestAnimationFrame(() => {
                                    el.style.height = height + 'px';
                                    el.style.opacity = '1';

                                    // 动画完成后调用done
                                    setTimeout(done, 600);
                                });
                            }

                            function onAfterEnter(el) {
                                // 动画完成后移除固定高度，恢复自适应
                                el.style.height = 'auto';
                            }

                            function onBeforeLeave(el) {
                                // 记录当前高度
                                el.style.height = el.offsetHeight + 'px';
                                el.style.opacity = '1';
                            } function onLeave(el, done) {
                                // 强制重绘
                                el.offsetHeight;

                                // 下一帧开始收起动画
                                requestAnimationFrame(() => {
                                    el.style.height = '0';
                                    el.style.opacity = '0';

                                    // 动画完成后调用done
                                    setTimeout(done, 600);
                                });
                            }

                            // 计算卡片宽度：单卡 100%，双卡等分
                            function cardWidth(idx, fileName) {
                                const len = displayedSelectedFiles.value.length;
                                if (len === 1) return '100%';
                                // len >= 2 时，直接返回半宽，确保1→2和2→3时新卡片宽度一致
                                return 'calc((100% - 1.5rem) / 2)';
                            }

                            // 返回卡片样式（宽度、折行控制等）
                            function cardStyle(idx, fileName) {
                                const w = cardWidth(idx, fileName);
                                return {
                                    width: w,
                                    flexBasis: w,
                                    flexShrink: 0,
                                    minWidth: 0,
                                    overflow: 'hidden'
                                };
                            }                            // 文件解析与数据装载入口
                            async function handleFiles(e) {
                                // 导入流程总览（新版规则）：
                                // 1) 生成唯一显示名（允许重复导入，name, name (2), name (3)...）
                                // 2) HTML：在每个 <table> 内寻找“第一列为 零件号/供应商零件号/客户零件号”的行作为表头；
                                //    删除后续误入的表头行、包含合并单元格的行（colspan/rowspan>1）、第一列以 Design 开头的行；按表头对齐填充数据。
                                // 3) Excel：读取完整网格并识别合并区域；同样按“第一列令牌”识别表头并删除误入表头/合并/Design 行；
                                //    若找不到表头则回退到“列1..列N”的临时列名策略，尽量保证可用。
                                // 4) PN 填充：若“零件号”为空且“供应商零件号”也为空，则丢弃该行；若“零件号”为空但“供应商零件号”有值，则将“零件号”填为【供应商零件号】。
                                // 5) 规范化与聚合：对导线/WIRE/线束三段号规范为前两段；按“零件号”聚合并汇总“数量”。
                                // 6) 排序：按“零件号”自然升序（数字友好、忽略中英文大小写差异）。
                                if (!sheetReady.value || !window.ExcelJS) {
                                    alert('ExcelJS 还在加载中，请刷新页面后重新尝试');
                                    return;
                                }
                                const files = Array.from(e.target.files);
                                if (!files.length) return;
                                loading.value = true;
                                await Promise.all(files.map(file => new Promise(resolve => {
                                    // 不再跳过同名文件：生成一个唯一可显示名称（name, name (2), name (3)...）
                                    const displayName = generateUniqueFileName(file.name);
                                    const table = { name: displayName, columns: [], data: [], status: 'pending', errorMsg: '' };
                                    tables.push(table);
                                    fileList.push({ name: displayName, rows: 0, status: 'pending', errorMsg: '' });
                                    const reader = new FileReader();
                                    reader.onload = async (evt) => {
                                        try {
                                            let rows = [];
                                            let columns = [];
                                            if (file.name.endsWith('.html') || file.name.endsWith('.htm')) {
                                                const html = evt.target.result;
                                                // 在离屏容器中解析，按“第一列为 零件号/供应商零件号/客户零件号 的行”识别表头
                                                const container = document.createElement('div');
                                                container.innerHTML = html;
                                                const tbls = Array.from(container.getElementsByTagName('table'));
                                                const TOKENS = new Set(['零件号', '供应商零件号', '客户零件号']);
                                                const allRows = [];
                                                let detectedCols = [];
                                                tbls.forEach((tbl, idx) => {
                                                    try {
                                                        const trs = Array.from(tbl.querySelectorAll('tr'));
                                                        if (trs.length === 0) return;
                                                        // 将每一行解析为 文本数组 + 是否合并单元格 标记
                                                        const matrix = trs.map(tr => {
                                                            const tds = Array.from(tr.children);
                                                            const texts = tds.map(td => (td.textContent || '').trim());
                                                            const hasMerge = tds.some(td => {
                                                                const cs = parseInt(td.getAttribute('colspan') || '1', 10);
                                                                const rs = parseInt(td.getAttribute('rowspan') || '1', 10);
                                                                return (cs > 1 || rs > 1);
                                                            });
                                                            return { texts, hasMerge };
                                                        });
                                                        const hdrIdx = matrix.findIndex(r => (r.texts[0] || '') && TOKENS.has(String(r.texts[0]).trim()));
                                                        if (hdrIdx === -1) return; // 非数据表
                                                        const headers = matrix[hdrIdx].texts.map(s => String(s).trim());
                                                        // 合并列集合（保持顺序，避免重复）
                                                        headers.forEach(c => { if (!detectedCols.includes(c)) detectedCols.push(c); });
                                                        // 逐行写入数据（跳过后续误入的表头行；删除合并行；删除Design开头行）
                                                        for (let i = hdrIdx + 1; i < matrix.length; i++) {
                                                            const r = matrix[i];
                                                            const first = String((r.texts[0] || '')).trim();
                                                            if (TOKENS.has(first)) continue; // 删除误入的表头行
                                                            if (r.hasMerge) continue; // 删除合并单元格的行
                                                            if (first.startsWith('Design')) continue; // 删除第一列以Design开头
                                                            const o = {};
                                                            headers.forEach((h, idx2) => {
                                                                o[h] = (r.texts[idx2] != null ? String(r.texts[idx2]).trim() : '');
                                                            });
                                                            allRows.push(o);
                                                        }
                                                    } catch (err) {
                                                        console.warn('解析HTML表格失败，已跳过: 表索引', idx, err);
                                                    }
                                                });
                                                const parsed = parseHTMLTables(html);
                                                rows = parsed.rows;
                                                columns = parsed.columns;
                                            } else {
                                                const lower = file.name.toLowerCase();
                                                if (lower.endsWith('.xls')) {
                                                    throw new Error('暂不支持 .xls（请另存为 .xlsx 后导入）');
                                                }
                                                const wb = new ExcelJS.Workbook();
                                                await wb.xlsx.load(evt.target.result);
                                                if (!wb.worksheets || wb.worksheets.length === 0) {
                                                    throw new Error('Excel文件无有效Sheet');
                                                }
                                                const ws = wb.worksheets[0];
                                                // —— 解析策略要点 ——
                                                // 1) 使用 actualColumnCount/actualRowCount 获取网格范围，逐格标准化读取（避免空格/富文本/公式值混乱）。
                                                // 2) 识别合并区域并以“行”为粒度删除合并行；按“第一列令牌”定位表头并重建数据；未识别到表头时回退到临时列名。
                                                const colCount = ws.actualColumnCount || ws.columnCount || 0;
                                                const rowCount = ws.actualRowCount || ws.rowCount || 0;
                                                if (colCount === 0 || rowCount === 0) throw new Error('Excel为空');
                                                const normalize = (v) => {
                                                    if (v == null) return '';
                                                    if (typeof v === 'object') {
                                                        if (v.text != null) return String(v.text).trim();
                                                        if (v.result != null) return String(v.result).trim();
                                                        if (Array.isArray(v.richText)) return String(v.richText.map(t => t.text).join('')).trim();
                                                    }
                                                    // 日期/数字等统一转成字符串
                                                    try { return String(v).trim(); } catch { return ''; }
                                                };
                                                const arr = [];
                                                // 记录合并单元格所在的“行”集合，用于后续整体剔除（同一行中只要存在合并单元格就视为不可靠）。
                                                const mergedRowSet = new Set();
                                                try {
                                                    const merges = ws._merges || ws._mergesMap || ws.model && ws.model.merges;
                                                    // 支持多种内部表示
                                                    if (merges) {
                                                        const values = Array.isArray(merges) ? merges : (typeof merges === 'object' ? Object.values(merges) : []);
                                                        values.forEach(m => {
                                                            // m 可能是 "A1:B2" 或对象 {top,left,bottom,right}
                                                            if (m && typeof m === 'string') {
                                                                // 解析范围字符串
                                                                const m2 = m.split(':');
                                                                const toRC = (addr) => {
                                                                    const match = addr.match(/([A-Z]+)(\d+)/);
                                                                    if (!match) return { r: 0, c: 0 };
                                                                    const colStr = match[1];
                                                                    const rowStr = match[2];
                                                                    let c = 0;
                                                                    for (let i = 0; i < colStr.length; i++) {
                                                                        c = c * 26 + (colStr.charCodeAt(i) - 64);
                                                                    }
                                                                    return { r: parseInt(rowStr, 10) || 0, c };
                                                                };
                                                                const a = toRC(m2[0] || 'A1');
                                                                const b = toRC(m2[1] || m2[0] || 'A1');
                                                                const r1 = Math.min(a.r, b.r), r2 = Math.max(a.r, b.r);
                                                                for (let rr = r1; rr <= r2; rr++) mergedRowSet.add(rr);
                                                            } else if (m && typeof m === 'object' && m.top != null && m.bottom != null) {
                                                                for (let rr = m.top; rr <= m.bottom; rr++) mergedRowSet.add(rr);
                                                            }
                                                        });
                                                    }
                                                } catch { }

                                                for (let r = 1; r <= rowCount; r++) {
                                                    const row = ws.getRow(r);
                                                    // 兜底：若未识别到 merges，则尝试逐格判断
                                                    if (!mergedRowSet.has(r)) {
                                                        try {
                                                            let hasMerge = false;
                                                            for (let c = 1; c <= colCount; c++) {
                                                                const cell = row.getCell(c);
                                                                if (cell && (cell.isMerged || (cell.master && cell.address !== cell.master.address))) {
                                                                    hasMerge = true; break;
                                                                }
                                                            }
                                                            if (hasMerge) mergedRowSet.add(r);
                                                        } catch (mergeErr) {
                                                            console.warn(`检查第${r}行合并单元格时出错:`, mergeErr.message);
                                                        }
                                                    }
                                                    const one = new Array(colCount);
                                                    for (let c = 1; c <= colCount; c++) {
                                                        const cell = row.getCell(c);
                                                        one[c - 1] = normalize(cell && cell.value);
                                                    }
                                                    arr.push(one);
                                                }

                                                // 识别表头：第一列为“令牌”（零件号/供应商零件号/客户零件号）的一行即为表头；其后若再出现同类行，则视为误入表头并删除。
                                                const TOKENS = new Set(['零件号', '供应商零件号', '客户零件号']);
                                                let headerRowIdx = -1;
                                                for (let i = 0; i < arr.length; i++) {
                                                    const first = String((arr[i] && arr[i][0]) || '').trim();
                                                    if (TOKENS.has(first)) { headerRowIdx = i; break; }
                                                }
                                                if (headerRowIdx !== -1) {
                                                    const headerRow = arr[headerRowIdx];
                                                    columns = headerRow.map(v => String(v || '').trim());
                                                    const newRows = [];
                                                    for (let i = 0; i < arr.length; i++) {
                                                        if (i === headerRowIdx) continue;
                                                        const first = String((arr[i] && arr[i][0]) || '').trim();
                                                        // 删除误入表头行
                                                        if (TOKENS.has(first)) continue;
                                                        // 删除合并单元格的行
                                                        if (mergedRowSet.has(i + 1)) continue;
                                                        // 删除第一列以 Design 开头的行
                                                        if (first.startsWith('Design')) continue;
                                                        const o = {};
                                                        for (let j = 0; j < columns.length; j++) {
                                                            o[columns[j]] = arr[i][j] != null ? String(arr[i][j]).trim() : '';
                                                        }
                                                        newRows.push(o);
                                                    }
                                                    rows = newRows;
                                                } else {
                                                    // 后备：保持原有策略（临时列名 + 全部数据），下游步骤会尽量兼容
                                                    columns = Array.from({ length: colCount }, (_, i) => `列${i + 1}`);
                                                    rows = arr.map(a => {
                                                        const o = {};
                                                        for (let i = 0; i < colCount; i++) o[columns[i]] = a[i] ?? '';
                                                        return o;
                                                    });
                                                }
                                            }
                                            // 清洗逻辑（与新规则一致）：
                                            // 1) 表头已在解析阶段按“第一列=令牌”识别，并已移除误入表头行；合并行与第一列以 Design 开头的行也已删除。
                                            // 2) 对“零件号/供应商零件号”做统一规整 + PN 填充：
                                            //    - 仅对这两列进行：去除不可见字符(零宽/软连字符等)；去除多余空白，再 trim。
                                            //    - 若“零件号”为空且“供应商零件号”也为空 -> 删除该行；
                                            //    - 若“零件号”为空但“供应商零件号”有值 -> 将“零件号”填为【供应商零件号】。
                                            try {
                                                const hasPN = columns.includes('零件号');
                                                const hasSPN = columns.includes('供应商零件号');
                                                if (!hasPN) {
                                                    // 确保存在“零件号”列，便于后续流程
                                                    columns = ['零件号', ...columns.filter(c => c !== '零件号')];
                                                }
                                                if (hasPN || hasSPN) {
                                                    // 仅用于“零件号/供应商零件号”的规整函数
                                                    const normalizeKey = (v) => {
                                                        if (v == null) return '';
                                                        let s = String(v);
                                                        // 删除零宽字符与软连字符：U+200B..U+200D, U+FEFF, U+00AD
                                                        s = s.replace(/[\u200B-\u200D\uFEFF\u00AD]/g, '');
                                                        // 删除所有空白（空格/回车/制表/不间断空格等），不保留
                                                        s = s.replace(/[\s\u00A0]+/g, '').trim();
                                                        return s;
                                                    };
                                                    const kept = [];
                                                    rows.forEach(r => {
                                                        // 先对两列做规整（仅这两列）
                                                        const pn0 = (r && r['零件号']);
                                                        const spn0 = (r && r['供应商零件号']);
                                                        const pn = normalizeKey(pn0);
                                                        const spn = normalizeKey(spn0);
                                                        r['零件号'] = pn; // 确保“零件号”列写回为规整后的值
                                                        if (hasSPN && ('供应商零件号' in r)) r['供应商零件号'] = spn;

                                                        if (!pn) {
                                                            if (!spn) {
                                                                // 两者都空：丢弃
                                                                return;
                                                            }
                                                            // 仅 PN 为空：用【供应商零件号】填充
                                                            r['零件号'] = `【${spn}】`;
                                                        }
                                                        //（移除冗余）此处无需再次确保“零件号”存在，前面已统一写回
                                                        kept.push(r);
                                                    });
                                                    rows = kept;
                                                }
                                            } catch (err) {
                                                throw new Error(`零件号数据清理失败: ${err.message || '零件号或供应商零件号数据格式有误'}`);
                                            }

                                            // 4. 基于“类型”列的规则处理与聚合（在排序之前，基于“零件号”字段）
                                            try {
                                                const colPN = (columns && columns.includes('零件号')) ? '零件号' : null;
                                                const colType = columns.includes('类型') ? '类型' : null;
                                                const colQty = columns.includes('数量') ? '数量' : null;
                                                const TYPE_SET = new Set(['WIRE', '线束', '导线']);

                                                if (colPN && colType) {
                                                    // 4.1 PN 规范化：对 类型∈{WIRE, 线束, 导线} 的行，若 PN 形如 A-B-C（三段），则规范为 “A-B” 便于聚合。
                                                    rows.forEach(r => {
                                                        const t = r && r[colType];
                                                        const aVal = r && r[colPN];
                                                        const aStr = (aVal == null ? '' : String(aVal)).trim();
                                                        if (TYPE_SET.has(String(t).trim())) {
                                                            const parts = aStr.split('-');
                                                            if (parts.length === 3) {
                                                                r[colPN] = parts[0] + '-' + parts[1];
                                                            }
                                                        }
                                                    });
                                                }

                                                // 4.2 按“零件号”聚合：相同 PN 的“数量”相加，其它字段保留首行值
                                                if (colPN && colQty) {
                                                    const map = new Map();
                                                    rows.forEach(row => {
                                                        const key = String((row && row[colPN]) ?? '').trim();
                                                        if (!map.has(key)) {
                                                            // 浅拷贝一份作为聚合基
                                                            const base = { ...row };
                                                            base[colQty] = toNumber(base[colQty]);
                                                            map.set(key, base);
                                                        } else {
                                                            const agg = map.get(key);
                                                            agg[colQty] = toNumber(agg[colQty]) + toNumber(row[colQty]);
                                                        }
                                                    });
                                                    rows = Array.from(map.values());
                                                }
                                            } catch (e) {
                                                throw new Error(`导线类型处理或数据聚合失败: ${e && e.message ? e.message : '类型列或数量列数据格式有误'}`);
                                            }
                                            // 5. 排序：使用 Intl.Collator 的 numeric 自然排序，兼容中英文与数字混排。
                                            try {
                                                const primaryCol = (columns && columns.includes(COLUMN_NAMES.PART_NUMBER)) ? COLUMN_NAMES.PART_NUMBER : null;
                                                if (primaryCol) {
                                                    const collator = new Intl.Collator('zh-CN', { numeric: true, sensitivity: 'base' });
                                                    rows.sort((a, b) => {
                                                        const av = (a && typeof a === 'object') ? a[primaryCol] : '';
                                                        const bv = (b && typeof b === 'object') ? b[primaryCol] : '';
                                                        const as = av == null ? '' : String(av).trim();
                                                        const bs = bv == null ? '' : String(bv).trim();
                                                        return collator.compare(as, bs);
                                                    });
                                                }
                                            } catch (e) {
                                                throw new Error(`数据排序失败: ${e && e.message ? e.message : '零件号列数据无法正常排序'}`);
                                            }
                                            table.columns = columns;
                                            table.data = rows;
                                            table.status = 'success';
                                            table.errorMsg = '';
                                            const f = fileList.find(f => f.name === displayName);
                                            f.rows = table.data.length;
                                            f.status = 'success';
                                            f.errorMsg = '';
                                        } catch (err) {
                                            // 根据错误类型提供具体的错误信息
                                            let errorMessage = '';
                                            const originalError = err && err.message ? err.message : err;

                                            if (typeof originalError === 'string') {
                                                if (originalError.includes('Excel解析失败')) {
                                                    errorMessage = `Excel文件格式错误: ${originalError.replace('Excel解析失败: ', '')}`;
                                                } else if (originalError.includes('零件号数据清理失败')) {
                                                    errorMessage = `数据清洗阶段 - ${originalError}`;
                                                } else if (originalError.includes('导线类型处理或数据聚合失败')) {
                                                    errorMessage = `数据处理阶段 - ${originalError}`;
                                                } else if (originalError.includes('数据排序失败')) {
                                                    errorMessage = `数据整理阶段 - ${originalError}`;
                                                } else if (originalError.includes('暂不支持')) {
                                                    errorMessage = `文件格式不支持: ${originalError}`;
                                                } else if (originalError.includes('Excel文件无有效Sheet')) {
                                                    errorMessage = `Excel文件结构错误: 文件中没有有效的工作表`;
                                                } else if (originalError.includes('Excel为空')) {
                                                    errorMessage = `Excel文件内容错误: 工作表为空或没有数据`;
                                                } else {
                                                    errorMessage = `文件解析失败: ${originalError}`;
                                                }
                                            } else {
                                                errorMessage = `文件解析过程中出现未知错误`;
                                            }

                                            table.status = 'error';
                                            table.errorMsg = errorMessage;
                                            table.columns = [];
                                            table.data = [];
                                            const f = fileList.find(f => f.name === displayName);
                                            if (f) {
                                                f.rows = 0;
                                                f.status = 'error';
                                                f.errorMsg = errorMessage;
                                            }
                                            console.error('文件解析异常:', file.name, '错误详情:', err);
                                        }
                                        resolve();
                                    };
                                    if (file.name.endsWith('.html') || file.name.endsWith('.htm')) {
                                        reader.readAsText(file);
                                    } else {
                                        reader.readAsArrayBuffer(file);
                                    }
                                })));
                                loading.value = false;
                            }

                            // 删除文件
                            // 从列表与选中集合中移除文件
                            function removeFile(idx) {
                                if (idx < 0 || idx >= fileList.length) return;
                                const name = fileList[idx].name;
                                const tIdx = tables.findIndex(t => t.name === name);
                                if (tIdx !== -1) tables.splice(tIdx, 1);
                                fileList.splice(idx, 1);
                                const selIdx = selectedFiles.value.indexOf(name);
                                if (selIdx !== -1) selectedFiles.value.splice(selIdx, 1);
                            }

                            //（已移除）点击文件条目切换预览功能由 onFileCheckboxChange 统一处理

                            // 文件选择逻辑 - 分离选择和预览：
                            // 1. 文件选择：多选模式下无限制，普通模式下最多2个
                            // 2. 文件预览：无论哪种模式，预览区最多显示2个文件，遵循挤掉规则
                            function onFileCheckboxChange(name, checked, status) {
                                if (status === 'error') return;
                                const i = selectedFiles.value.indexOf(name);

                                if (checked) {
                                    if (i === -1) {
                                        // 文件选择逻辑
                                        if (multiCompareMode.value) {
                                            // 多选模式：可以选择无限个文件
                                            selectedFiles.value.push(name);
                                        } else {
                                            // 普通模式：最多选择2个文件
                                            if (selectedFiles.value.length >= 2) {
                                                selectedFiles.value.shift(); // 移除最早选择的文件
                                            }
                                            selectedFiles.value.push(name);
                                        }
                                    }
                                } else {
                                    // 取消选择
                                    if (i >= 0) selectedFiles.value.splice(i, 1);
                                }
                            }
                            // 多文件对比模式开关 - 改进版本：
                            // - 进入时：保持已选择的文件和预览状态
                            // - 退出时：保持已选择的文件和预览状态，并清空所有选中文件
                            function toggleMultiCompare() {
                                multiCompareMode.value = !multiCompareMode.value;
                                if (multiCompareMode.value) {
                                    // 进入多选模式：保持预览状态和已选择的文件
                                    compareMode.value = false;
                                    // 不关闭预览容器，不清空已选择文件
                                } else {
                                    // 退出多选模式（点击"取消多选"）：清空所有已选择的文件
                                    selectedFiles.value = [];
                                    containerVisible.value = false;
                                    compareMode.value = false;
                                }
                            }

                            // 多选模式下一键全选（过滤解析失败的项）
                            function selectAllFiles() {
                                if (!multiCompareMode.value) return;
                                const all = fileList.filter(f => f.status !== 'error').map(f => f.name);
                                selectedFiles.value.splice(0, selectedFiles.value.length, ...all);
                            }

                            // 获取表格
                            // 根据显示名获取表对象（columns、data 等）
                            function getTable(name) {
                                const t = tables.find(t => t.name === name);
                                if (!t || !t.columns || !t.data) {
                                    return { columns: [], data: [], status: 'error', errorMsg: '未找到' };
                                }
                                return t;
                            }

                            const filterUI = reactive({}); // 下拉开关与临时搜索/选择
                            const activeFilters = reactive({}); // 生效的按列筛选: { [fileName]: { [col]: Set(values) } }
                            // Teleport 筛选面板定位（fixed 到视口），key 由 fileName__col 组成
                            const dropdownPositions = reactive({}); // { [key]: { top, left } }
                            const openDropdownKey = ref('');

                            // 获取筛选面板的临时状态对象（不存在则初始化）
                            function keyOf(fileName, col) {
                                if (!filterUI[fileName]) filterUI[fileName] = {};
                                if (!filterUI[fileName][col]) filterUI[fileName][col] = { open: false, search: '', temp: new Set() };
                                return filterUI[fileName][col];
                            }

                            // 打开/关闭列筛选下拉面板，并计算定位
                            function toggleFilterDropdown(fileName, col, evt) {
                                const k = keyOf(fileName, col);
                                k.open = !k.open;
                                // 初始化临时集合为当前已选值
                                const selected = activeFilters[fileName] && activeFilters[fileName][col] ? activeFilters[fileName][col] : new Set();
                                k.temp = new Set(Array.from(selected));
                                // 记录打开的面板位置（按钮的可视区域 rect）
                                const key = `${fileName}__${col}`;
                                if (k.open && evt && evt.currentTarget) {
                                    const rect = evt.currentTarget.getBoundingClientRect();
                                    dropdownPositions[key] = { top: rect.bottom + 4, left: rect.left };
                                    openDropdownKey.value = key;
                                } else if (!k.open && openDropdownKey.value === key) {
                                    openDropdownKey.value = '';
                                }
                            }
                            // 关闭列筛选面板
                            function closeDropdown(fileName, col) {
                                const k = keyOf(fileName, col);
                                k.open = false;
                                if (openDropdownKey.value === `${fileName}__${col}`) openDropdownKey.value = '';
                            }
                            // 判断列筛选面板是否打开
                            function isDropdownOpen(fileName, col) { return !!(filterUI[fileName] && filterUI[fileName][col] && filterUI[fileName][col].open); }

                            // 获取列筛选的临时状态（含搜索与临时勾选）
                            function getFilterState(fileName, col) { return keyOf(fileName, col); }

                            // 计算下拉筛选面板的 fixed 定位样式
                            function dropdownStyle(fileName, col) {
                                const key = `${fileName}__${col}`;
                                const pos = dropdownPositions[key] || { top: 0, left: 0 };
                                const panelWidth = 256; // w-64
                                const panelHeight = 320; // 估算高度，内部滚动
                                let top = pos.top;
                                let left = pos.left;
                                const vw = window.innerWidth || document.documentElement.clientWidth;
                                const vh = window.innerHeight || document.documentElement.clientHeight;
                                if (left + panelWidth > vw - 8) left = Math.max(8, vw - panelWidth - 8);
                                if (top + panelHeight > vh - 8) top = Math.max(8, vh - panelHeight - 8);
                                return `top:${top}px;left:${left}px;`;
                            }

                            // 收集指定列的去重值列表（基于当前表数据，不受列筛选影响）
                            function collectDistinctValues(fileName, col) {
                                const table = getTable(fileName);
                                const set = new Set();
                                (table.data || []).forEach(r => set.add(String((r && r[col]) ?? '')));
                                return Array.from(set);
                            }

                            // 在去重值基础上应用搜索过滤并排序（供下拉面板显示）
                            function filteredDistinctValues(fileName, col) {
                                const state = getFilterState(fileName, col);
                                const search = (state.search || '').toLowerCase();
                                const collator = new Intl.Collator('zh-CN', { numeric: true, sensitivity: 'base' });
                                return collectDistinctValues(fileName, col)
                                    .filter(v => v.toLowerCase().includes(search))
                                    .sort((a, b) => collator.compare(a, b));
                            }

                            // 判断值是否在临时勾选集合中
                            function isValueChecked(fileName, col, val) { return getFilterState(fileName, col).temp.has(String(val ?? '')); }
                            // 切换下拉项的临时勾选状态
                            function onToggleValue(fileName, col, val, checked) {
                                const state = getFilterState(fileName, col);
                                const key = String(val ?? '');
                                if (checked) state.temp.add(key); else state.temp.delete(key);
                            }
                            // 勾选当前列的全部可选值
                            function selectAllValues(fileName, col) {
                                const state = getFilterState(fileName, col);
                                state.temp = new Set(collectDistinctValues(fileName, col).map(v => String(v ?? '')));
                            }
                            // 清除当前列的全部勾选值
                            function clearAllValues(fileName, col) { getFilterState(fileName, col).temp = new Set(); }

                            // 应用列筛选（将临时勾选写入正式筛选集合）
                            function applyFilter(fileName, col) {
                                if (!activeFilters[fileName]) activeFilters[fileName] = {};
                                activeFilters[fileName][col] = new Set(Array.from(getFilterState(fileName, col).temp));
                                closeDropdown(fileName, col);
                            }

                            // 判断某列是否存在有效的筛选条件
                            function isColumnFiltered(fileName, col) {
                                return !!(activeFilters[fileName] && activeFilters[fileName][col] && activeFilters[fileName][col].size > 0);
                            }

                            // 文件是否存在任意列筛选
                            function hasActiveFilters(fileName) {
                                const f = activeFilters[fileName] || {};
                                return Object.values(f).some(set => set && set.size > 0);
                            }

                            // 仅应用列值筛选（不应用颜色筛选），用于计数等
                            function baseFilteredRows(fileName) {
                                const table = getTable(fileName);
                                const rows = table.data || [];
                                const filters = activeFilters[fileName] || {};
                                const cols = table.columns || [];
                                const hasAny = Object.values(filters).some(set => set && set.size > 0);
                                return hasAny ? rows.filter(r => cols.every(col => {
                                    const set = filters[col];
                                    if (!set || set.size === 0) return true;
                                    const key = String((r && r[col]) ?? '');
                                    return set.has(key);
                                })) : rows;
                            }

                            // 综合列筛选与颜色分类筛选，返回最终用于渲染的行
                            function filteredRows(fileName) {
                                const table = getTable(fileName);
                                const cols = table.columns || [];
                                let result = baseFilteredRows(fileName);
                                // 颜色分类筛选（仅在对比模式且选了两表时生效）
                                if (compareMode.value && displayedSelectedFiles.value.length === 2 && colorFilters[fileName]) {
                                    const want = COLOR_TO_PRIORITY[colorFilters[fileName]];
                                    result = result.filter(r => categoryPriority(fileName, r) === want);
                                }
                                // 对比模式下，按底色优先级排序：红(0) 橙(1) 蓝(2) 绿(3)
                                if (compareMode.value && displayedSelectedFiles.value.length === 2 && cols.includes('零件号')) {
                                    const collator = new Intl.Collator('zh-CN', { numeric: true, sensitivity: 'base' });
                                    result = [...result].sort((a, b) => {
                                        const pa = categoryPriority(fileName, a);
                                        const pb = categoryPriority(fileName, b);
                                        if (pa !== pb) return pa - pb;
                                        const as = String((a && a['零件号']) ?? '').trim();
                                        const bs = String((b && b['零件号']) ?? '').trim();
                                        return collator.compare(as, bs);
                                    });
                                }
                                return result;
                            }

                            // 开关对比模式；开启时短暂进入忙碌态
                            async function toggleCompare() {
                                if (compareMode.value) {
                                    // 关闭对比：直接退出
                                    compareMode.value = false;
                                    return;
                                }
                                // 启动对比：进入忙碌态，短暂分析后开启
                                if (compareBusy.value) return;
                                compareBusy.value = true;
                                try {
                                    // 可以在此预热索引/缓存分类，当前做一个小延时模拟分析
                                    await new Promise(r => setTimeout(r, 500));
                                    compareMode.value = true;
                                } finally {
                                    compareBusy.value = false;
                                }
                            }

                            // 获取与当前文件成对的另一个文件名（仅在预览了两个文件时有效）
                            function getOtherFileName(current) {
                                if (displayedSelectedFiles.value.length !== 2) return null;
                                return displayedSelectedFiles.value[0] === current ? displayedSelectedFiles.value[1] : displayedSelectedFiles.value[0];
                            }

                            // 将数量字段转换为数字（兼容千位分隔逗号，空值为 0）
                            function toNumber(v) {
                                if (v == null || v === '') return 0;
                                const n = parseFloat(String(v).replace(/,/g, ''));
                                return isNaN(n) ? 0 : n;
                            }

                            // 为对表构建按“零件号/供应商零件号”的快速索引
                            function buildIndexes(otherName) {
                                const other = getTable(otherName);
                                const byPN = new Map();
                                const bySupplier = new Map();
                                if (other && Array.isArray(other.data)) {
                                    other.data.forEach(r => {
                                        const pn = String((r && r['零件号']) ?? '').trim();
                                        const spn = String((r && r['供应商零件号']) ?? '').trim();
                                        if (pn) byPN.set(pn, r);
                                        if (spn) bySupplier.set(spn, r);
                                    });
                                }
                                return { byPN, bySupplier };
                            }

                            // 构建“交叉索引”：用于按你的定义计算“橙色”（双方均为红的供应商零件号交集）
                            // 构建交叉索引：用于判断橙色（本表红、且供应商号落在对表红集合内）与蓝绿
                            function buildCrossIndex(currentName) {
                                const otherName = getOtherFileName(currentName);
                                const current = getTable(currentName);
                                const other = getTable(otherName);
                                const currentPNSet = new Set();
                                const otherByPN = new Map();
                                const otherRedSupplierSet = new Set();
                                if (current && Array.isArray(current.data)) {
                                    current.data.forEach(r => {
                                        const pn = String((r && r['零件号']) ?? '').trim();
                                        if (pn) currentPNSet.add(pn);
                                    });
                                }
                                if (other && Array.isArray(other.data)) {
                                    other.data.forEach(r => {
                                        const pn = String((r && r['零件号']) ?? '').trim();
                                        if (pn) otherByPN.set(pn, r);
                                    });
                                    // 另一张表的“红色”集合（相对于当前表）：PN 不在当前表中
                                    other.data.forEach(r => {
                                        const pn = String((r && r['零件号']) ?? '').trim();
                                        const spn = String((r && r['供应商零件号']) ?? '').trim();
                                        if (!pn || !spn) return;
                                        if (!currentPNSet.has(pn)) {
                                            otherRedSupplierSet.add(spn);
                                        }
                                    });
                                }
                                return { otherByPN, otherRedSupplierSet };
                            }

                            // 计算一行的对比分类优先级：红(0)/橙(1)/蓝(2)/绿(3)
                            function categoryPriority(fileName, row) {
                                if (!compareMode.value) return 3; // 默认当作绿色
                                const otherName = getOtherFileName(fileName);
                                if (!otherName) return 3;
                                const pn = String((row && row['零件号']) ?? '').trim();
                                const { otherByPN, otherRedSupplierSet } = buildCrossIndex(fileName);
                                const otherRow = pn ? otherByPN.get(pn) : undefined;
                                if (!otherRow) {
                                    // 本表红：若供应商零件号落在对表红集合内，则橙，否则红
                                    const spn = String((row && row['供应商零件号']) ?? '').trim();
                                    if (spn && otherRedSupplierSet.has(spn)) return 1; // 橙
                                    return 0; // 红
                                }
                                // PN 命中：比较数量
                                const q1 = toNumber(row['数量']);
                                const q2 = toNumber(otherRow['数量']);
                                if (q1 === q2) return 3; // 绿
                                return 2; // 蓝
                            }

                            // 根据分类优先级返回表格行的背景色 class
                            function rowBgClass(fileName, row) {
                                const p = categoryPriority(fileName, row);
                                switch (p) {
                                    case 0: return 'bg-red-50';
                                    case 1: return 'bg-orange-50';
                                    case 2: return 'bg-blue-50';
                                    case 3: return 'bg-green-50';
                                    default: return '';
                                }
                            }

                            // 统计当前文件在四种分类下的行数（基于基础列筛选，不含颜色筛选）
                            function categoryCounts(fileName) {
                                const counts = { red: 0, orange: 0, blue: 0, green: 0 };
                                const table = getTable(fileName);
                                if (!compareMode.value || displayedSelectedFiles.value.length !== 2 || !(table.columns || []).includes('零件号')) {
                                    return counts;
                                }
                                const { otherByPN, otherRedSupplierSet } = buildCrossIndex(fileName);
                                // 用不含颜色筛选的基础结果来统计数量
                                const rows = baseFilteredRows(fileName) || [];
                                rows.forEach(row => {
                                    const pn = String((row && row['零件号']) ?? '').trim();
                                    const otherRow = pn ? otherByPN.get(pn) : undefined;
                                    if (!otherRow) {
                                        const spn = String((row && row['供应商零件号']) ?? '').trim();
                                        if (spn && otherRedSupplierSet.has(spn)) counts.orange++; else counts.red++;
                                    } else {
                                        const q1 = toNumber(row['数量']);
                                        const q2 = toNumber(otherRow['数量']);
                                        if (q1 === q2) counts.green++; else counts.blue++;
                                    }
                                });
                                return counts;
                            }

                            // 计算“导线数量差值”列表（蓝色类且类型为导线/WIRE/线束），返回 [{ pn, type, q1, q2, diff }]
                            // 计算导线类的数量差值列表（包含所有导线类型，右表未找到时数量为0）
                            function wiresDiff(fileName) {
                                if (!compareMode.value || displayedSelectedFiles.value.length !== 2) return [];
                                const table = getTable(fileName);
                                if (!table || !(table.columns || []).includes('零件号')) return [];
                                const TYPE_SET = new Set(['WIRE', '线束', '导线']);
                                const otherName = getOtherFileName(fileName);
                                const { byPN } = buildIndexes(otherName);
                                const rows = filteredRows(fileName) || [];
                                const list = [];
                                rows.forEach(row => {
                                    const pn = String((row && row['零件号']) ?? '').trim();
                                    const tp = String((row && row['类型']) ?? '').trim();
                                    if (!pn || !TYPE_SET.has(tp)) return;
                                    const otherRow = byPN.get(pn);
                                    const q1 = toNumber(row['数量']);
                                    const q2 = otherRow ? toNumber(otherRow['数量']) : 0; // 右表未找到时数量为0
                                    // 包含所有导线类型零件，无论是否找到对应项
                                    list.push({ pn, type: tp, q1, q2, diff: q1 - q2 });
                                });
                                return list;
                            }

                            // ======================== 通用导出工具（可复用） ========================
                            const COLORS = {
                                LIGHT_RED: 'FFFFC8C8',   // #FFC8C8 - 未找到
                                ORANGE: 'FFF4B382',      // #F4B382 - 供应商零件号匹配
                                LIGHT_BLUE: 'FF99CCFF',  // #99CCFF - 数量不一致
                                LIGHT_GREEN: 'FFC8FFC8', // #C8FFC8 - 完全一致
                                GRAY: 'FFDCDCDC',        // #DCDCDC - 标题背景
                                LIGHT_GRAY: 'FFF0F0F0',  // #F0F0F0 - 表头背景
                            };
                            const fillSolid = (argb) => ({ type: 'pattern', pattern: 'solid', fgColor: { argb } });
                            function priorityFill(p) {
                                switch (p) {
                                    case 0: return fillSolid(COLORS.LIGHT_RED);
                                    case 1: return fillSolid(COLORS.ORANGE);
                                    case 2: return fillSolid(COLORS.LIGHT_BLUE);
                                    case 3: return fillSolid(COLORS.LIGHT_GREEN);
                                    default: return undefined;
                                }
                            }
                            function markText(p) { return ['未找到', '供应商匹配', '数量不同', '数量相同'][p] || ''; }

                            // 使用当前 UI 选择与排序导出（模拟“启动对比后点击导出”的行为）
                            async function exportCurrentSelection() {
                                const n = selectedFiles.value.length;
                                if (n === 0) return;
                                const wb = new ExcelJS.Workbook();
                                if (n === 1) {
                                    const f = selectedFiles.value[0];
                                    const t = getTable(f);
                                    const cols = (t.columns || []).slice();
                                    const rows = filteredRows(f) || [];
                                    const ws = wb.addWorksheet(sanitizeSheetName(f, new Set()));
                                    ws.addRow(cols); ws.getRow(1).font = { bold: true }; ws.getRow(1).fill = fillSolid(COLORS.LIGHT_GRAY);
                                    rows.forEach(r => ws.addRow(cols.map(c => r[c])));
                                    applyBordersForRange(ws, 1, 1, rows.length + 1, cols.length);
                                    autoFitColumns(ws);
                                    await downloadWorkbook(wb, `${sanitizeFileBase(f)}.xlsx`);
                                    return;
                                }

                                const [f1, f2] = selectedFiles.value;
                                const t1 = getTable(f1), t2 = getTable(f2);
                                const cols1 = (t1.columns || []).slice();
                                const cols2 = (t2.columns || []).slice();
                                if (compareMode.value) {
                                    // 着色对比表 A
                                    const wsA = wb.addWorksheet(sanitizeSheetName(f1, new Set()));
                                    wsA.addRow([...cols1, '对比标记']); wsA.getRow(1).font = { bold: true }; wsA.getRow(1).fill = fillSolid(COLORS.LIGHT_GRAY);
                                    (filteredRows(f1) || []).forEach(r => {
                                        const p = categoryPriority(f1, r);
                                        const vals = [...cols1.map(c => r[c]), markText(p)];
                                        const row = wsA.addRow(vals);
                                        const fill = priorityFill(p); if (fill) for (let c = 1; c <= vals.length; c++) row.getCell(c).fill = fill;
                                    });
                                    applyBordersForRange(wsA, 1, 1, wsA.rowCount, wsA.columnCount);
                                    autoFitColumns(wsA);

                                    // 着色对比表 B
                                    const wsB = wb.addWorksheet(sanitizeSheetName(f2, new Set(wb.worksheets.map(w => w.name))));
                                    wsB.addRow([...cols2, '对比标记']); wsB.getRow(1).font = { bold: true }; wsB.getRow(1).fill = fillSolid(COLORS.LIGHT_GRAY);
                                    (filteredRows(f2) || []).forEach(r => {
                                        const p = categoryPriority(f2, r);
                                        const vals = [...cols2.map(c => r[c]), markText(p)];
                                        const row = wsB.addRow(vals);
                                        const fill = priorityFill(p); if (fill) for (let c = 1; c <= vals.length; c++) row.getCell(c).fill = fill;
                                    });
                                    applyBordersForRange(wsB, 1, 1, wsB.rowCount, wsB.columnCount);
                                    autoFitColumns(wsB);

                                    // 汇总页（使用现有统计与差值函数）
                                    const wsS = wb.addWorksheet(sanitizeSheetName('对比结果', new Set(wb.worksheets.map(w => w.name))));
                                    wsS.getCell('A1').value = '图例'; wsS.getCell('A1').fill = fillSolid(COLORS.GRAY);
                                    const legends = [
                                        { text: '零件号不存在', color: COLORS.LIGHT_RED },
                                        { text: '供应商零件号匹配', color: COLORS.ORANGE },
                                        { text: '数量不一致', color: COLORS.LIGHT_BLUE },
                                        { text: '完全一致', color: COLORS.LIGHT_GREEN },
                                    ];
                                    for (let i = 0; i < legends.length; i++) { const r = 3 + i; wsS.getCell(r, 1).value = legends[i].text; wsS.getCell(r, 1).fill = fillSolid(legends[i].color); }
                                    const cntA = categoryCounts(f1); const cntB = categoryCounts(f2);
                                    const colsBase = ['零件号', '供应商零件号', '类型', '数量'];
                                    // A 面计数 + 明细（按当前 filteredRows 顺序）
                                    wsS.getCell('C1').value = sanitizeSheetName(f1); wsS.getCell('C1').fill = fillSolid(COLORS.GRAY);
                                    [cntA.red, cntA.orange, cntA.blue, cntA.green].forEach((val, i) => { const cell = wsS.getCell(2, 3 + i); cell.value = val; cell.fill = fillSolid([COLORS.LIGHT_RED, COLORS.ORANGE, COLORS.LIGHT_BLUE, COLORS.LIGHT_GREEN][i]); });
                                    colsBase.forEach((c, k) => { const cell = wsS.getCell(3, 3 + k); cell.value = c; cell.fill = fillSolid(COLORS.LIGHT_GRAY); cell.font = { bold: true }; });
                                    (filteredRows(f1) || []).forEach((r, i) => {
                                        const p = categoryPriority(f1, r);
                                        const vals = [r['零件号'], r['供应商零件号'], r['类型'], r['数量']];
                                        for (let j = 0; j < vals.length; j++) { const cell = wsS.getCell(4 + i, 3 + j); cell.value = vals[j]; const fill = priorityFill(p); if (fill) cell.fill = fill; }
                                    });
                                    // B 面
                                    wsS.getCell('H1').value = sanitizeSheetName(f2); wsS.getCell('H1').fill = fillSolid(COLORS.GRAY);
                                    [cntB.red, cntB.orange, cntB.blue, cntB.green].forEach((val, i) => { const cell = wsS.getCell(2, 8 + i); cell.value = val; cell.fill = fillSolid([COLORS.LIGHT_RED, COLORS.ORANGE, COLORS.LIGHT_BLUE, COLORS.LIGHT_GREEN][i]); });
                                    colsBase.forEach((c, k) => { const cell = wsS.getCell(3, 8 + k); cell.value = c; cell.fill = fillSolid(COLORS.LIGHT_GRAY); cell.font = { bold: true }; });
                                    (filteredRows(f2) || []).forEach((r, i) => {
                                        const p = categoryPriority(f2, r);
                                        const vals = [r['零件号'], r['供应商零件号'], r['类型'], r['数量']];
                                        for (let j = 0; j < vals.length; j++) { const cell = wsS.getCell(4 + i, 8 + j); cell.value = vals[j]; const fill = priorityFill(p); if (fill) cell.fill = fill; }
                                    });
                                    // 导线差值列表（复用 wiresDiff 排序与过滤）
                                    wsS.getCell('M1').value = '导线长度差值计算'; wsS.getCell('M1').fill = fillSolid(COLORS.GRAY);
                                    const head3 = ['零件号', '类型', '左表数量', '右表数量', '差值(左-右)'];
                                    head3.forEach((h, k) => { const cell = wsS.getCell(3, 13 + k); cell.value = h; cell.fill = fillSolid(COLORS.LIGHT_GRAY); cell.font = { bold: true }; });
                                    (wiresDiff(f1) || []).forEach((d, i) => {
                                        const vals = [d.pn, d.type, d.q1, d.q2, d.diff];
                                        const fill = d.diff > 0 ? fillSolid(COLORS.LIGHT_GREEN) : (d.diff < 0 ? fillSolid(COLORS.LIGHT_RED) : undefined);
                                        for (let j = 0; j < vals.length; j++) { const cell = wsS.getCell(4 + i, 13 + j); cell.value = vals[j]; if (fill) cell.fill = fill; }
                                    });
                                    const maxRow = Math.max(6, wsS.rowCount);
                                    applyBordersForRange(wsS, 1, 1, maxRow, 17);
                                    autoFitColumns(wsS);
                                    await downloadWorkbook(wb, `对比结果_${sanitizeFileBase(f1)}_VS_${sanitizeFileBase(f2)}.xlsx`);
                                } else {
                                    // 两表原样导出（按 filteredRows 当前顺序）
                                    const ws1 = wb.addWorksheet(sanitizeSheetName(f1, new Set()));
                                    ws1.addRow(cols1); ws1.getRow(1).font = { bold: true }; ws1.getRow(1).fill = fillSolid(COLORS.LIGHT_GRAY);
                                    (filteredRows(f1) || []).forEach(r => ws1.addRow(cols1.map(c => r[c])));
                                    applyBordersForRange(ws1, 1, 1, ws1.rowCount, ws1.columnCount); autoFitColumns(ws1);

                                    const ws2 = wb.addWorksheet(sanitizeSheetName(f2, new Set(wb.worksheets.map(w => w.name))));
                                    ws2.addRow(cols2); ws2.getRow(1).font = { bold: true }; ws2.getRow(1).fill = fillSolid(COLORS.LIGHT_GRAY);
                                    (filteredRows(f2) || []).forEach(r => ws2.addRow(cols2.map(c => r[c])));
                                    applyBordersForRange(ws2, 1, 1, ws2.rowCount, ws2.columnCount); autoFitColumns(ws2);

                                    await downloadWorkbook(wb, `两表导出_${sanitizeFileBase(f1)}_与_${sanitizeFileBase(f2)}.xlsx`);
                                }
                            }

                            async function downloadWorkbook(wb, filename) {
                                const buffer = await wb.xlsx.writeBuffer();
                                const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url; a.download = filename; a.click();
                                URL.revokeObjectURL(url);
                            }

                            // 导出：使用现有 UI 逻辑；多选时模拟人工“启动对比+导出”的逐对流程
                            async function exportCompare() {
                                try {
                                    if (!window.ExcelJS || selectedFiles.value.length === 0) return;
                                    const n = selectedFiles.value.length;
                                    // 多于两个文件：两两成对分别导出（模拟人工操作）
                                    if (n > 2) {
                                        const originalSel = [...selectedFiles.value];
                                        const originalCompare = compareMode.value;
                                        try {
                                            for (let i = 0; i < originalSel.length - 1; i++) {
                                                for (let j = i + 1; j < originalSel.length; j++) {
                                                    const a = originalSel[i];
                                                    const b = originalSel[j];
                                                    selectedFiles.value = [a, b];
                                                    if (!compareMode.value) await toggleCompare();
                                                    await exportCurrentSelection();
                                                }
                                            }
                                        } finally {
                                            selectedFiles.value = originalSel;
                                            compareMode.value = originalCompare && originalSel.length === 2; // 仅当原本是双选时保留
                                        }
                                        return;
                                    }

                                    // 单个文件：导出单表
                                    if (n === 1) {
                                        await exportCurrentSelection();
                                        return;
                                    }

                                    // 恰好两个文件
                                    await exportCurrentSelection();
                                } catch (e) {
                                    alert('导出失败：' + (e && e.message ? e.message : e));
                                }
                            }
                            // 自动适配列宽（基于文本长度，设置上下限）
                            function autoFitColumns(ws, minWidth = 10, maxWidth = 40) {
                                const cols = ws.columns || [];
                                cols.forEach(col => {
                                    let maxLen = 0;
                                    col.eachCell({ includeEmpty: true }, cell => {
                                        const v = cell.value;
                                        let l = 0;
                                        if (v == null) l = 0;
                                        else if (typeof v === 'object') {
                                            if (Array.isArray(v.richText)) {
                                                l = v.richText.map(t => t.text || '').join('').length;
                                            } else if (v.text != null) {
                                                l = String(v.text).length;
                                            } else {
                                                l = String(v).length;
                                            }
                                        } else {
                                            l = String(v).length;
                                        }
                                        if (l > maxLen) maxLen = l;
                                    });
                                    col.width = Math.min(maxWidth, Math.max(minWidth, maxLen + 2));
                                });
                            }

                            function applyBordersForRange(ws, r1, c1, r2, c2) {
                                // 容错：确保边界有效
                                r1 = Math.max(1, Math.floor(r1));
                                c1 = Math.max(1, Math.floor(c1));
                                r2 = Math.max(r1, Math.floor(r2));
                                c2 = Math.max(c1, Math.floor(c2));
                                for (let r = r1; r <= r2; r++) {
                                    for (let c = c1; c <= c2; c++) {
                                        const cell = ws.getCell(r, c);
                                        cell.border = {
                                            top: { style: 'thin' },
                                            left: { style: 'thin' },
                                            bottom: { style: 'thin' },
                                            right: { style: 'thin' },
                                        };
                                    }
                                }
                            }

                            //（移除未使用的 labelForCategory）

                            // 清洗为合法的 Excel 工作表名，并避免重名冲突
                            function sanitizeSheetName(name, existing = new Set()) {
                                const invalid = /[\\\/*?:\[\]]/g;
                                const baseRaw = String(name).replace(invalid, ' ').trim() || 'Sheet';
                                const cut = (s) => s.length > 31 ? s.slice(0, 31) : s;
                                let candidate = cut(baseRaw);
                                // 如果冲突，尝试追加 (2),(3)...，并保证总长<=31
                                let idx = 2;
                                while (existing.has(candidate)) {
                                    const suffix = ` (${idx})`;
                                    const maxLen = 31 - suffix.length;
                                    candidate = cut(baseRaw.slice(0, Math.max(1, maxLen)) + suffix);
                                    idx++;
                                }
                                existing.add(candidate);
                                return candidate;
                            }

                            // 生成可用于文件名的基础串（去扩展名并替换非法字符）
                            function sanitizeFileBase(name) {
                                return String(name).replace(/\.[^.]+$/, '').replace(/[^\u4e00-\u9fa5\w-]+/g, '_');
                            }

                            // 生成唯一显示名：name, name (2), name (3)...

                            return {
                                tables,
                                fileList,
                                selectedFiles,
                                subtitle,
                                loading,
                                compareMode,
                                multiCompareMode,
                                compareBusy,
                                sheetReady,
                                faReady,
                                sheetBadge,
                                faBadge,
                                // 回到顶部
                                showTop,
                                scrollToTop,
                                // 颜色分类筛选
                                toggleColorFilter,
                                badgeClass,
                                handleFiles,
                                exportCompare,
                                toggleCompare,
                                toggleMultiCompare,
                                onFileCheckboxChange,
                                selectAllFiles,
                                getTable,
                                removeFile,
                                toggleFilterDropdown,
                                isDropdownOpen,
                                getFilterState,
                                closeDropdown,
                                filteredDistinctValues,
                                isValueChecked,
                                onToggleValue,
                                selectAllValues,
                                clearAllValues,
                                applyFilter,
                                isColumnFiltered,
                                hasActiveFilters,
                                dropdownStyle,
                                filteredRows,
                                rowBgClass,
                                categoryCounts,
                                wiresDiff,
                                // 预览容器控制
                                containerVisible,
                                displayedSelectedFiles,
                                onPreviewContainerAfterLeave,
                                onBeforeEnter,
                                onEnter,
                                onAfterEnter,
                                onBeforeLeave,
                                onLeave,
                                cardWidth,
                                cardStyle,
                                previewWrap
                            };
                        }
                    }).mount('#app');

                    // ========== 页面增强功能 ==========

                    // 性能监控
                    if (window.performance) {
                        window.addEventListener('load', () => {
                            const perfData = performance.getEntriesByType('navigation')[0];
                            console.log(`页面加载时间: ${(perfData.loadEventEnd - perfData.fetchStart).toFixed(2)}ms`);
                        });
                    }

                    // 移动端适配
                    if (/Mobile|Android|iPhone|iPad/i.test(navigator.userAgent)) {
                        document.body.classList.add('mobile-device');

                        // 移动端表格横向滚动提示
                        const addSwipeHint = () => {
                            const tables = document.querySelectorAll('.overflow-auto');
                            tables.forEach(container => {
                                if (container.scrollWidth > container.clientWidth) {
                                    container.setAttribute('data-swipe-hint', '👈 左右滑动查看更多');
                                }
                            });
                        };

                        // 延迟执行，等待表格渲染
                        setTimeout(addSwipeHint, 1000);
                    }

                    // 键盘快捷键支持
                    document.addEventListener('keydown', (e) => {
                        // Ctrl/Cmd + Enter 快速导入文件
                        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                            e.preventDefault();
                            document.getElementById('fileInput')?.click();
                        }

                        // Esc 键关闭所有下拉菜单
                        if (e.key === 'Escape') {
                            const app = document.getElementById('app').__vue_app__;
                            if (app && app._instance) {
                                const vm = app._instance.ctx;
                                // 关闭所有筛选面板
                                Object.keys(vm.filterUI || {}).forEach(fileName => {
                                    const cols = vm.filterUI[fileName] || {};
                                    Object.keys(cols).forEach(colName => {
                                        cols[colName].open = false;
                                    });
                                });
                                vm.openDropdownKey = '';
                            }
                        }
                    });

                    // PWA 支持检测
                    if ('serviceWorker' in navigator) {
                        console.log('浏览器支持 Service Worker，可以考虑添加离线支持');
                    }

                </script>

                <!-- 增强的无障碍支持 -->
                <div id="sr-status" class="sr-only" aria-live="polite" aria-atomic="true"></div>

            </main>
        </div>
    </body>

</html>