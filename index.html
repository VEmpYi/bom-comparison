<!DOCTYPE html>
<html lang="zh-CN">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes">
        <meta name="description" content="专业的BOM表格对比分析工具，支持Excel和HTML文件导入对比">
        <meta name="keywords" content="BOM,表格对比,Excel,数据分析">
        <title>表格 BOM 对比分析</title>

        <!-- Preload critical resources -->
        <link rel="preload" href="https://cdn.tailwindcss.com" as="script">
        <link rel="preload" href="https://unpkg.com/vue@3/dist/vue.global.prod.js" as="script">

        <!-- Tailwind CSS v3 CDN -->
        <script src="https://cdn.tailwindcss.com"></script>
        <!-- Font Awesome 6 CDN with fallback -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
            onerror="this.onerror=null; this.href='https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css'">
        <!-- ExcelJS CDN (defer避免阻塞渲染) -->
        <script defer src="https://cdn.jsdelivr.net/npm/exceljs@4.4.0/dist/exceljs.min.js"></script>
        <!-- SheetJS (XLSX) for HTML/Table parsing -->
        <script defer src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
        <!-- Vue 3 全局构建 CDN with fallback -->
        <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"
            onerror="this.onerror=null; this.src='https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.prod.js'"></script>
        <style>
            /* ========== 现代化基础样式 ========== */
            :root {
                --primary-blue: #2563eb;
                --primary-green: #059669;
                --primary-red: #dc2626;
                --primary-orange: #ea580c;
                --bg-gradient: linear-gradient(135deg, #f0f9ff 0%, #ffffff 50%, #fef7f7 100%);
                --shadow-soft: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
                --shadow-card: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
                --border-radius: 12px;
                --transition-smooth: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            }

            /* 浮动式滚动条（不占用页面布局空间） */
            html {
                overflow-y: overlay;
                /* 滚动条浮在内容上方 */
                scrollbar-gutter: stable;
                /* 为滚动条预留稳定空间 */
            }

            /* 如果不支持 overlay，则隐藏滚动条 */
            @supports not (overflow-y: overlay) {
                html {
                    overflow-y: auto;
                    scrollbar-width: none;
                    /* Firefox */
                    -ms-overflow-style: none;
                    /* Internet Explorer 10+ */
                }

                html::-webkit-scrollbar {
                    display: none;
                    /* WebKit */
                }
            }

            /* 优雅的滚动条（支持更多浏览器） */
            ::-webkit-scrollbar {
                width: 12px;
                height: 12px;
            }

            ::-webkit-scrollbar-track {
                background: transparent;
                /* 透明背景，不影响页面布局 */
            }

            ::-webkit-scrollbar-thumb {
                background: rgba(156, 163, 175, 0.3);
                border-radius: 6px;
                border: 2px solid transparent;
                background-clip: content-box;
                transition: var(--transition-smooth);
            }

            ::-webkit-scrollbar-thumb:hover {
                background: rgba(107, 114, 128, 0.6);
                background-clip: content-box;
            }

            /* 滚动条角落处理 */
            ::-webkit-scrollbar-corner {
                background: transparent;
            }

            /* Firefox 浮动式滚动条 */
            * {
                scrollbar-width: thin;
                scrollbar-color: rgba(156, 163, 175, 0.3) transparent;
            }

            /* 如果不支持 overlay，则对所有元素隐藏滚动条 */
            @supports not (overflow-y: overlay) {
                * {
                    scrollbar-width: none;
                    /* Firefox */
                    -ms-overflow-style: none;
                    /* Internet Explorer 10+ */
                }

                *::-webkit-scrollbar {
                    display: none;
                    /* WebKit */
                }
            }

            /* 确保页面内容不因滚动条出现而偏移 */
            body {
                overflow-y: overlay;
                scrollbar-gutter: stable;
            }

            /* 如果不支持 overlay，body 也隐藏滚动条 */
            @supports not (overflow-y: overlay) {
                body {
                    overflow-y: auto;
                    scrollbar-width: none;
                    -ms-overflow-style: none;
                }

                body::-webkit-scrollbar {
                    display: none;
                }
            }

            /* 过渡动画 */
            .fade-enter-active,
            .fade-leave-active {
                transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            }

            .fade-enter-from,
            .fade-leave-to {
                opacity: 0;
                transform: translateY(-8px);
            }

            .fadeout-leave-active {
                transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            }

            .fadeout-leave-to {
                opacity: 0;
                transform: translateY(-8px);
            }

            /* 滑动过渡 */
            .slide-down-enter-active,
            .slide-down-leave-active {
                transition: max-height 0.5s cubic-bezier(0.4, 0, 0.2, 1);
                overflow: hidden;
            }

            .slide-down-enter-from {
                max-height: 0;
                opacity: 0;
            }

            .slide-down-enter-to {
                max-height: 9999px;
                opacity: 1;
            }

            .slide-down-leave-from {
                max-height: 9999px;
                opacity: 1;
            }

            .slide-down-leave-to {
                max-height: 0;
                opacity: 0;
            }

            /* 滑动过渡 - 自适应高度版本 */
            .slide-up-enter-active {
                transition: height 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.4s ease-in-out;
                overflow: hidden;
            }

            .slide-up-leave-active {
                transition: height 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.4s ease-in-out;
                overflow: hidden;
            }

            .slide-up-enter-from {
                height: 0;
                opacity: 0;
            }

            .slide-up-enter-to {
                height: auto;
                opacity: 1;
            }

            .slide-up-leave-from {
                height: auto;
                opacity: 1;
            }

            .slide-up-leave-to {
                height: 0;
                opacity: 0;
            }

            /* 内容淡入淡出 - 独立控制 */
            .content-fade-enter-active {
                transition: opacity 0.3s ease-in-out 0.2s;
                /* 延迟0.2s开始，让容器先展开一点 */
            }

            .content-fade-leave-active {
                transition: opacity 0.2s ease-in-out;
                /* 快速淡出，在容器收回前完成 */
            }

            .content-fade-enter-from {
                opacity: 0;
            }

            .content-fade-enter-to {
                opacity: 1;
            }

            .content-fade-leave-from {
                opacity: 1;
            }

            .content-fade-leave-to {
                opacity: 0.3;
                /* 保持微弱可见度，避免完全消失 */
            }

            /* 预览卡片切换动画 - 统一的过渡效果 */
            .preview-list-move,
            .preview-list-enter-active,
            .preview-list-leave-active {
                transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            }

            /* 预览卡片基础样式 */
            .preview-card {
                /* 移除宽度和flex-basis的transition，避免与Vue transition-group冲突 */
                transition: opacity 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            }

            /* 新文件进入：从右侧滑入 */
            .preview-list-enter-from {
                opacity: 0;
                transform: translateX(120%) scale(0.9);
            }

            .preview-list-enter-to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }

            /* 被挤掉的文件向左滑出 */
            .preview-list-leave-from {
                opacity: 1;
                transform: translateX(0) scale(1);
            }

            .preview-list-leave-to {
                opacity: 0;
                transform: translateX(-120%) scale(0.9);
            }

            /* 被移除的元素绝对定位，不影响布局 */
            .preview-list-leave-active {
                position: absolute;
                z-index: 0;
                width: calc((100% - 1.5rem) / 2);
                /* 保持原始宽度 */
            }

            /* 移动中的元素保持在上层 */
            .preview-list-move {
                z-index: 1;
            }

            /* 预览容器样式 - 确保动画空间 */
            .preview-container {
                position: relative;
                min-height: 200px;
                /* 确保有足够空间进行动画 */
                overflow: hidden;
                /* 隐藏滑出的元素 */
            }

            /* 现代化的按钮样式 */
            .btn-modern {
                transition: var(--transition-smooth);
                transform: translateY(0);
                box-shadow: var(--shadow-card);
            }

            .btn-modern:hover {
                transform: translateY(-2px);
                box-shadow: var(--shadow-soft);
            }

            .btn-modern:active {
                transform: translateY(0);
            }

            /* 增强的卡片样式 */
            .card-modern {
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.2);
                box-shadow: var(--shadow-card);
                transition: var(--transition-smooth), height 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            }

            .card-modern:hover {
                box-shadow: var(--shadow-soft);
                transform: translateY(-2px);
            }

            /* 文件列表容器hover效果 */
            .file-list-container {
                background: rgba(255, 255, 255, 0.8);
                border-radius: var(--border-radius);
                box-shadow: var(--shadow-card);
                transition: var(--transition-smooth);
            }

            .file-list-container:hover {
                background: rgba(255, 255, 255, 0.95);
                box-shadow: var(--shadow-soft);
                transform: translateY(-2px);
            }

            /* 文件列表项hover效果 */
            .file-item {
                transition: var(--transition-smooth);
                border-radius: var(--border-radius);
            }

            .file-item:hover {
                box-shadow: var(--shadow-soft);
                transform: translateY(-1px);
            }

            .file-item.selected {
                background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
                border: 1px solid #3b82f6;
                box-shadow: var(--shadow-card);
                transform: translateY(-1px);
            }

            .file-item.selected:hover {
                box-shadow: var(--shadow-soft);
                transform: translateY(-2px);
            }

            /* 预览卡片hover效果 */
            .preview-card {
                background: white;
                border-radius: var(--border-radius);
                box-shadow: var(--shadow-card);
                transition: var(--transition-smooth);
            }

            .preview-card:hover {
                box-shadow: var(--shadow-soft);
                transform: translateY(-3px);
            }

            /* 表格容器 - 移除hover效果 */
            .table-container {
                border-radius: var(--border-radius);
                overflow: hidden;
            }

            /* 筛选下拉菜单hover效果 */
            .filter-dropdown {
                transition: var(--transition-smooth);
                border-radius: var(--border-radius);
                box-shadow: var(--shadow-card);
            }

            .filter-dropdown:hover {
                box-shadow: var(--shadow-soft);
                transform: translateY(-1px);
            }

            /* 表格增强样式 */
            .table-modern {
                border-collapse: separate;
                border-spacing: 0;
                overflow: hidden;
                border-radius: var(--border-radius);
                box-shadow: var(--shadow-card);
            }

            .table-modern th {
                background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
                position: sticky;
                top: 0;
                z-index: 10;
            }

            .table-modern tbody tr:hover {
                background-color: rgba(59, 130, 246, 0.05);
                transform: scale(1.002);
                transition: var(--transition-smooth);
            }

            /* 改进的兼容性 */
            .touch-friendly {
                touch-action: manipulation;
                -webkit-tap-highlight-color: transparent;
            }

            /* 可访问性增强 */
            .focus-visible:focus {
                outline: 2px solid var(--primary-blue);
                outline-offset: 2px;
            }

            /* 性能优化 */
            .gpu-accelerated {
                transform: translateZ(0);
                will-change: transform;
            }

            /* 响应式优化 */
            @media (max-width: 768px) {
                .mobile-optimized {
                    padding: 12px;
                    font-size: 14px;
                }

                .btn-mobile {
                    min-height: 44px;
                    /* iOS建议的最小触摸目标 */
                    padding: 12px 16px;
                }
            }

            /* 老浏览器回退 */
            @supports not (backdrop-filter: blur(10px)) {
                .card-modern {
                    background: rgba(255, 255, 255, 0.98);
                }
            }
        </style>
    </head>

    <body class="min-h-screen bg-gradient-to-br from-blue-50 via-white to-rose-50">
        <div id="app" class="container mx-auto px-2 py-6 max-w-none w-[95vw]">
            <!-- 现代化的主容器 -->
            <main class="card-modern rounded-2xl p-8 gpu-accelerated" role="main">
                <!-- 标题区 - 增强可访问性 -->
                <header class="flex flex-col gap-4 mb-10 relative">
                    <div class="flex items-end gap-4 flex-wrap">
                        <h1
                            class="text-3xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent flex items-center gap-3">
                            <span
                                class="p-3 bg-gradient-to-br from-green-400 to-blue-500 rounded-xl text-white shadow-lg">
                                <i class="fa-solid fa-table" aria-hidden="true"></i>
                            </span>
                            表格 BOM 对比分析工具
                        </h1>
                        <span class="text-lg text-gray-600 font-medium">{{ subtitle }}</span>
                    </div>
                    <p class="text-gray-700 leading-relaxed">
                        🚀 专业的BOM表格对比分析工具，支持导入多份数据，并可对最多两份数据进行即时对比。
                        <strong class="text-amber-600">⚠️ 注意：导入的文件必须解密才可用。</strong>
                    </p>

                    <!-- 状态徽章区 -->
                    <div class="absolute right-0 top-0 flex flex-col items-end gap-2" aria-live="polite">
                        <transition name="fadeout">
                            <div v-if="sheetBadge.show"
                                :class="['text-sm font-medium text-white px-4 py-2 rounded-full shadow-lg', sheetBadge.bgClass]"
                                role="status">
                                {{ sheetBadge.text }}
                            </div>
                        </transition>
                        <transition name="fadeout">
                            <div v-if="sjsBadge && sjsBadge.show"
                                :class="['text-sm font-medium text-white px-4 py-2 rounded-full shadow-lg', sjsBadge.bgClass]"
                                role="status">
                                {{ sjsBadge.text }}
                            </div>
                        </transition>
                        <transition name="fadeout">
                            <div v-if="faBadge.show"
                                :class="['text-sm font-medium text-white px-4 py-2 rounded-full shadow-lg', faBadge.bgClass]"
                                role="status">
                                {{ faBadge.text }}
                            </div>
                        </transition>
                    </div>
                </header>
                <!-- 文件导入区 - 增强的拖拽体验 -->
                <section class="mb-8" aria-labelledby="file-import-heading">
                    <h2 id="file-import-heading"
                        class="block mb-4 text-lg font-bold text-gray-800 flex items-center gap-2">
                        <i class="fa-solid fa-cloud-upload-alt text-blue-500" aria-hidden="true"></i>
                        文件导入
                    </h2>
                    <div class="flex items-center gap-4 flex-wrap">
                        <input id="fileInput" type="file" multiple accept=".xlsx,.xls,.html,.htm" @change="handleFiles"
                            class="sr-only" aria-describedby="file-help" />
                        <label for="fileInput"
                            class="btn-modern px-6 py-3 rounded-xl bg-gradient-to-r from-blue-500 to-blue-600 text-white hover:from-blue-600 hover:to-blue-700 cursor-pointer font-semibold flex items-center gap-2 touch-friendly focus-visible"
                            tabindex="0" @keydown.enter="$refs.fileInput?.click()"
                            @keydown.space.prevent="$refs.fileInput?.click()">
                            <i class="fa-solid fa-folder-open" aria-hidden="true"></i>
                            选择文件
                        </label>
                        <div class="flex flex-col gap-1">
                            <span class="text-sm font-medium text-gray-600">支持格式：Excel (.xlsx, .xls) 和 HTML (.html,
                                .htm)</span>
                            <span id="file-help" class="text-xs text-gray-500">💡 支持批量导入，可同时选择多个文件</span>
                        </div>
                    </div>
                    <div v-if="loading"
                        class="mt-4 flex items-center gap-3 p-4 bg-blue-50 rounded-xl border border-blue-200"
                        role="status" aria-live="polite">
                        <div class="animate-spin w-5 h-5 border-2 border-blue-500 border-t-transparent rounded-full">
                        </div>
                        <span class="text-blue-700 font-medium">正在解析文件，请稍候...</span>
                    </div>
                </section>
                <!-- 文件列表区（滑动进入/离开 1s） -->
                <transition name="slide-down">
                    <div v-if="fileList.length" class="mb-8 file-list-container p-4">
                        <div class="font-semibold mb-2 text-gray-700 flex items-center gap-2">
                            <div class="flex items-center gap-2 min-w-0">
                                <i class="fa-solid fa-list"></i>
                                <span class="whitespace-nowrap">已导入文件（共 {{ fileList.length }} 个）：</span>
                                <span class="truncate"
                                    :class="['text-sm', multiCompareMode ? 'text-red-600' : 'text-gray-500']">
                                    {{ multiCompareMode ? '勾选多份文件导出分别对比结果' : '勾选文件即可预览（最多并列2个）' }}
                                </span>
                            </div>
                            <div class="flex-1"></div>
                            <div class="ml-4 flex items-center gap-2">
                                <!-- 多文件对比导出按钮（右侧，位于“全选”左侧） -->
                                <button type="button" :class="multiCompareMode
                                    ? 'px-2 py-1 text-xs rounded bg-red-600 text-white hover:bg-red-700'
                                    : 'px-2 py-1 text-xs rounded bg-blue-600 text-white hover:bg-blue-700'"
                                    @click="toggleMultiCompare">
                                    {{ multiCompareMode ? '取消多选' : '多文件对比导出' }}
                                </button>
                                <!-- 全选按钮：占位隐藏以避免抖动 -->
                                <button type="button" :class="[
                                    'px-2 py-1 text-xs rounded border',
                                    multiCompareMode ? 'border-red-300 text-red-600 hover:bg-red-50' : 'invisible pointer-events-none border-transparent'
                                ]" @click="selectAllFiles">
                                    全选
                                </button>
                            </div>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
                            <label v-for="(file, idx) in fileList" :key="file.name"
                                class="file-item flex items-center gap-2 cursor-pointer bg-blue-50 hover:bg-blue-100 rounded px-2 py-1"
                                :class="{ 'selected': selectedFiles.includes(file.name) }">
                                <input type="checkbox" :checked="selectedFiles.includes(file.name)"
                                    @change="onFileCheckboxChange(file.name, $event.target.checked, file.status)"
                                    :disabled="file.status === 'error'" class="accent-blue-500" />
                                <span class="truncate"><i
                                        class="fa-solid fa-file-excel text-green-500 mr-1"></i>{{ file.name }}</span>
                                <span class="text-xs text-gray-400">({{ file.rows }} 行)</span>
                                <span class="ml-2">
                                    <i v-if="file.status === 'pending'"
                                        class="fa-solid fa-spinner fa-spin text-blue-400"></i>
                                    <i v-else-if="file.status === 'success'"
                                        class="fa-solid fa-check text-green-500"></i>
                                    <i v-else-if="file.status === 'error'"
                                        class="fa-solid fa-circle-exclamation text-red-500" title="解析失败"></i>
                                </span>
                                <span v-if="file.status === 'error'"
                                    class="text-xs text-red-500 ml-2">{{ file.errorMsg }}</span>
                                <button type="button" @click.stop="removeFile(idx)"
                                    class="ml-2 px-2 py-1 text-xs text-red-500 hover:text-white hover:bg-red-500 rounded transition"><i
                                        class="fa-solid fa-trash"></i> 删除</button>
                            </label>
                        </div>
                        <div class="mt-2 text-xs" :class="multiCompareMode ? 'text-red-600' : 'text-gray-500'">
                            {{ multiCompareMode ? '勾选多份文件导出分别对比结果' : '勾选文件进行预览（最多并列2个）' }}
                        </div>
                    </div>
                </transition>
                <!-- 对比任务开关 + 图例 + 导出按钮 -->
                <div class="mb-4 flex items-center justify-between gap-4 flex-wrap">
                    <div class="flex items-center gap-3 flex-wrap">
                        <button type="button" @click="toggleCompare"
                            :disabled="(selectedFiles.length !== 2 && !compareMode) || compareBusy"
                            class="px-3 py-1.5 rounded text-sm font-medium shadow transition flex items-center gap-2"
                            :class="compareBusy ? 'bg-gray-400 text-white cursor-wait' : (compareMode ? 'bg-red-600 text-white hover:bg-red-700' : (selectedFiles.length !== 2 ? 'bg-gray-200 text-gray-400 cursor-not-allowed' : 'bg-blue-600 text-white hover:bg-blue-700'))">
                            <i v-if="compareBusy" class="fa-solid fa-spinner fa-spin"></i>
                            <i v-else :class="compareMode ? 'fa-solid fa-toggle-on' : 'fa-solid fa-toggle-off'"></i>
                            <span>{{ compareBusy ? '分析中...' : (compareMode ? '关闭对比' : '启动对比') }}</span>
                        </button>
                        <span v-if="selectedFiles.length !== 2" class="text-xs text-gray-400">需选择2个文件</span>
                        <!-- 色块图例 -->
                        <div class="flex items-center gap-3 text-xs text-gray-600">
                            <span class="inline-flex items-center gap-2"><span
                                    class="w-3 h-3 inline-block rounded bg-red-600"></span>该行未在对表中找到</span>
                            <span class="inline-flex items-center gap-2"><span
                                    class="w-3 h-3 inline-block rounded bg-orange-500"></span>该行虽未找到，但供应商零件号匹配</span>
                            <span class="inline-flex items-center gap-2"><span
                                    class="w-3 h-3 inline-block rounded bg-blue-600"></span>该行在对表找到，但数量不同</span>
                            <span class="inline-flex items-center gap-2"><span
                                    class="w-3 h-3 inline-block rounded bg-green-600"></span>该行与对表中数据一致</span>
                        </div>
                    </div>
                    <div>
                        <button type="button" @click="exportCompare" :class="[
                            'px-3 py-1.5 rounded text-sm font-medium shadow transition bg-emerald-600 text-white hover:bg-emerald-700',
                            (selectedFiles.length > 0 && sheetReady) ? '' : 'invisible pointer-events-none'
                        ]" :aria-hidden="!(selectedFiles.length > 0 && sheetReady)"
                            :tabindex="(selectedFiles.length > 0 && sheetReady) ? 0 : -1" title="导出数据">
                            <i class="fa-solid fa-file-arrow-down mr-1"></i>
                            导出数据
                        </button>
                    </div>
                </div>
                <!-- 并列预览区 - 优化动画效果 -->
                <transition name="slide-up" @before-enter="onBeforeEnter" @enter="onEnter" @after-enter="onAfterEnter"
                    @before-leave="onBeforeLeave" @leave="onLeave" @after-leave="onPreviewContainerAfterLeave">
                    <div v-if="containerVisible" ref="previewWrap" class="w-full">
                        <div class="w-full preview-container">
                            <transition-group name="preview-list" tag="div"
                                class="flex w-full flex-wrap gap-6 relative">
                                <div v-for="(fileName, idx) in displayedSelectedFiles" :key="fileName"
                                    class="preview-card p-4" :style="cardStyle(idx, fileName)">
                                    <div
                                        v-if="getTable(fileName) && Array.isArray(getTable(fileName).columns) && Array.isArray(getTable(fileName).data)">
                                        <div class="flex items-center justify-between mb-2">
                                            <span class="font-semibold text-blue-600"><i
                                                    class="fa-solid fa-file-excel text-green-500 mr-1"></i>{{ fileName }}</span>
                                            <div class="flex items-center gap-2">
                                                <div v-if="compareMode" class="flex items-center gap-1">
                                                    <label class="text-xs text-gray-500 mr-2">点击右侧色块筛选</label>
                                                    <button type="button" :class="badgeClass(fileName, 'red')"
                                                        title="点击筛选仅在对表中未找到的行"
                                                        @click.stop="toggleColorFilter(fileName, 'red')">{{ categoryCounts(fileName).red }}</button>
                                                    <button type="button" :class="badgeClass(fileName, 'orange')"
                                                        title="点击筛选未找到但仅在对表中供应商零件号匹配的行"
                                                        @click.stop="toggleColorFilter(fileName, 'orange')">{{ categoryCounts(fileName).orange }}</button>
                                                    <button type="button" :class="badgeClass(fileName, 'blue')"
                                                        title="点击筛选仅在对表中数量不同的行"
                                                        @click.stop="toggleColorFilter(fileName, 'blue')">{{ categoryCounts(fileName).blue }}</button>
                                                    <button type="button" :class="badgeClass(fileName, 'green')"
                                                        title="点击筛选仅在对表中数量相同的行"
                                                        @click.stop="toggleColorFilter(fileName, 'green')">{{ categoryCounts(fileName).green }}</button>
                                                </div>
                                                <span v-if="hasActiveFilters(fileName)"
                                                    class="text-xs text-blue-600">筛选后
                                                    {{ filteredRows(fileName).length }} 行</span>
                                                <span class="text-xs text-gray-700">共
                                                    {{ getTable(fileName).data.length }}
                                                    行</span>
                                            </div>
                                        </div>
                                        <div class="overflow-auto table-container">
                                            <table class="min-w-full text-sm border border-gray-200 rounded-lg">
                                                <thead>
                                                    <tr class="bg-blue-50">
                                                        <th v-for="col in getTable(fileName).columns" :key="col"
                                                            class="px-2 py-1 font-medium text-gray-700 border-b relative">
                                                            <div class="flex items-center gap-2">
                                                                <span class="truncate" :title="col">{{ col }}</span>
                                                                <button type="button"
                                                                    class="text-gray-500 hover:text-blue-600 filter-btn"
                                                                    :data-filter-key="fileName + '__' + col"
                                                                    @click.stop="toggleFilterDropdown(fileName, col, $event)"
                                                                    :title="isColumnFiltered(fileName, col) ? '已筛选' : '筛选'">
                                                                    <i class="fa-solid fa-filter"></i>
                                                                    <span v-if="isColumnFiltered(fileName, col)"
                                                                        class="inline-block w-1.5 h-1.5 rounded-full bg-blue-600 ml-1"></span>
                                                                </button>
                                                            </div>
                                                            <!-- 下拉筛选面板 -->
                                                            <teleport to="body">
                                                                <div v-if="isDropdownOpen(fileName, col)"
                                                                    class="filter-dropdown filter-panel fixed z-[10000] bg-white border rounded shadow-lg w-64 p-2"
                                                                    :style="dropdownStyle(fileName, col)">
                                                                    <div class="mb-2">
                                                                        <input type="text"
                                                                            class="w-full border rounded px-2 py-1 text-xs"
                                                                            placeholder="搜索..."
                                                                            v-model="getFilterState(fileName, col).search">
                                                                    </div>
                                                                    <div class="flex items-center gap-2 mb-2">
                                                                        <button type="button"
                                                                            class="text-xs px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded"
                                                                            @click.stop="selectAllValues(fileName, col)">全选</button>
                                                                        <button type="button"
                                                                            class="text-xs px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded"
                                                                            @click.stop="clearAllValues(fileName, col)">清空</button>
                                                                    </div>
                                                                    <div
                                                                        class="max-h-56 overflow-auto border rounded p-1 text-sm">
                                                                        <label
                                                                            v-for="val in filteredDistinctValues(fileName, col)"
                                                                            :key="val"
                                                                            class="flex items-center gap-2 px-1 py-0.5 hover:bg-gray-50 cursor-pointer">
                                                                            <input type="checkbox"
                                                                                :checked="isValueChecked(fileName, col, val)"
                                                                                @change="onToggleValue(fileName, col, val, $event.target.checked)">
                                                                            <span class="truncate"
                                                                                :title="val || '(空)'">{{ val || '(空)' }}</span>
                                                                        </label>
                                                                    </div>
                                                                    <div class="flex justify-end gap-2 mt-2">
                                                                        <button
                                                                            class="text-xs px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded"
                                                                            @click.stop="closeDropdown(fileName, col)">取消</button>
                                                                        <button
                                                                            class="text-xs px-2 py-1 bg-blue-600 text-white hover:bg-blue-700 rounded"
                                                                            @click.stop="applyFilter(fileName, col)">确定</button>
                                                                    </div>
                                                                </div>
                                                            </teleport>
                                                        </th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr v-for="(row, rIdx) in filteredRows(fileName)" :key="rIdx"
                                                        :class="['transition hover:bg-blue-100', compareMode ? rowBgClass(fileName, row) : '']">
                                                        <td v-for="col in getTable(fileName).columns" :key="col"
                                                            class="px-2 py-1 border-b">
                                                            {{ (row && typeof row === 'object' && col in row) ? row[col] : '' }}
                                                        </td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </div>
                                        <!-- 导线数量差值（仅在对比模式） -->
                                        <div v-if="compareMode" class="mt-3 border-t pt-2">
                                            <div class="text-sm font-medium text-gray-700 mb-1 flex items-center gap-2">
                                                <i class="fa-solid fa-code-compare text-blue-500"></i>导线数量差值
                                            </div>
                                            <div v-if="wiresDiff(fileName).length === 0" class="text-xs text-gray-400">
                                                无差异或无导线类型
                                            </div>
                                            <div v-else class="overflow-auto">
                                                <table class="min-w-full text-xs border border-gray-200 rounded">
                                                    <thead>
                                                        <tr class="bg-gray-50">
                                                            <th class="px-2 py-1 border-b text-left">零件号</th>
                                                            <th class="px-2 py-1 border-b text-left">类型</th>
                                                            <th class="px-2 py-1 border-b text-right">本表数量</th>
                                                            <th class="px-2 py-1 border-b text-right">对表数量</th>
                                                            <th class="px-2 py-1 border-b text-right">差值(本-对)</th>
                                                        </tr>
                                                    </thead>
                                                    <tbody>
                                                        <tr v-for="(d, i) in wiresDiff(fileName)" :key="i">
                                                            <td class="px-2 py-1 border-b">{{ d.pn }}</td>
                                                            <td class="px-2 py-1 border-b">{{ d.type }}</td>
                                                            <td class="px-2 py-1 border-b text-right">{{ d.q1 }}
                                                            </td>
                                                            <td class="px-2 py-1 border-b text-right">{{ d.q2 }}
                                                            </td>
                                                            <td class="px-2 py-1 border-b text-right"
                                                                :class="d.diff === 0 ? 'text-gray-500' : (d.diff > 0 ? 'text-green-600' : 'text-red-600')">
                                                                {{ d.diff }}
                                                            </td>
                                                        </tr>
                                                    </tbody>
                                                </table>
                                            </div>
                                        </div>
                                    </div>
                                    <div v-else class="text-red-500 text-sm">表格数据不存在或已被删除</div>
                            </transition-group>
                        </div>
                    </div>
                </transition>
                <!-- 视口回到顶部按钮（Teleport 到 body，确保贴可视区右下角） -->
                <teleport to="body">
                    <div
                        :class="['fixed bottom-0 right-0 z-[9999] transform transition-all duration-300', showTop ? 'translate-x-0 opacity-100' : 'translate-x-24 opacity-0 pointer-events-none']">
                        <button @click="scrollToTop" aria-label="回到顶部" title="回到顶部"
                            class="w-8 h-8 rounded-lg bg-blue-600 text-white shadow-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-300 flex items-center justify-center">
                            <i class="fa-solid fa-arrow-up text-xs"></i>
                        </button>
                    </div>
                </teleport>
                <script>
                    const { createApp, ref, reactive, onMounted, onUnmounted, watch, nextTick } = Vue;
                    createApp({
                        setup() {
                            // ======================== 核心状态与常量 ========================
                            const tables = reactive([]);
                            const fileList = reactive([]);
                            const selectedFiles = ref([]);

                            // 通用常量定义
                            const HEADER_TOKENS = new Set(['零件号', '供应商零件号', '客户零件号']);
                            const COLUMN_NAMES = {
                                PART_NUMBER: '零件号',
                                SUPPLIER_PART_NUMBER: '供应商零件号',
                                CUSTOMER_PART_NUMBER: '客户零件号',
                                QUANTITY: '数量',
                                TYPE: '类型'
                            };
                            const WIRE_TYPES = new Set(['WIRE', '线束', '导线']);
                            const COLOR_TO_PRIORITY = { red: 0, orange: 1, blue: 2, green: 3 };

                            // ======================== 通用工具函数 ========================

                            /* UNUSED: 由下方同名函数覆盖，保留一处定义即可
                            // 数字转换函数（处理千位分隔符，空值转0）
                            function toNumber(v) {
                                if (v == null || v === '') return 0;
                                const n = parseFloat(String(v).replace(/,/g, ''));
                                return isNaN(n) ? 0 : n;
                            }
                            */

                            // 规范化键名函数（零件号专用）
                            function normalizeKey(key) {
                                if (key == null) return '';
                                let s = String(key);
                                s = s.replace(/[\u200B-\u200D\uFEFF\u00AD]/g, '');
                                s = s.replace(/[\s\u00A0]+/g, '').trim();
                                return s;
                            }

                            /* UNUSED: 未在当前逻辑中调用
                            // 错误处理工具
                            function handleError(error, context = '') {
                                console.error(`Error ${context}:`, error);
                                const message = error?.message || String(error) || 'Unknown error';
                                alert(`操作失败${context ? ' (' + context + ')' : ''}: ${message}`);
                            }
                            */

                            // ======================== 通用字符串处理 ========================

                            /* UNUSED: 通用工具当前未使用
                            function safeString(value) { return value != null ? String(value).trim() : ''; }
                            function getStringProp(obj, prop) { return safeString(obj && obj[prop]); }
                            function isEmpty(str) { return !str || !String(str).trim(); }
                            function safeExecute(fn, defaultValue = null, context = '') {
                                try { return fn(); } catch (err) { if (context) console.warn(`Safe execution failed (${context}):`, err); return defaultValue; }
                            }
                            async function safeExecuteAsync(fn, defaultValue = null, context = '') {
                                try { return await fn(); } catch (err) { if (context) console.warn(`Async safe execution failed (${context}):`, err); return defaultValue; }
                            }
                            */

                            // ======================== 文件解析工具函数 ========================

                            // 生成唯一文件名（支持重复导入，自动添加后缀）
                            function generateUniqueFileName(originalName) {
                                let displayName = originalName;
                                let counter = 2;
                                while (fileList.some(f => f.name === displayName)) {
                                    displayName = `${originalName} (${counter})`;
                                    counter++;
                                }
                                return displayName;
                            }

                            /* UNUSED: 旧版表头与行清理逻辑，已被统一管道替代
                            function isHeaderRow(cellData) { const firstCellText = String(cellData[0] || '').trim(); return HEADER_TOKENS.has(firstCellText); }
                            function cleanDataRows(rows, columns) {
                                return rows.filter(row => {
                                    if (!row || typeof row !== 'object') return false;
                                    const firstCol = String(row[columns[0]] || '').trim();
                                    if (!firstCol || HEADER_TOKENS.has(firstCol) || firstCol.startsWith('Design')) return false;
                                    return true;
                                });
                            }
                            */

                            // 处理零件号填充和数据清理
                            function processPartNumbers(rows, columns) {
                                try {
                                    if (!columns.includes(COLUMN_NAMES.PART_NUMBER)) {
                                        columns.unshift(COLUMN_NAMES.PART_NUMBER);
                                    }

                                    const hasPN = columns.includes(COLUMN_NAMES.PART_NUMBER);
                                    const hasSPN = columns.includes(COLUMN_NAMES.SUPPLIER_PART_NUMBER);

                                    if (!hasPN && !hasSPN) return rows;

                                    return rows.filter((row, index) => {
                                        try {
                                            const pn0 = row[COLUMN_NAMES.PART_NUMBER];
                                            const spn0 = row[COLUMN_NAMES.SUPPLIER_PART_NUMBER];
                                            const pn = normalizeKey(pn0);
                                            const spn = normalizeKey(spn0);

                                            // 如果零件号和供应商零件号都为空，丢弃该行
                                            if (!pn && !spn) return false;

                                            // 如果零件号为空但供应商零件号有值，填充零件号
                                            if (!pn && spn) {
                                                row[COLUMN_NAMES.PART_NUMBER] = spn0;
                                            }

                                            return true;
                                        } catch (err) {
                                            console.warn(`处理第${index + 1}行零件号数据时出错:`, err.message);
                                            return false; // 跳过有问题的行
                                        }
                                    });
                                } catch (err) {
                                    throw new Error(`零件号处理失败: ${err.message}`);
                                }
                            }

                            // 处理导线类型的三段号规范化
                            function processWireTypes(rows, columns) {
                                const colPN = columns.find(c => c === COLUMN_NAMES.PART_NUMBER);
                                const colType = columns.find(c => c && c.includes(COLUMN_NAMES.TYPE));

                                if (!colPN || !colType) return;

                                const TYPE_SET = WIRE_TYPES;

                                rows.forEach(r => {
                                    const t = r && r[colType];
                                    const aVal = r && r[colPN];
                                    const aStr = (aVal == null ? '' : String(aVal)).trim();

                                    if (TYPE_SET.has(String(t).trim())) {
                                        const parts = aStr.split('-');
                                        if (parts.length === 3) {
                                            r[colPN] = parts[0] + '-' + parts[1];
                                        }
                                    }
                                });
                            }

                            // 按零件号聚合数据
                            function aggregateByPartNumber(rows, columns) {
                                try {
                                    const colPN = columns.find(c => c === COLUMN_NAMES.PART_NUMBER);
                                    const colQty = columns.find(c => c && c.includes(COLUMN_NAMES.QUANTITY));

                                    if (!colPN || !colQty) return rows;

                                    const map = new Map();
                                    rows.forEach((row, index) => {
                                        try {
                                            const key = String((row && row[colPN]) ?? '').trim();
                                            if (!key) {
                                                console.warn(`第${index + 1}行: 零件号为空，跳过聚合`);
                                                return;
                                            }

                                            if (!map.has(key)) {
                                                const base = { ...row };
                                                const qtyValue = toNumber(base[colQty]);
                                                if (isNaN(qtyValue)) {
                                                    console.warn(`第${index + 1}行: 数量值"${base[colQty]}"无法转换为数字，使用0替代`);
                                                    base[colQty] = 0;
                                                } else {
                                                    base[colQty] = qtyValue;
                                                }
                                                map.set(key, base);
                                            } else {
                                                const agg = map.get(key);
                                                const currentQty = toNumber(agg[colQty]);
                                                const addQty = toNumber(row[colQty]);
                                                agg[colQty] = currentQty + addQty;
                                            }
                                        } catch (err) {
                                            console.warn(`处理第${index + 1}行聚合时出错:`, err.message);
                                        }
                                    });

                                    return Array.from(map.values());
                                } catch (err) {
                                    throw new Error(`数据聚合失败: ${err.message}`);
                                }
                            }

                            // ======================== HTML解析工具函数 ========================

                            /* UNUSED: 已改为使用 SheetJS 解析 HTML
                            // function parseHTMLTables(htmlText) {}
                            */

                            // 使用 SheetJS 解析 HTML，按同义词识别表头并输出规范列名
                            function parseHTMLWithSheetJS(htmlText) {
                                if (!window.XLSX) return { rows: [], columns: [] };
                                const normalizeHeaderText = (v) => {
                                    if (v == null) return '';
                                    let s = String(v);
                                    s = s.replace(/[\u200B-\u200D\uFEFF\u00AD]/g, '');
                                    s = s.replace(/[\u00A0\s]+/g, ' ').trim();
                                    return s;
                                };
                                const toKey = (s) => normalizeHeaderText(s).toLowerCase();
                                const CANONICAL = {
                                    [COLUMN_NAMES.PART_NUMBER]: new Set(['零件号', 'pn', 'part no', 'part number', '物料号', '料号', '编号', '部件号']),
                                    [COLUMN_NAMES.SUPPLIER_PART_NUMBER]: new Set(['供应商零件号', '供应商料号', '供应商pn', '供应商编号', '供应商物料号']),
                                    [COLUMN_NAMES.CUSTOMER_PART_NUMBER]: new Set(['客户零件号', '客户料号', '客户pn']),
                                    [COLUMN_NAMES.TYPE]: new Set(['类型', '品类', '类别', 'type', '线束类型']),
                                    [COLUMN_NAMES.QUANTITY]: new Set(['数量', 'qty', '数量(pcs)', '数量（pcs）', '数目'])
                                };
                                const allSynonyms = new Map();
                                Object.entries(CANONICAL).forEach(([canon, set]) => {
                                    Array.from(set).forEach(s => allSynonyms.set(toKey(s), canon));
                                });
                                const wb = XLSX.read(htmlText, { type: 'string' });
                                const aggregatedRows = [];
                                const seenColsOrder = [];
                                const seenColsSet = new Set();
                                (wb.SheetNames || []).forEach(name => {
                                    const ws = wb.Sheets[name];
                                    if (!ws) return;
                                    const AOA = XLSX.utils.sheet_to_json(ws, { header: 1, defval: '' });
                                    if (!Array.isArray(AOA) || !AOA.length) return;
                                    const maxScan = Math.min(10, AOA.length);
                                    let headerIdx = -1, bestCount = -1;
                                    for (let i = 0; i < maxScan; i++) {
                                        const row = AOA[i] || [];
                                        let count = 0; const seen = new Set();
                                        row.forEach(cell => {
                                            const canon = allSynonyms.get(toKey(cell));
                                            if (canon && !seen.has(canon)) { seen.add(canon); count++; }
                                        });
                                        if (count > bestCount) { bestCount = count; headerIdx = i; }
                                    }
                                    if (headerIdx === -1) return;
                                    const rawHeader = (AOA[headerIdx] || []).map(h => normalizeHeaderText(h));
                                    const columns = rawHeader.map(h => allSynonyms.get(toKey(h)) || h);
                                    // 记录列顺序（合并多个表时保留首次出现顺序）
                                    columns.forEach(c => { if (c && !seenColsSet.has(c)) { seenColsSet.add(c); seenColsOrder.push(c); } });
                                    for (let r = headerIdx + 1; r < AOA.length; r++) {
                                        const row = AOA[r] || [];
                                        // 跳过空行
                                        if (!row.some(v => String(v || '').trim() !== '')) continue;
                                        const normCells = row.map(v => normalizeHeaderText(v));
                                        const first = normCells[0] || '';
                                        // 删除设计说明行
                                        if (first.startsWith('Design')) continue;
                                        // 与 XLSX 路径对齐的“重复表头”规则：
                                        // 只在第一列为令牌（零件号/供应商零件号/客户零件号）或可映射为“零件号”时才判定为表头
                                        const firstCanon = allSynonyms.get(toKey(first));
                                        if ((typeof HEADER_TOKENS !== 'undefined' && HEADER_TOKENS.has(first)) || firstCanon === COLUMN_NAMES.PART_NUMBER) {
                                            continue;
                                        }
                                        const o = {};
                                        for (let c = 0; c < columns.length; c++) {
                                            o[columns[c]] = row[c] != null ? String(row[c]).trim() : '';
                                        }
                                        aggregatedRows.push(o);
                                    }
                                });
                                // 需至少包含关键列
                                const hasKey = seenColsSet.has(COLUMN_NAMES.PART_NUMBER) || seenColsSet.has(COLUMN_NAMES.SUPPLIER_PART_NUMBER);
                                if (!hasKey) return { columns: [], rows: [] };
                                // 规范列顺序：优先关键列，其余按首次出现顺序
                                const preferred = [COLUMN_NAMES.PART_NUMBER, COLUMN_NAMES.SUPPLIER_PART_NUMBER, COLUMN_NAMES.CUSTOMER_PART_NUMBER, COLUMN_NAMES.TYPE, COLUMN_NAMES.QUANTITY];
                                const finalColumns = [];
                                preferred.forEach(k => { if (seenColsSet.has(k)) finalColumns.push(k); });
                                seenColsOrder.forEach(c => { if (!finalColumns.includes(c)) finalColumns.push(c); });
                                return { columns: finalColumns, rows: aggregatedRows };
                            }

                            // ======================== Excel解析工具函数 ========================

                            // 解析Excel文件数据
                            async function parseExcelFile(fileBuffer, fileName) {
                                try {
                                    const workbook = new ExcelJS.Workbook();
                                    await workbook.xlsx.load(fileBuffer);
                                    const ws = workbook.worksheets[0];
                                    if (!ws) throw new Error('工作表为空');
                                    // 拉平成 AOA（行、列均从1开始填充，保持与 grid 读取一致）
                                    const grid = [];
                                    const safeCellText = (cell) => {
                                        try {
                                            if (!cell) return '';
                                            if (cell.text != null) return String(cell.text).trim();
                                            const v = cell.value;
                                            if (v == null) return '';
                                            const t = typeof v;
                                            if (t === 'string' || t === 'number' || t === 'boolean') return String(v).trim();
                                            if (v && typeof v === 'object') {
                                                if (Array.isArray(v.richText)) return String(v.richText.map(x => x && x.text || '').join('')).trim();
                                                if (v.result != null) return String(v.result).trim();
                                                if (v.text != null) return String(v.text).trim();
                                            }
                                            // 最后兜底：可能某些对象自定义了无效 toString，捕获异常
                                            try { return String(v).trim(); } catch { return ''; }
                                        } catch { return ''; }
                                    };
                                    let maxRow = 0, maxCol = 0;
                                    ws.eachRow({ includeEmpty: true }, (row, r) => {
                                        maxRow = Math.max(maxRow, r);
                                        row.eachCell({ includeEmpty: true }, (cell, c) => {
                                            maxCol = Math.max(maxCol, c);
                                            if (!grid[r]) grid[r] = [];
                                            grid[r][c] = safeCellText(cell);
                                        });
                                    });
                                    // 规范化与同义词表
                                    const normalizeHeaderText = (v) => {
                                        if (v == null) return '';
                                        let s = String(v);
                                        s = s.replace(/[\u200B-\u200D\uFEFF\u00AD]/g, '');
                                        s = s.replace(/[\u00A0\s]+/g, ' ').trim();
                                        return s;
                                    };
                                    const toKey = (s) => normalizeHeaderText(s).toLowerCase();
                                    const CANONICAL = {
                                        [COLUMN_NAMES.PART_NUMBER]: new Set(['零件号', 'pn', 'part no', 'part number', '物料号', '料号', '编号', '部件号']),
                                        [COLUMN_NAMES.SUPPLIER_PART_NUMBER]: new Set(['供应商零件号', '供应商料号', '供应商pn', '供应商编号', '供应商物料号']),
                                        [COLUMN_NAMES.CUSTOMER_PART_NUMBER]: new Set(['客户零件号', '客户料号', '客户pn']),
                                        [COLUMN_NAMES.TYPE]: new Set(['类型', '品类', '类别', 'type', '线束类型']),
                                        [COLUMN_NAMES.QUANTITY]: new Set(['数量', 'qty', '数量(pcs)', '数量（pcs）', '数目'])
                                    };
                                    const allSynonyms = new Map();
                                    Object.entries(CANONICAL).forEach(([canon, set]) => {
                                        Array.from(set).forEach(s => allSynonyms.set(toKey(s), canon));
                                    });
                                    // 扫描前10行，选择同义匹配最多的作为表头
                                    let headerRowIndex = -1, bestCount = -1;
                                    const maxScan = Math.min(10, maxRow);
                                    for (let r = 1; r <= maxScan; r++) {
                                        const row = grid[r] || [];
                                        let count = 0; const seen = new Set();
                                        for (let c = 1; c <= maxCol; c++) {
                                            const canon = allSynonyms.get(toKey(row[c] || ''));
                                            if (canon && !seen.has(canon)) { seen.add(canon); count++; }
                                        }
                                        if (count > bestCount) { bestCount = count; headerRowIndex = r; }
                                    }
                                    if (headerRowIndex === -1) {
                                        // 兜底：尝试用第一列令牌定位；再不行用第1行
                                        for (let r = 1; r <= Math.min(maxRow, 100); r++) {
                                            const first = normalizeHeaderText(((grid[r] || [])[1]) || '');
                                            if (typeof HEADER_TOKENS !== 'undefined' && HEADER_TOKENS.has(first)) { headerRowIndex = r; break; }
                                        }
                                        if (headerRowIndex === -1) headerRowIndex = 1;
                                    }
                                    // 构建规范列名
                                    const rawHeader = [];
                                    for (let c = 1; c <= maxCol; c++) rawHeader.push(normalizeHeaderText((grid[headerRowIndex] || [])[c] || ''));
                                    const mapped = rawHeader.map(h => allSynonyms.get(toKey(h)) || h);
                                    const columns = [];
                                    const seenCols = new Set();
                                    mapped.forEach(c => { if (c && !seenCols.has(c)) { seenCols.add(c); columns.push(c); } });
                                    // 提取数据行
                                    const rows = [];
                                    for (let r = headerRowIndex + 1; r <= maxRow; r++) {
                                        // 判断空行
                                        let any = false; for (let c = 1; c <= maxCol; c++) { if ((grid[r] || [])[c] && String((grid[r] || [])[c]).trim() !== '') { any = true; break; } }
                                        if (!any) continue;
                                        const first = normalizeHeaderText(((grid[r] || [])[1]) || '');
                                        if (first.startsWith('Design')) continue;
                                        const firstCanon = allSynonyms.get(toKey(first));
                                        if ((typeof HEADER_TOKENS !== 'undefined' && HEADER_TOKENS.has(first)) || firstCanon === COLUMN_NAMES.PART_NUMBER) continue;
                                        const o = {};
                                        for (let i = 0; i < columns.length; i++) {
                                            const v = (grid[r] || [])[i + 1];
                                            o[columns[i]] = v != null ? String(v).trim() : '';
                                        }
                                        rows.push(o);
                                    }
                                    const hasKey = columns.includes(COLUMN_NAMES.PART_NUMBER) || columns.includes(COLUMN_NAMES.SUPPLIER_PART_NUMBER);
                                    if (!hasKey) throw new Error('未检测到关键列');
                                    return { rows, columns };
                                } catch (err) {
                                    throw new Error(`Excel解析失败: ${err.message}`);
                                }
                            }

                            /* UNUSED: 列名转数字
                            function columnToNumber(col) { let result = 0; for (let i = 0; i < col.length; i++) { result = result * 26 + (col.charCodeAt(i) - 64); } return result; }
                            */

                            // ======================== 数据处理流水线 ========================

                            // 对原始数据执行完整的处理流程
                            function processRawData(rawRows, rawColumns) {
                                try {
                                    // 1. 零件号填充和数据清理
                                    let rows = processPartNumbers(rawRows, rawColumns);
                                    let columns = [...rawColumns];

                                    // 2. 导线类型规范化
                                    processWireTypes(rows, columns);

                                    // 3. 按零件号聚合
                                    rows = aggregateByPartNumber(rows, columns);

                                    // 4. 排序（按零件号自然升序）
                                    const colPN = columns.find(c => c === COLUMN_NAMES.PART_NUMBER);
                                    if (colPN) {
                                        rows.sort((a, b) => {
                                            const aVal = String(a[colPN] || '').trim();
                                            const bVal = String(b[colPN] || '').trim();
                                            return aVal.localeCompare(bVal, undefined, {
                                                numeric: true,
                                                sensitivity: 'accent'
                                            });
                                        });
                                    }

                                    return { rows, columns };
                                } catch (err) {
                                    console.error('数据处理失败:', err);
                                    throw new Error(`数据清洗失败: ${err.message || '未知错误'}`);
                                }
                            }

                            // ======================== 导出工具函数 ========================

                            // Excel样式常量
                            const EXCEL_COLORS = {
                                LIGHT_GRAY: 'FFF0F0F0',
                                RED: 'FFFF9999',
                                ORANGE: 'FFFFCC99',
                                BLUE: 'FF99CCFF',
                                GREEN: 'FF99FF99'
                            };

                            // 创建纯色填充
                            function createSolidFill(color) {
                                return { type: 'pattern', pattern: 'solid', fgColor: { argb: color } };
                            }

                            /* UNUSED: 使用 applyBordersForRange 代替
                            // function applyBordersToRange(worksheet, startRow, startCol, endRow, endCol) {}
                            */

                            /* UNUSED: 下方有改进版 autoFitColumns
                            // function autoFitColumns(worksheet) {}
                            */

                            // 清理文件名用于Excel工作表
                            function sanitizeSheetName(name, usedNames) {
                                let cleaned = String(name).replace(/[\\\/:\*\?\[\]]/g, '_');
                                cleaned = cleaned.substring(0, 31); // Excel工作表名限制

                                let candidate = cleaned;
                                let counter = 1;
                                while (usedNames.has(candidate)) {
                                    const suffix = `_${counter}`;
                                    const maxBase = 31 - suffix.length;
                                    candidate = cleaned.substring(0, maxBase) + suffix;
                                    counter++;
                                }
                                usedNames.add(candidate);
                                return candidate;
                            }

                            /* UNUSED: 已改用 sanitizeFileBase 派生文件名
                            function sanitizeFileName(name) { return String(name).replace(/[\\\/:\*\?\[\]<>|"]/g, '_'); }
                            */

                            /* UNUSED: 下方已定义同名下载函数
                            // async function downloadWorkbook(workbook, filename) {}
                            */
                            // 预览容器显示控制：与 selectedFiles 解耦
                            const containerVisible = ref(false);
                            const displayedSelectedFiles = ref([]);
                            const previewWrap = ref(null);
                            const subtitle = ref('V2.6.1 - Beta 网页版 HTML解析补丁上线');
                            const loading = ref(false);
                            const compareMode = ref(false);
                            const multiCompareMode = ref(false);
                            const compareBusy = ref(false);
                            const dataEpoch = ref(0); // 数据版本号：每次装载/删除文件后自增，用于缓存失效
                            // 原始行索引映射：fileName -> WeakMap(rowObj -> index)
                            const originalIndexMaps = new Map();
                            // 比对结果缓存：fileName -> { categories: Int8Array|number[], wiresDiff: Array<{pn,type,q1,q2,diff}> }
                            const compareCache = reactive({});
                            let compareWorker = null;
                            function ensureCompareWorker() {
                                if (compareWorker) return compareWorker;
                                const workerCode = `
                                    self.onmessage = (e) => {
                                        const { left, right } = e.data || {};
                                        const TYPE_SET = new Set(['WIRE','线束','导线']);
                                        const toNumber = (v) => { if (v == null || v === '') return 0; const n = parseFloat(String(v).replace(/,/g,'')); return isNaN(n)?0:n; };
                                        const leftRows = Array.isArray(left?.rows) ? left.rows : [];
                                        const rightRows = Array.isArray(right?.rows) ? right.rows : [];
                                        // 构建右表索引与红集合
                                        const leftPNSet = new Set();
                                        leftRows.forEach(r=>{ const pn=String((r&&r['零件号'])??'').trim(); if(pn) leftPNSet.add(pn); });
                                        const rightByPN = new Map();
                                        rightRows.forEach(r=>{ const pn=String((r&&r['零件号'])??'').trim(); if(pn) rightByPN.set(pn,r); });
                                        const rightRedSupplierSet = new Set();
                                        rightRows.forEach(r=>{ const pn=String((r&&r['零件号'])??'').trim(); const spn=String((r&&r['供应商零件号'])??'').trim(); if(!pn||!spn) return; if(!leftPNSet.has(pn)) rightRedSupplierSet.add(spn); });
                                        // 计算左->右分类
                                        const categoriesL = new Array(leftRows.length).fill(3);
                                        let countsL = {red:0, orange:0, blue:0, green:0};
                                        for (let i=0;i<leftRows.length;i++){
                                            const row = leftRows[i];
                                            const pn = String((row&&row['零件号'])??'').trim();
                                            const other = pn? rightByPN.get(pn): undefined;
                                            let cat = 3;
                                            if(!other){
                                                const spn = String((row&&row['供应商零件号'])??'').trim();
                                                cat = (spn && rightRedSupplierSet.has(spn)) ? 1 : 0;
                                            } else {
                                                const q1 = toNumber(row['数量']);
                                                const q2 = toNumber(other['数量']);
                                                cat = (q1===q2)?3:2;
                                            }
                                            categoriesL[i]=cat;
                                            if (cat===0) countsL.red++; else if(cat===1) countsL.orange++; else if(cat===2) countsL.blue++; else countsL.green++;
                                        }
                                        // wiresDiff（左表）
                                        const wiresL = [];
                                        for(let i=0;i<leftRows.length;i++){
                                            const row = leftRows[i];
                                            const pn = String((row&&row['零件号'])??'').trim();
                                            const tp = String((row&&row['类型'])??'').trim();
                                            if(!pn || !TYPE_SET.has(tp)) continue;
                                            const other = rightByPN.get(pn);
                                            const q1 = toNumber(row['数量']);
                                            const q2 = other? toNumber(other['数量']) : 0;
                                            wiresL.push({ pn, type: tp, q1, q2, diff: q1 - q2 });
                                        }
                                        // 右->左（为对称显示预先算好）
                                        const rightPNSet = new Set();
                                        rightRows.forEach(r=>{ const pn=String((r&&r['零件号'])??'').trim(); if(pn) rightPNSet.add(pn); });
                                        const leftByPN = new Map();
                                        leftRows.forEach(r=>{ const pn=String((r&&r['零件号'])??'').trim(); if(pn) leftByPN.set(pn,r); });
                                        const leftRedSupplierSet = new Set();
                                        leftRows.forEach(r=>{ const pn=String((r&&r['零件号'])??'').trim(); const spn=String((r&&r['供应商零件号'])??'').trim(); if(!pn||!spn) return; if(!rightPNSet.has(pn)) leftRedSupplierSet.add(spn); });
                                        const categoriesR = new Array(rightRows.length).fill(3);
                                        let countsR = {red:0, orange:0, blue:0, green:0};
                                        for (let i=0;i<rightRows.length;i++){
                                            const row = rightRows[i];
                                            const pn = String((row&&row['零件号'])??'').trim();
                                            const other = pn? leftByPN.get(pn): undefined;
                                            let cat = 3;
                                            if(!other){
                                                const spn = String((row&&row['供应商零件号'])??'').trim();
                                                cat = (spn && leftRedSupplierSet.has(spn)) ? 1 : 0;
                                            } else {
                                                const q1 = toNumber(row['数量']);
                                                const q2 = toNumber(other['数量']);
                                                cat = (q1===q2)?3:2;
                                            }
                                            categoriesR[i]=cat;
                                            if (cat===0) countsR.red++; else if(cat===1) countsR.orange++; else if(cat===2) countsR.blue++; else countsR.green++;
                                        }
                                        const wiresR = [];
                                        for(let i=0;i<rightRows.length;i++){
                                            const row = rightRows[i];
                                            const pn = String((row&&row['零件号'])??'').trim();
                                            const tp = String((row&&row['类型'])??'').trim();
                                            if(!pn || !TYPE_SET.has(tp)) continue;
                                            const other = leftByPN.get(pn);
                                            const q1 = toNumber(row['数量']);
                                            const q2 = other? toNumber(other['数量']) : 0;
                                            wiresR.push({ pn, type: tp, q1, q2, diff: q1 - q2 });
                                        }
                                        self.postMessage({
                                            left: { name: left?.name, categories: categoriesL, counts: countsL, wires: wiresL },
                                            right: { name: right?.name, categories: categoriesR, counts: countsR, wires: wiresR }
                                        });
                                    };
                                `;
                                const blob = new Blob([workerCode], { type: 'application/javascript' });
                                compareWorker = new Worker(URL.createObjectURL(blob));
                                compareWorker.onmessage = (e) => {
                                    const res = e.data || {};
                                    if (res.left?.name) compareCache[res.left.name] = { categories: res.left.categories, counts: res.left.counts, wires: res.left.wires };
                                    if (res.right?.name) compareCache[res.right.name] = { categories: res.right.categories, counts: res.right.counts, wires: res.right.wires };
                                    compareBusy.value = false;
                                    compareMode.value = true;
                                };
                                // 避免 worker 内部错误导致一直处于忙碌态
                                compareWorker.onerror = (err) => {
                                    console.error('Compare worker error:', err);
                                    compareBusy.value = false;
                                };
                                return compareWorker;
                            }
                            const sheetReady = ref(false);
                            const sjsReady = ref(false);
                            const faReady = ref(false);
                            // 统一的提示徽标（各一个）：加载中为蓝色，加载完成切换为绿色并淡出
                            const sheetBadge = reactive({ show: true, bgClass: 'bg-blue-600', text: 'ExcelJS 加载中...' });
                            const sjsBadge = reactive({ show: true, bgClass: 'bg-blue-600', text: 'SheetJS 加载中...' });
                            const faBadge = reactive({ show: true, bgClass: 'bg-blue-600', text: '图标库加载中...' });                            // 颜色筛选：每个文件最多选一种颜色分类（再次点击清除）
                            const colorFilters = reactive({}); // { [fileName]: 'red'|'orange'|'blue'|'green' }

                            // 切换某个文件的颜色分类筛选（同一文件仅可选一种；再次点击关闭）
                            function toggleColorFilter(fileName, color) {
                                if (!compareMode.value || displayedSelectedFiles.value.length !== 2) return;
                                colorFilters[fileName] = (colorFilters[fileName] === color) ? undefined : color;
                            }
                            // 根据是否选中返回色块按钮的样式类名
                            function badgeClass(fileName, color) {
                                const active = colorFilters[fileName] === color;
                                const base = 'text-[10px] px-1.5 py-0.5 rounded min-w-[1.75rem] text-center border transition';
                                const map = {
                                    red: active ? 'bg-red-600 text-white border-red-600' : 'bg-red-50 text-red-700 border-red-100',
                                    orange: active ? 'bg-orange-500 text-white border-orange-500' : 'bg-orange-50 text-orange-700 border-orange-100',
                                    blue: active ? 'bg-blue-600 text-white border-blue-600' : 'bg-blue-50 text-blue-700 border-blue-100',
                                    green: active ? 'bg-green-600 text-white border-green-600' : 'bg-green-50 text-green-700 border-green-100',
                                };
                                return base + ' ' + map[color];
                            }

                            // 检测 Font Awesome 字体加载（优先检测字体，而非CSS）
                            function detectFontAwesome() {
                                if (document.fonts && document.fonts.load) {
                                    const markReady = () => {
                                        if (!faReady.value) faReady.value = true;
                                        faBadge.bgClass = 'bg-green-600';
                                        faBadge.text = '图标库加载完毕';
                                        setTimeout(() => { faBadge.show = false; }, 2000);
                                        console.log('Font Awesome 字体已加载');
                                    };
                                    const poll = async () => {
                                        try {
                                            // 尝试检测 solid 900 字重
                                            const r1 = await document.fonts.load('900 1em "Font Awesome 6 Free"');
                                            if (r1 && r1.length > 0) return markReady();
                                            // 退化检测常规权重
                                            const r2 = await document.fonts.load('400 1em "Font Awesome 6 Free"');
                                            if (r2 && r2.length > 0) return markReady();
                                            // 品牌字库（可选）
                                            const r3 = await document.fonts.load('400 1em "Font Awesome 6 Brands"');
                                            if (r3 && r3.length > 0) return markReady();
                                        } catch { }
                                        setTimeout(poll, 200);
                                    };
                                    poll();
                                } else {
                                    // 后备：退回到link onload（极少数旧浏览器）
                                    try {
                                        const links = Array.from(document.getElementsByTagName('link'));
                                        const faLink = links.find(l => (l.href || '').includes('font-awesome') || (l.href || '').includes('all.min.css'));
                                        if (faLink) {
                                            const fallbackMark = () => { if (!faReady.value) faReady.value = true; faBadge.bgClass = 'bg-green-600'; faBadge.text = '图标库加载完毕'; setTimeout(() => { faBadge.show = false; }, 2000); };
                                            if (faLink.sheet) { fallbackMark(); }
                                            else { faLink.addEventListener('load', fallbackMark); }
                                        }
                                    } catch { }
                                }
                            }
                            detectFontAwesome();

                            // 轮询检测 ExcelJS / SheetJS 是否已加载
                            const checkTimer = setInterval(() => {
                                if (window && window.ExcelJS && !sheetReady.value) {
                                    sheetReady.value = true;
                                    sheetBadge.bgClass = 'bg-green-600';
                                    sheetBadge.text = 'ExcelJS 加载完毕';
                                    setTimeout(() => { sheetBadge.show = false; }, 2000);
                                    console.log('ExcelJS 已加载');
                                }
                                if (window && window.XLSX && !sjsReady.value) {
                                    sjsReady.value = true;
                                    sjsBadge.bgClass = 'bg-green-600';
                                    sjsBadge.text = 'SheetJS 加载完毕';
                                    setTimeout(() => { sjsBadge.show = false; }, 2000);
                                    console.log('SheetJS 已加载');
                                }
                                if (sheetReady.value && sjsReady.value) clearInterval(checkTimer);
                            }, 100);

                            // 回到顶部：显示/隐藏逻辑（不依赖具体滚动容器，捕获任何滚动）
                            const showTop = ref(false);
                            const atTop = () => {
                                const y = window.scrollY || document.documentElement.scrollTop || document.body.scrollTop || 0;
                                if (y > 0) return false;
                                // 检查常见可滚容器是否滚动
                                const scrollers = document.querySelectorAll('[class*="overflow-"], [style*="overflow"], table, tbody');
                                for (const el of scrollers) {
                                    try {
                                        const cs = getComputedStyle(el);
                                        const oy = cs.overflowY || cs.overflow;
                                        if (/(auto|scroll)/.test(oy) && el.scrollHeight > el.clientHeight && el.scrollTop > 0) {
                                            return false;
                                        }
                                    } catch { }
                                }
                                return true;
                            };
                            const updateBackTop = () => { showTop.value = !atTop(); };
                            const forceShowBackTop = () => {
                                // 不强制显示，延后一次判断，避免在顶端上滚时误显
                                if (typeof requestAnimationFrame === 'function') {
                                    requestAnimationFrame(updateBackTop);
                                } else {
                                    setTimeout(updateBackTop, 0);
                                }
                            };
                            // 回到页面顶部（平滑滚动）
                            function scrollToTop() { window.scrollTo({ top: 0, behavior: 'smooth' }); }
                            onMounted(() => {
                                window.addEventListener('scroll', updateBackTop, { passive: true });
                                document.addEventListener('scroll', updateBackTop, { passive: true, capture: true });
                                document.addEventListener('wheel', forceShowBackTop, { passive: true });
                                document.addEventListener('touchmove', forceShowBackTop, { passive: true });
                                // 点击外部关闭筛选面板
                                const onDocClick = (e) => {
                                    const path = e.composedPath ? e.composedPath() : [];
                                    const isPanel = path.some(el => el && el.classList && el.classList.contains('filter-panel'));
                                    const isBtn = path.some(el => el && el.classList && el.classList.contains('filter-btn'));
                                    if (isPanel || isBtn) return;
                                    Object.keys(filterUI).forEach(fn => {
                                        const cols = filterUI[fn] || {};
                                        Object.keys(cols).forEach(cn => { cols[cn].open = false; });
                                    });
                                    openDropdownKey.value = '';
                                };
                                document.addEventListener('click', onDocClick, { capture: true });
                                // 滚动/缩放时重算打开面板位置
                                const recompute = () => {
                                    const key = openDropdownKey.value;
                                    if (!key) return;
                                    const btn = document.querySelector(`.filter-btn[data-filter-key="${CSS.escape(key)}"]`);
                                    if (!btn) return;
                                    const rect = btn.getBoundingClientRect();
                                    dropdownPositions[key] = { top: rect.bottom + 4, left: rect.left };
                                };
                                window.addEventListener('resize', recompute, { passive: true });
                                window.addEventListener('scroll', recompute, { passive: true });
                                updateBackTop();
                                // 存到实例上以便卸载时移除
                                window.__bom_onDocClick = onDocClick;
                                window.__bom_recompute = recompute;
                            });
                            onUnmounted(() => {
                                window.removeEventListener('scroll', updateBackTop);
                                document.removeEventListener('scroll', updateBackTop, { capture: true });
                                document.removeEventListener('wheel', forceShowBackTop);
                                document.removeEventListener('touchmove', forceShowBackTop);
                                if (window.__bom_onDocClick) document.removeEventListener('click', window.__bom_onDocClick, { capture: true });
                                if (window.__bom_recompute) {
                                    window.removeEventListener('resize', window.__bom_recompute);
                                    window.removeEventListener('scroll', window.__bom_recompute);
                                }
                            });

                            // 控制预览容器的显示/隐藏与内容切换 - 优化版本：
                            // - 展开：容器先展开，内容延迟淡入
                            // - 收回：内容先淡出但保持半透明，容器再收回
                            watch(selectedFiles, (newVal, oldVal) => {
                                const n = (newVal || []).length;
                                const o = (oldVal || []).length;

                                // 计算预览文件列表（最多2个，遵循挤掉规则）
                                let previewFiles = [];
                                if (n > 0) {
                                    if (n <= 2) {
                                        // 1-2个文件：直接预览
                                        previewFiles = [...newVal];
                                    } else {
                                        // 超过2个文件：只预览最后2个（最新选择的2个）
                                        previewFiles = newVal.slice(-2);
                                    }
                                }

                                if (previewFiles.length > 0 && !containerVisible.value) {
                                    // 初次显示：立即渲染内容并展开外层
                                    displayedSelectedFiles.value = [...previewFiles];
                                    containerVisible.value = true;
                                    return;
                                }
                                if (previewFiles.length === 0) {
                                    // 无预览：立即清空预览内容，让预览列表动画生效
                                    compareMode.value = false;
                                    displayedSelectedFiles.value = []; // 立即清空，触发预览列表的退出动画
                                    if (containerVisible.value) {
                                        // 延迟一点再关闭容器，让预览列表动画先完成
                                        setTimeout(() => {
                                            containerVisible.value = false;
                                        }, 100);
                                    }
                                    return;
                                }
                                // 其他情况：直接更新预览内容
                                displayedSelectedFiles.value = [...previewFiles];
                            }, { deep: true });                            // 预览容器过渡离开后清空内部内容 - 优化版本
                            function onPreviewContainerAfterLeave() {
                                // 外层容器收回完毕后清空内容，为下次展开做准备
                                if ((selectedFiles.value || []).length === 0) {
                                    displayedSelectedFiles.value = [];
                                }
                            }

                            // 预览容器自适应高度过渡钩子函数
                            function onBeforeEnter(el) {
                                el.style.height = '0';
                                el.style.opacity = '0';
                            }

                            function onEnter(el, done) {
                                // 强制重绘
                                el.offsetHeight;

                                // 获取自然高度
                                el.style.height = 'auto';
                                const height = el.offsetHeight;

                                // 重置为0开始动画
                                el.style.height = '0';

                                // 下一帧开始动画
                                requestAnimationFrame(() => {
                                    el.style.height = height + 'px';
                                    el.style.opacity = '1';

                                    // 动画完成后调用done
                                    setTimeout(done, 600);
                                });
                            }

                            function onAfterEnter(el) {
                                // 动画完成后移除固定高度，恢复自适应
                                el.style.height = 'auto';
                            }

                            function onBeforeLeave(el) {
                                // 记录当前高度
                                el.style.height = el.offsetHeight + 'px';
                                el.style.opacity = '1';
                            } function onLeave(el, done) {
                                // 强制重绘
                                el.offsetHeight;

                                // 下一帧开始收起动画
                                requestAnimationFrame(() => {
                                    el.style.height = '0';
                                    el.style.opacity = '0';

                                    // 动画完成后调用done
                                    setTimeout(done, 600);
                                });
                            }

                            // 计算卡片宽度：单卡 100%，双卡等分
                            function cardWidth(idx, fileName) {
                                const len = displayedSelectedFiles.value.length;
                                if (len === 1) return '100%';
                                // len >= 2 时，直接返回半宽，确保1→2和2→3时新卡片宽度一致
                                return 'calc((100% - 1.5rem) / 2)';
                            }

                            // 返回卡片样式（宽度、折行控制等）
                            function cardStyle(idx, fileName) {
                                const w = cardWidth(idx, fileName);
                                return {
                                    width: w,
                                    flexBasis: w,
                                    flexShrink: 0,
                                    minWidth: 0,
                                    overflow: 'hidden'
                                };
                            }                            // 文件解析与数据装载入口
                            async function handleFiles(e) {
                                // 导入流程总览（新版规则）：
                                // 1) 生成唯一显示名（允许重复导入，name, name (2), name (3)...）
                                // 2) HTML：在每个 <table> 内寻找“第一列为 零件号/供应商零件号/客户零件号”的行作为表头；
                                //    删除后续误入的表头行、包含合并单元格的行（colspan/rowspan>1）、第一列以 Design 开头的行；按表头对齐填充数据。
                                // 3) Excel：读取完整网格并识别合并区域；同样按“第一列令牌”识别表头并删除误入表头/合并/Design 行；
                                //    若找不到表头则回退到“列1..列N”的临时列名策略，尽量保证可用。
                                // 4) PN 填充：若“零件号”为空且“供应商零件号”也为空，则丢弃该行；若“零件号”为空但“供应商零件号”有值，则将“零件号”填为【供应商零件号】。
                                // 5) 规范化与聚合：对导线/WIRE/线束三段号规范为前两段；按“零件号”聚合并汇总“数量”。
                                // 6) 排序：按“零件号”自然升序（数字友好、忽略中英文大小写差异）。
                                const files = Array.from(e.target.files || []);
                                if (!files.length) return;
                                // 按需校验依赖：含Excel需ExcelJS，含HTML需SheetJS
                                const needExcel = files.some(f => !/\.html?$/i.test(f.name));
                                const needSheet = files.some(f => /\.html?$/i.test(f.name));
                                if (needExcel && !window.ExcelJS) { alert('ExcelJS 还在加载中，请稍后再试'); return; }
                                if (needSheet && !window.XLSX) { alert('SheetJS 还在加载中，请稍后再试'); return; }
                                loading.value = true;
                                await Promise.all(files.map(file => new Promise(resolve => {
                                    // 不再跳过同名文件：生成一个唯一可显示名称（name, name (2), name (3)...）
                                    const displayName = generateUniqueFileName(file.name);
                                    const table = { name: displayName, columns: [], data: [], status: 'pending', errorMsg: '' };
                                    tables.push(table);
                                    fileList.push({ name: displayName, rows: 0, status: 'pending', errorMsg: '' });
                                    const reader = new FileReader();
                                    reader.onload = async (evt) => {
                                        try {
                                            let rows = [];
                                            let columns = [];
                                            if (file.name.endsWith('.html') || file.name.endsWith('.htm')) {
                                                const html = evt.target.result;
                                                const parsed = parseHTMLWithSheetJS(html);
                                                rows = parsed.rows;
                                                columns = parsed.columns;
                                            } else {
                                                const lower = file.name.toLowerCase();
                                                if (lower.endsWith('.xls')) {
                                                    throw new Error('暂不支持 .xls（请另存为 .xlsx 后导入）');
                                                }
                                                const parsed = await parseExcelFile(evt.target.result, file.name);
                                                rows = parsed.rows;
                                                columns = parsed.columns;
                                            }
                                            // 严格复用 XLSX 的统一清洗管道
                                            const cleaned = processRawData(rows, columns);
                                            table.columns = cleaned.columns;
                                            table.data = cleaned.rows;
                                            table.status = 'success';
                                            table.errorMsg = '';
                                            const f = fileList.find(f => f.name === displayName);
                                            f.rows = table.data.length;
                                            f.status = 'success';
                                            f.errorMsg = '';
                                            // 数据变更：失效缓存 & bump 版本
                                            dataEpoch.value++;
                                            delete compareCache[displayName];
                                        } catch (err) {
                                            // 根据错误类型提供具体的错误信息
                                            let errorMessage = '';
                                            const originalError = err && err.message ? err.message : err;

                                            if (typeof originalError === 'string') {
                                                if (originalError.includes('Excel解析失败')) {
                                                    errorMessage = `Excel文件格式错误: ${originalError.replace('Excel解析失败: ', '')}`;
                                                } else if (originalError.includes('零件号数据清理失败')) {
                                                    errorMessage = `数据清洗阶段 - ${originalError}`;
                                                } else if (originalError.includes('导线类型处理或数据聚合失败')) {
                                                    errorMessage = `数据处理阶段 - ${originalError}`;
                                                } else if (originalError.includes('数据排序失败')) {
                                                    errorMessage = `数据整理阶段 - ${originalError}`;
                                                } else if (originalError.includes('暂不支持')) {
                                                    errorMessage = `文件格式不支持: ${originalError}`;
                                                } else if (originalError.includes('Excel文件无有效Sheet')) {
                                                    errorMessage = `Excel文件结构错误: 文件中没有有效的工作表`;
                                                } else if (originalError.includes('Excel为空')) {
                                                    errorMessage = `Excel文件内容错误: 工作表为空或没有数据`;
                                                } else {
                                                    errorMessage = `文件解析失败: ${originalError}`;
                                                }
                                            } else {
                                                errorMessage = `文件解析过程中出现未知错误`;
                                            }

                                            table.status = 'error';
                                            table.errorMsg = errorMessage;
                                            table.columns = [];
                                            table.data = [];
                                            const f = fileList.find(f => f.name === displayName);
                                            if (f) {
                                                f.rows = 0;
                                                f.status = 'error';
                                                f.errorMsg = errorMessage;
                                            }
                                            console.error('文件解析异常:', file.name, '错误详情:', err);
                                        }
                                        resolve();
                                    };
                                    if (file.name.endsWith('.html') || file.name.endsWith('.htm')) {
                                        reader.readAsText(file);
                                    } else {
                                        reader.readAsArrayBuffer(file);
                                    }
                                })));
                                loading.value = false;
                            }

                            // 删除文件
                            // 从列表与选中集合中移除文件
                            function removeFile(idx) {
                                if (idx < 0 || idx >= fileList.length) return;
                                const name = fileList[idx].name;
                                const tIdx = tables.findIndex(t => t.name === name);
                                if (tIdx !== -1) tables.splice(tIdx, 1);
                                fileList.splice(idx, 1);
                                const selIdx = selectedFiles.value.indexOf(name);
                                if (selIdx !== -1) selectedFiles.value.splice(selIdx, 1);
                                // 数据变更：失效缓存 & bump 版本
                                dataEpoch.value++;
                                delete compareCache[name];
                            }

                            //（已移除）点击文件条目切换预览功能由 onFileCheckboxChange 统一处理

                            // 文件选择逻辑 - 分离选择和预览：
                            // 1. 文件选择：多选模式下无限制，普通模式下最多2个
                            // 2. 文件预览：无论哪种模式，预览区最多显示2个文件，遵循挤掉规则
                            function onFileCheckboxChange(name, checked, status) {
                                if (status === 'error') return;
                                const i = selectedFiles.value.indexOf(name);

                                if (checked) {
                                    if (i === -1) {
                                        // 文件选择逻辑
                                        if (multiCompareMode.value) {
                                            // 多选模式：可以选择无限个文件
                                            selectedFiles.value.push(name);
                                        } else {
                                            // 普通模式：最多选择2个文件
                                            if (selectedFiles.value.length >= 2) {
                                                selectedFiles.value.shift(); // 移除最早选择的文件
                                            }
                                            selectedFiles.value.push(name);
                                        }
                                    }
                                } else {
                                    // 取消选择
                                    if (i >= 0) selectedFiles.value.splice(i, 1);
                                }
                            }
                            // 多文件对比模式开关 - 改进版本：
                            // - 进入时：保持已选择的文件和预览状态
                            // - 退出时：保持已选择的文件和预览状态，并清空所有选中文件
                            function toggleMultiCompare() {
                                multiCompareMode.value = !multiCompareMode.value;
                                if (multiCompareMode.value) {
                                    // 进入多选模式：保持预览状态和已选择的文件
                                    compareMode.value = false;
                                    // 不关闭预览容器，不清空已选择文件
                                } else {
                                    // 退出多选模式（点击"取消多选"）：清空所有已选择的文件
                                    selectedFiles.value = [];
                                    containerVisible.value = false;
                                    compareMode.value = false;
                                }
                            }

                            // 多选模式下一键全选（过滤解析失败的项）
                            function selectAllFiles() {
                                if (!multiCompareMode.value) return;
                                const all = fileList.filter(f => f.status !== 'error').map(f => f.name);
                                selectedFiles.value.splice(0, selectedFiles.value.length, ...all);
                            }

                            // 获取表格
                            // 根据显示名获取表对象（columns、data 等）
                            function getTable(name) {
                                const t = tables.find(t => t.name === name);
                                if (!t || !t.columns || !t.data) {
                                    return { columns: [], data: [], status: 'error', errorMsg: '未找到' };
                                }
                                return t;
                            }

                            const filterUI = reactive({}); // 下拉开关与临时搜索/选择
                            const activeFilters = reactive({}); // 生效的按列筛选: { [fileName]: { [col]: Set(values) } }
                            // Teleport 筛选面板定位（fixed 到视口），key 由 fileName__col 组成
                            const dropdownPositions = reactive({}); // { [key]: { top, left } }
                            const openDropdownKey = ref('');

                            // 获取筛选面板的临时状态对象（不存在则初始化）
                            function keyOf(fileName, col) {
                                if (!filterUI[fileName]) filterUI[fileName] = {};
                                if (!filterUI[fileName][col]) filterUI[fileName][col] = { open: false, search: '', temp: new Set() };
                                return filterUI[fileName][col];
                            }

                            // 打开/关闭列筛选下拉面板，并计算定位
                            function toggleFilterDropdown(fileName, col, evt) {
                                const k = keyOf(fileName, col);
                                k.open = !k.open;
                                // 初始化临时集合为当前已选值
                                const selected = activeFilters[fileName] && activeFilters[fileName][col] ? activeFilters[fileName][col] : new Set();
                                k.temp = new Set(Array.from(selected));
                                // 记录打开的面板位置（按钮的可视区域 rect）
                                const key = `${fileName}__${col}`;
                                if (k.open && evt && evt.currentTarget) {
                                    const rect = evt.currentTarget.getBoundingClientRect();
                                    dropdownPositions[key] = { top: rect.bottom + 4, left: rect.left };
                                    openDropdownKey.value = key;
                                } else if (!k.open && openDropdownKey.value === key) {
                                    openDropdownKey.value = '';
                                }
                            }
                            // 关闭列筛选面板
                            function closeDropdown(fileName, col) {
                                const k = keyOf(fileName, col);
                                k.open = false;
                                if (openDropdownKey.value === `${fileName}__${col}`) openDropdownKey.value = '';
                            }
                            // 判断列筛选面板是否打开
                            function isDropdownOpen(fileName, col) { return !!(filterUI[fileName] && filterUI[fileName][col] && filterUI[fileName][col].open); }

                            // 获取列筛选的临时状态（含搜索与临时勾选）
                            function getFilterState(fileName, col) { return keyOf(fileName, col); }

                            // 计算下拉筛选面板的 fixed 定位样式
                            function dropdownStyle(fileName, col) {
                                const key = `${fileName}__${col}`;
                                const pos = dropdownPositions[key] || { top: 0, left: 0 };
                                const panelWidth = 256; // w-64
                                const panelHeight = 320; // 估算高度，内部滚动
                                let top = pos.top;
                                let left = pos.left;
                                const vw = window.innerWidth || document.documentElement.clientWidth;
                                const vh = window.innerHeight || document.documentElement.clientHeight;
                                if (left + panelWidth > vw - 8) left = Math.max(8, vw - panelWidth - 8);
                                if (top + panelHeight > vh - 8) top = Math.max(8, vh - panelHeight - 8);
                                return `top:${top}px;left:${left}px;`;
                            }

                            // 收集指定列的去重值列表（基于当前表数据，不受列筛选影响）
                            function collectDistinctValues(fileName, col) {
                                const table = getTable(fileName);
                                const set = new Set();
                                (table.data || []).forEach(r => set.add(String((r && r[col]) ?? '')));
                                return Array.from(set);
                            }

                            // 在去重值基础上应用搜索过滤并排序（供下拉面板显示）
                            function filteredDistinctValues(fileName, col) {
                                const state = getFilterState(fileName, col);
                                const search = (state.search || '').toLowerCase();
                                const collator = new Intl.Collator('zh-CN', { numeric: true, sensitivity: 'base' });
                                return collectDistinctValues(fileName, col)
                                    .filter(v => v.toLowerCase().includes(search))
                                    .sort((a, b) => collator.compare(a, b));
                            }

                            // 判断值是否在临时勾选集合中
                            function isValueChecked(fileName, col, val) { return getFilterState(fileName, col).temp.has(String(val ?? '')); }
                            // 切换下拉项的临时勾选状态
                            function onToggleValue(fileName, col, val, checked) {
                                const state = getFilterState(fileName, col);
                                const key = String(val ?? '');
                                if (checked) state.temp.add(key); else state.temp.delete(key);
                            }
                            // 勾选当前列的全部可选值
                            function selectAllValues(fileName, col) {
                                const state = getFilterState(fileName, col);
                                state.temp = new Set(collectDistinctValues(fileName, col).map(v => String(v ?? '')));
                            }
                            // 清除当前列的全部勾选值
                            function clearAllValues(fileName, col) { getFilterState(fileName, col).temp = new Set(); }

                            // 应用列筛选（将临时勾选写入正式筛选集合）
                            function applyFilter(fileName, col) {
                                if (!activeFilters[fileName]) activeFilters[fileName] = {};
                                activeFilters[fileName][col] = new Set(Array.from(getFilterState(fileName, col).temp));
                                closeDropdown(fileName, col);
                            }

                            // 判断某列是否存在有效的筛选条件
                            function isColumnFiltered(fileName, col) {
                                return !!(activeFilters[fileName] && activeFilters[fileName][col] && activeFilters[fileName][col].size > 0);
                            }

                            // 文件是否存在任意列筛选
                            function hasActiveFilters(fileName) {
                                const f = activeFilters[fileName] || {};
                                return Object.values(f).some(set => set && set.size > 0);
                            }

                            // 仅应用列值筛选（不应用颜色筛选），用于计数等
                            function baseFilteredRows(fileName) {
                                const table = getTable(fileName);
                                const rows = table.data || [];
                                const filters = activeFilters[fileName] || {};
                                const cols = table.columns || [];
                                const hasAny = Object.values(filters).some(set => set && set.size > 0);
                                return hasAny ? rows.filter(r => cols.every(col => {
                                    const set = filters[col];
                                    if (!set || set.size === 0) return true;
                                    const key = String((r && r[col]) ?? '');
                                    return set.has(key);
                                })) : rows;
                            }

                            // 综合列筛选与颜色分类筛选，返回最终用于渲染的行
                            function filteredRows(fileName) {
                                const table = getTable(fileName);
                                const cols = table.columns || [];
                                let result = baseFilteredRows(fileName);
                                // 颜色分类筛选（仅在对比模式且选了两表时生效）
                                if (compareMode.value && displayedSelectedFiles.value.length === 2 && colorFilters[fileName]) {
                                    const want = COLOR_TO_PRIORITY[colorFilters[fileName]];
                                    result = result.filter(r => categoryPriority(fileName, r) === want);
                                }
                                // 对比模式下，按底色优先级排序：红(0) 橙(1) 蓝(2) 绿(3)
                                if (compareMode.value && displayedSelectedFiles.value.length === 2 && cols.includes('零件号')) {
                                    const collator = new Intl.Collator('zh-CN', { numeric: true, sensitivity: 'base' });
                                    result = [...result].sort((a, b) => {
                                        const pa = categoryPriority(fileName, a);
                                        const pb = categoryPriority(fileName, b);
                                        if (pa !== pb) return pa - pb;
                                        const as = String((a && a['零件号']) ?? '').trim();
                                        const bs = String((b && b['零件号']) ?? '').trim();
                                        return collator.compare(as, bs);
                                    });
                                }
                                return result;
                            }

                            // 开关对比模式；开启时短暂进入忙碌态
                            async function toggleCompare() {
                                if (compareMode.value) { compareMode.value = false; return; }
                                if (compareBusy.value) return;
                                if (displayedSelectedFiles.value.length !== 2) return;
                                const [f1, f2] = displayedSelectedFiles.value;
                                const t1 = getTable(f1); const t2 = getTable(f2);
                                if (!t1?.data?.length && !t2?.data?.length) { compareMode.value = true; return; }
                                // 构建原始索引映射（用于把 worker 分类结果按行对象找回）
                                const makeIndexMap = (name, data) => {
                                    const map = new WeakMap();
                                    data.forEach((row, idx) => map.set(row, idx));
                                    originalIndexMaps.set(name, map);
                                };
                                makeIndexMap(f1, t1.data || []);
                                makeIndexMap(f2, t2.data || []);
                                // 将响应式行对象转换为可克隆的普通对象，避免 postMessage DataCloneError
                                const toPlainRows = (rows) => (Array.isArray(rows) ? rows : []).map(r => Object.fromEntries(Object.entries(r)));
                                const leftPayload = { name: f1, rows: toPlainRows(t1.data) };
                                const rightPayload = { name: f2, rows: toPlainRows(t2.data) };
                                compareBusy.value = true;
                                const worker = ensureCompareWorker();
                                try {
                                    worker.postMessage({ left: leftPayload, right: rightPayload });
                                } catch (err) {
                                    console.error('postMessage failed:', err);
                                    compareBusy.value = false;
                                    // 保持 compareMode 关闭状态
                                }
                            }

                            // 获取与当前文件成对的另一个文件名（仅在预览了两个文件时有效）
                            function getOtherFileName(current) {
                                if (displayedSelectedFiles.value.length !== 2) return null;
                                return displayedSelectedFiles.value[0] === current ? displayedSelectedFiles.value[1] : displayedSelectedFiles.value[0];
                            }

                            // 将数量字段转换为数字（兼容千位分隔逗号，空值为 0）
                            function toNumber(v) {
                                if (v == null || v === '') return 0;
                                const n = parseFloat(String(v).replace(/,/g, ''));
                                return isNaN(n) ? 0 : n;
                            }

                            // 为对表构建按“零件号/供应商零件号”的快速索引
                            function buildIndexes(otherName) {
                                const other = getTable(otherName);
                                const byPN = new Map();
                                const bySupplier = new Map();
                                if (other && Array.isArray(other.data)) {
                                    other.data.forEach(r => {
                                        const pn = String((r && r['零件号']) ?? '').trim();
                                        const spn = String((r && r['供应商零件号']) ?? '').trim();
                                        if (pn) byPN.set(pn, r);
                                        if (spn) bySupplier.set(spn, r);
                                    });
                                }
                                return { byPN, bySupplier };
                            }

                            // 构建“交叉索引”：用于按你的定义计算“橙色”（双方均为红的供应商零件号交集）
                            // 构建交叉索引：用于判断橙色（本表红、且供应商号落在对表红集合内）与蓝绿
                            function buildCrossIndex(currentName) {
                                const otherName = getOtherFileName(currentName);
                                const current = getTable(currentName);
                                const other = getTable(otherName);
                                const currentPNSet = new Set();
                                const otherByPN = new Map();
                                const otherRedSupplierSet = new Set();
                                if (current && Array.isArray(current.data)) {
                                    current.data.forEach(r => {
                                        const pn = String((r && r['零件号']) ?? '').trim();
                                        if (pn) currentPNSet.add(pn);
                                    });
                                }
                                if (other && Array.isArray(other.data)) {
                                    other.data.forEach(r => {
                                        const pn = String((r && r['零件号']) ?? '').trim();
                                        if (pn) otherByPN.set(pn, r);
                                    });
                                    // 另一张表的“红色”集合（相对于当前表）：PN 不在当前表中
                                    other.data.forEach(r => {
                                        const pn = String((r && r['零件号']) ?? '').trim();
                                        const spn = String((r && r['供应商零件号']) ?? '').trim();
                                        if (!pn || !spn) return;
                                        if (!currentPNSet.has(pn)) {
                                            otherRedSupplierSet.add(spn);
                                        }
                                    });
                                }
                                return { otherByPN, otherRedSupplierSet };
                            }

                            // 计算一行的对比分类优先级：红(0)/橙(1)/蓝(2)/绿(3)
                            function categoryPriority(fileName, row) {
                                if (!compareMode.value) return 3; // 默认当作绿色
                                const otherName = getOtherFileName(fileName);
                                if (!otherName) return 3;
                                const pn = String((row && row['零件号']) ?? '').trim();
                                const { otherByPN, otherRedSupplierSet } = buildCrossIndex(fileName);
                                const otherRow = pn ? otherByPN.get(pn) : undefined;
                                if (!otherRow) {
                                    // 本表红：若供应商零件号落在对表红集合内，则橙，否则红
                                    const spn = String((row && row['供应商零件号']) ?? '').trim();
                                    if (spn && otherRedSupplierSet.has(spn)) return 1; // 橙
                                    return 0; // 红
                                }
                                // PN 命中：比较数量
                                const q1 = toNumber(row['数量']);
                                const q2 = toNumber(otherRow['数量']);
                                if (q1 === q2) return 3; // 绿
                                return 2; // 蓝
                            }

                            // 根据分类优先级返回表格行的背景色 class
                            function rowBgClass(fileName, row) {
                                // 使用 worker 结果优先（避免在渲染时重复计算）
                                const cache = compareCache[fileName];
                                let p;
                                if (cache && Array.isArray(cache.categories)) {
                                    const idxMap = originalIndexMaps.get(fileName);
                                    const idx = idxMap ? idxMap.get(row) : undefined;
                                    p = (typeof idx === 'number') ? cache.categories[idx] : undefined;
                                }
                                if (p == null) p = categoryPriority(fileName, row);
                                switch (p) {
                                    case 0: return 'bg-red-50';
                                    case 1: return 'bg-orange-50';
                                    case 2: return 'bg-blue-50';
                                    case 3: return 'bg-green-50';
                                    default: return '';
                                }
                            }

                            // 统计当前文件在四种分类下的行数（基于基础列筛选，不含颜色筛选）
                            function categoryCounts(fileName) {
                                // 优先使用 worker 统计结果
                                const cache = compareCache[fileName];
                                if (cache && cache.counts) return cache.counts;
                                // 回退到同步计算
                                const counts = { red: 0, orange: 0, blue: 0, green: 0 };
                                const table = getTable(fileName);
                                if (!compareMode.value || displayedSelectedFiles.value.length !== 2 || !(table.columns || []).includes('零件号')) return counts;
                                const { otherByPN, otherRedSupplierSet } = buildCrossIndex(fileName);
                                const rows = baseFilteredRows(fileName) || [];
                                rows.forEach(row => {
                                    const pn = String((row && row['零件号']) ?? '').trim();
                                    const otherRow = pn ? otherByPN.get(pn) : undefined;
                                    if (!otherRow) {
                                        const spn = String((row && row['供应商零件号']) ?? '').trim();
                                        if (spn && otherRedSupplierSet.has(spn)) counts.orange++; else counts.red++;
                                    } else {
                                        const q1 = toNumber(row['数量']);
                                        const q2 = toNumber(otherRow['数量']);
                                        if (q1 === q2) counts.green++; else counts.blue++;
                                    }
                                });
                                return counts;
                            }

                            // 计算“导线数量差值”列表（蓝色类且类型为导线/WIRE/线束），返回 [{ pn, type, q1, q2, diff }]
                            // 计算导线类的数量差值列表（包含所有导线类型，右表未找到时数量为0）
                            function wiresDiff(fileName) {
                                // 优先使用 worker 结果（再在 UI 侧应用列筛选）
                                const cache = compareCache[fileName];
                                let list = cache && Array.isArray(cache.wires) ? cache.wires : null;
                                if (!list) {
                                    // 同步回退
                                    if (!compareMode.value || displayedSelectedFiles.value.length !== 2) return [];
                                    const table = getTable(fileName);
                                    if (!table || !(table.columns || []).includes('零件号')) return [];
                                    const TYPE_SET = new Set(['WIRE', '线束', '导线']);
                                    const otherName = getOtherFileName(fileName);
                                    const { byPN } = buildIndexes(otherName);
                                    const rows = filteredRows(fileName) || [];
                                    const tmp = [];
                                    rows.forEach(row => {
                                        const pn = String((row && row['零件号']) ?? '').trim();
                                        const tp = String((row && row['类型']) ?? '').trim();
                                        if (!pn || !TYPE_SET.has(tp)) return;
                                        const otherRow = byPN.get(pn);
                                        const q1 = toNumber(row['数量']);
                                        const q2 = otherRow ? toNumber(otherRow['数量']) : 0;
                                        tmp.push({ pn, type: tp, q1, q2, diff: q1 - q2 });
                                    });
                                    list = tmp;
                                }
                                // 套用当前列筛选（只显示当前筛选后的 PN）
                                const visible = new Set((filteredRows(fileName) || []).map(r => String((r && r['零件号']) ?? '').trim()));
                                return (list || []).filter(d => visible.has(d.pn));
                            }

                            // ======================== 通用导出工具（可复用） ========================
                            const COLORS = {
                                LIGHT_RED: 'FFFFC8C8',   // #FFC8C8 - 未找到
                                ORANGE: 'FFF4B382',      // #F4B382 - 供应商零件号匹配
                                LIGHT_BLUE: 'FF99CCFF',  // #99CCFF - 数量不一致
                                LIGHT_GREEN: 'FFC8FFC8', // #C8FFC8 - 完全一致
                                GRAY: 'FFDCDCDC',        // #DCDCDC - 标题背景
                                LIGHT_GRAY: 'FFF0F0F0',  // #F0F0F0 - 表头背景
                            };
                            const fillSolid = (argb) => ({ type: 'pattern', pattern: 'solid', fgColor: { argb } });
                            function priorityFill(p) {
                                switch (p) {
                                    case 0: return fillSolid(COLORS.LIGHT_RED);
                                    case 1: return fillSolid(COLORS.ORANGE);
                                    case 2: return fillSolid(COLORS.LIGHT_BLUE);
                                    case 3: return fillSolid(COLORS.LIGHT_GREEN);
                                    default: return undefined;
                                }
                            }
                            function markText(p) { return ['未找到', '供应商匹配', '数量不同', '数量相同'][p] || ''; }

                            // 使用当前 UI 选择与排序导出（模拟“启动对比后点击导出”的行为）
                            async function exportCurrentSelection() {
                                const n = selectedFiles.value.length;
                                if (n === 0) return;
                                const wb = new ExcelJS.Workbook();
                                if (n === 1) {
                                    const f = selectedFiles.value[0];
                                    const t = getTable(f);
                                    const cols = (t.columns || []).slice();
                                    const rows = filteredRows(f) || [];
                                    const ws = wb.addWorksheet(sanitizeSheetName(f, new Set()));
                                    ws.addRow(cols); ws.getRow(1).font = { bold: true }; ws.getRow(1).fill = fillSolid(COLORS.LIGHT_GRAY);
                                    rows.forEach(r => ws.addRow(cols.map(c => r[c])));
                                    // 设置列格式：除“数量”外，全部按文本显示以保留前导零
                                    const qtyIdx_ws = cols.indexOf('数量');
                                    ws.columns = cols.map((name, idx) => ({ header: name, key: `c${idx}`, width: Math.max(10, String(name || '').length + 2), numFmt: (idx === qtyIdx_ws ? undefined : '@') }));
                                    // 确保数量列是数值
                                    if (qtyIdx_ws !== -1) {
                                        for (let r = 2; r <= ws.rowCount; r++) {
                                            const cell = ws.getRow(r).getCell(qtyIdx_ws + 1);
                                            const n = toNumber(cell.value);
                                            cell.value = n;
                                        }
                                    }
                                    applyBordersForRange(ws, 1, 1, rows.length + 1, cols.length);
                                    autoFitColumns(ws);
                                    await downloadWorkbook(wb, `${sanitizeFileBase(f)}.xlsx`);
                                    return;
                                }

                                const [f1, f2] = selectedFiles.value;
                                const t1 = getTable(f1), t2 = getTable(f2);
                                const cols1 = (t1.columns || []).slice();
                                const cols2 = (t2.columns || []).slice();
                                if (compareMode.value) {
                                    // 着色对比表 A
                                    const wsA = wb.addWorksheet(sanitizeSheetName(f1, new Set()));
                                    wsA.addRow([...cols1, '对比标记']); wsA.getRow(1).font = { bold: true }; wsA.getRow(1).fill = fillSolid(COLORS.LIGHT_GRAY);
                                    (filteredRows(f1) || []).forEach(r => {
                                        const p = categoryPriority(f1, r);
                                        const vals = [...cols1.map(c => r[c]), markText(p)];
                                        const row = wsA.addRow(vals);
                                        const fill = priorityFill(p); if (fill) for (let c = 1; c <= vals.length; c++) row.getCell(c).fill = fill;
                                    });
                                    // 列格式：除“数量”外文本，数量为数值
                                    const qtyIdx_A = cols1.indexOf('数量');
                                    wsA.columns = [...cols1, '对比标记'].map((name, idx) => ({ header: name, key: `a${idx}`, width: Math.max(10, String(name || '').length + 2), numFmt: (idx === qtyIdx_A ? undefined : '@') }));
                                    if (qtyIdx_A !== -1) {
                                        for (let r = 2; r <= wsA.rowCount; r++) {
                                            const cell = wsA.getRow(r).getCell(qtyIdx_A + 1);
                                            const n = toNumber(cell.value);
                                            cell.value = n;
                                        }
                                    }
                                    applyBordersForRange(wsA, 1, 1, wsA.rowCount, wsA.columnCount);
                                    autoFitColumns(wsA);

                                    // 着色对比表 B
                                    const wsB = wb.addWorksheet(sanitizeSheetName(f2, new Set(wb.worksheets.map(w => w.name))));
                                    wsB.addRow([...cols2, '对比标记']); wsB.getRow(1).font = { bold: true }; wsB.getRow(1).fill = fillSolid(COLORS.LIGHT_GRAY);
                                    (filteredRows(f2) || []).forEach(r => {
                                        const p = categoryPriority(f2, r);
                                        const vals = [...cols2.map(c => r[c]), markText(p)];
                                        const row = wsB.addRow(vals);
                                        const fill = priorityFill(p); if (fill) for (let c = 1; c <= vals.length; c++) row.getCell(c).fill = fill;
                                    });
                                    // 列格式：除“数量”外文本，数量为数值
                                    const qtyIdx_B = cols2.indexOf('数量');
                                    wsB.columns = [...cols2, '对比标记'].map((name, idx) => ({ header: name, key: `b${idx}`, width: Math.max(10, String(name || '').length + 2), numFmt: (idx === qtyIdx_B ? undefined : '@') }));
                                    if (qtyIdx_B !== -1) {
                                        for (let r = 2; r <= wsB.rowCount; r++) {
                                            const cell = wsB.getRow(r).getCell(qtyIdx_B + 1);
                                            const n = toNumber(cell.value);
                                            cell.value = n;
                                        }
                                    }
                                    applyBordersForRange(wsB, 1, 1, wsB.rowCount, wsB.columnCount);
                                    autoFitColumns(wsB);

                                    // 汇总页（使用现有统计与差值函数）
                                    const wsS = wb.addWorksheet(sanitizeSheetName('对比结果', new Set(wb.worksheets.map(w => w.name))));
                                    wsS.getCell('A1').value = '图例'; wsS.getCell('A1').fill = fillSolid(COLORS.GRAY);
                                    const legends = [
                                        { text: '零件号不存在', color: COLORS.LIGHT_RED },
                                        { text: '供应商零件号匹配', color: COLORS.ORANGE },
                                        { text: '数量不一致', color: COLORS.LIGHT_BLUE },
                                        { text: '完全一致', color: COLORS.LIGHT_GREEN },
                                    ];
                                    for (let i = 0; i < legends.length; i++) { const r = 3 + i; wsS.getCell(r, 1).value = legends[i].text; wsS.getCell(r, 1).fill = fillSolid(legends[i].color); }
                                    const cntA = categoryCounts(f1); const cntB = categoryCounts(f2);
                                    const colsBase = ['零件号', '供应商零件号', '类型', '数量'];
                                    // A 面计数 + 明细（按当前 filteredRows 顺序）
                                    wsS.getCell('C1').value = sanitizeSheetName(f1); wsS.getCell('C1').fill = fillSolid(COLORS.GRAY);
                                    [cntA.red, cntA.orange, cntA.blue, cntA.green].forEach((val, i) => { const cell = wsS.getCell(2, 3 + i); cell.value = val; cell.fill = fillSolid([COLORS.LIGHT_RED, COLORS.ORANGE, COLORS.LIGHT_BLUE, COLORS.LIGHT_GREEN][i]); });
                                    colsBase.forEach((c, k) => { const cell = wsS.getCell(3, 3 + k); cell.value = c; cell.fill = fillSolid(COLORS.LIGHT_GRAY); cell.font = { bold: true }; });
                                    (filteredRows(f1) || []).forEach((r, i) => {
                                        const p = categoryPriority(f1, r);
                                        const vals = [r['零件号'], r['供应商零件号'], r['类型'], r['数量']];
                                        for (let j = 0; j < vals.length; j++) { const cell = wsS.getCell(4 + i, 3 + j); cell.value = vals[j]; const fill = priorityFill(p); if (fill) cell.fill = fill; }
                                    });
                                    // B 面
                                    wsS.getCell('H1').value = sanitizeSheetName(f2); wsS.getCell('H1').fill = fillSolid(COLORS.GRAY);
                                    [cntB.red, cntB.orange, cntB.blue, cntB.green].forEach((val, i) => { const cell = wsS.getCell(2, 8 + i); cell.value = val; cell.fill = fillSolid([COLORS.LIGHT_RED, COLORS.ORANGE, COLORS.LIGHT_BLUE, COLORS.LIGHT_GREEN][i]); });
                                    colsBase.forEach((c, k) => { const cell = wsS.getCell(3, 8 + k); cell.value = c; cell.fill = fillSolid(COLORS.LIGHT_GRAY); cell.font = { bold: true }; });
                                    (filteredRows(f2) || []).forEach((r, i) => {
                                        const p = categoryPriority(f2, r);
                                        const vals = [r['零件号'], r['供应商零件号'], r['类型'], r['数量']];
                                        for (let j = 0; j < vals.length; j++) { const cell = wsS.getCell(4 + i, 8 + j); cell.value = vals[j]; const fill = priorityFill(p); if (fill) cell.fill = fill; }
                                    });
                                    // 设置明细列格式（C:F 和 H:K）：除“数量”外文本
                                    const qtyOffset = 3; // C列为3
                                    const setDetailFormats = (startCol) => {
                                        const headers = ['零件号', '供应商零件号', '类型', '数量'];
                                        headers.forEach((h, idx) => {
                                            const colIndex = startCol + idx;
                                            const isQty = (h === '数量');
                                            wsS.getColumn(colIndex).numFmt = isQty ? undefined : '@';
                                            if (isQty) {
                                                for (let r = 4; r <= wsS.rowCount; r++) {
                                                    const cell = wsS.getCell(r, colIndex);
                                                    const n = toNumber(cell.value);
                                                    cell.value = n;
                                                }
                                            }
                                        });
                                    };
                                    setDetailFormats(3); // C:F
                                    setDetailFormats(8); // H:K
                                    // 导线差值列表（复用 wiresDiff 排序与过滤）
                                    wsS.getCell('M1').value = '导线长度差值计算'; wsS.getCell('M1').fill = fillSolid(COLORS.GRAY);
                                    const head3 = ['零件号', '类型', '左表数量', '右表数量', '差值(左-右)'];
                                    head3.forEach((h, k) => { const cell = wsS.getCell(3, 13 + k); cell.value = h; cell.fill = fillSolid(COLORS.LIGHT_GRAY); cell.font = { bold: true }; });
                                    (wiresDiff(f1) || []).forEach((d, i) => {
                                        const vals = [d.pn, d.type, d.q1, d.q2, d.diff];
                                        const fill = d.diff > 0 ? fillSolid(COLORS.LIGHT_GREEN) : (d.diff < 0 ? fillSolid(COLORS.LIGHT_RED) : undefined);
                                        for (let j = 0; j < vals.length; j++) { const cell = wsS.getCell(4 + i, 13 + j); cell.value = vals[j]; if (fill) cell.fill = fill; }
                                    });
                                    // 设置导线差值区域列格式：M(N)=文本，O/P/Q=数值
                                    wsS.getColumn(13).numFmt = '@'; // 零件号
                                    wsS.getColumn(14).numFmt = '@'; // 类型
                                    [15, 16, 17].forEach(ci => { wsS.getColumn(ci).numFmt = undefined; });
                                    for (let r = 4; r <= wsS.rowCount; r++) {
                                        [15, 16, 17].forEach(ci => { const cell = wsS.getCell(r, ci); const n = toNumber(cell.value); cell.value = n; });
                                    }
                                    const maxRow = Math.max(6, wsS.rowCount);
                                    applyBordersForRange(wsS, 1, 1, maxRow, 17);
                                    autoFitColumns(wsS);
                                    await downloadWorkbook(wb, `对比结果_${sanitizeFileBase(f1)}_VS_${sanitizeFileBase(f2)}.xlsx`);
                                } else {
                                    // 两表原样导出（按 filteredRows 当前顺序）
                                    const ws1 = wb.addWorksheet(sanitizeSheetName(f1, new Set()));
                                    ws1.addRow(cols1); ws1.getRow(1).font = { bold: true }; ws1.getRow(1).fill = fillSolid(COLORS.LIGHT_GRAY);
                                    (filteredRows(f1) || []).forEach(r => ws1.addRow(cols1.map(c => r[c])));
                                    const qtyIdx_1 = cols1.indexOf('数量');
                                    ws1.columns = cols1.map((name, idx) => ({ header: name, key: `x1_${idx}`, width: Math.max(10, String(name || '').length + 2), numFmt: (idx === qtyIdx_1 ? undefined : '@') }));
                                    if (qtyIdx_1 !== -1) {
                                        for (let r = 2; r <= ws1.rowCount; r++) {
                                            const cell = ws1.getRow(r).getCell(qtyIdx_1 + 1);
                                            const n = toNumber(cell.value);
                                            cell.value = n;
                                        }
                                    }
                                    applyBordersForRange(ws1, 1, 1, ws1.rowCount, ws1.columnCount); autoFitColumns(ws1);

                                    const ws2 = wb.addWorksheet(sanitizeSheetName(f2, new Set(wb.worksheets.map(w => w.name))));
                                    ws2.addRow(cols2); ws2.getRow(1).font = { bold: true }; ws2.getRow(1).fill = fillSolid(COLORS.LIGHT_GRAY);
                                    (filteredRows(f2) || []).forEach(r => ws2.addRow(cols2.map(c => r[c])));
                                    const qtyIdx_2 = cols2.indexOf('数量');
                                    ws2.columns = cols2.map((name, idx) => ({ header: name, key: `x2_${idx}`, width: Math.max(10, String(name || '').length + 2), numFmt: (idx === qtyIdx_2 ? undefined : '@') }));
                                    if (qtyIdx_2 !== -1) {
                                        for (let r = 2; r <= ws2.rowCount; r++) {
                                            const cell = ws2.getRow(r).getCell(qtyIdx_2 + 1);
                                            const n = toNumber(cell.value);
                                            cell.value = n;
                                        }
                                    }
                                    applyBordersForRange(ws2, 1, 1, ws2.rowCount, ws2.columnCount); autoFitColumns(ws2);

                                    await downloadWorkbook(wb, `两表导出_${sanitizeFileBase(f1)}_与_${sanitizeFileBase(f2)}.xlsx`);
                                }
                            }

                            async function downloadWorkbook(wb, filename) {
                                const buffer = await wb.xlsx.writeBuffer();
                                const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url; a.download = filename; a.click();
                                URL.revokeObjectURL(url);
                            }

                            // 导出：使用现有 UI 逻辑；多选时模拟人工“启动对比+导出”的逐对流程
                            async function exportCompare() {
                                try {
                                    if (!window.ExcelJS || selectedFiles.value.length === 0) return;
                                    const n = selectedFiles.value.length;
                                    // 工具: 直接运行一次对比（不依赖切换按钮），并等待缓存就绪
                                    const runCompareFor = async (f1, f2) => {
                                        const t1 = getTable(f1), t2 = getTable(f2);
                                        const makeIndexMap = (name, data) => { const map = new WeakMap(); (data || []).forEach((row, idx) => map.set(row, idx)); originalIndexMaps.set(name, map); };
                                        makeIndexMap(f1, t1.data || []);
                                        makeIndexMap(f2, t2.data || []);
                                        const toPlainRows = (rows) => (Array.isArray(rows) ? rows : []).map(r => Object.fromEntries(Object.entries(r)));
                                        const leftPayload = { name: f1, rows: toPlainRows(t1.data) };
                                        const rightPayload = { name: f2, rows: toPlainRows(t2.data) };
                                        const worker = ensureCompareWorker();
                                        compareBusy.value = true;
                                        worker.postMessage({ left: leftPayload, right: rightPayload });
                                    };
                                    const waitForCompareCache = async (a, b, timeoutMs = 15000) => {
                                        const start = Date.now();
                                        return new Promise((resolve, reject) => {
                                            const tick = () => {
                                                const ready = compareCache[a] && compareCache[b] && compareCache[a].categories && compareCache[b].categories && !compareBusy.value && compareMode.value;
                                                if (ready) return resolve(true);
                                                if (Date.now() - start > timeoutMs) return reject(new Error('对比耗时过长，已超时'));
                                                setTimeout(tick, 50);
                                            };
                                            tick();
                                        });
                                    };
                                    // 多于两个文件：两两成对分别导出（每对：先对比并等待结果 -> 再导出带颜色的对比表）
                                    if (n > 2) {
                                        const originalSel = [...selectedFiles.value];
                                        const originalCompare = compareMode.value;
                                        try {
                                            for (let i = 0; i < originalSel.length - 1; i++) {
                                                for (let j = i + 1; j < originalSel.length; j++) {
                                                    const a = originalSel[i];
                                                    const b = originalSel[j];
                                                    selectedFiles.value = [a, b];
                                                    await runCompareFor(a, b);
                                                    try { await waitForCompareCache(a, b); } catch (e) { /* 兜底：允许继续导出，但可能为非着色版 */ }
                                                    await exportCurrentSelection();
                                                }
                                            }
                                        } finally {
                                            selectedFiles.value = originalSel;
                                            compareMode.value = originalCompare && originalSel.length === 2; // 仅当原本是双选时保留
                                        }
                                        return;
                                    }

                                    // 单个文件：导出单表
                                    if (n === 1) {
                                        await exportCurrentSelection();
                                        return;
                                    }

                                    // 恰好两个文件：先对比并等待结果，再导出
                                    const [a, b] = selectedFiles.value;
                                    await runCompareFor(a, b);
                                    try { await waitForCompareCache(a, b); } catch (e) { /* 兜底继续 */ }
                                    await exportCurrentSelection();
                                } catch (e) {
                                    alert('导出失败：' + (e && e.message ? e.message : e));
                                }
                            }
                            // 自动适配列宽（基于文本长度，设置上下限）
                            function autoFitColumns(ws, minWidth = 10, maxWidth = 40) {
                                const cols = ws.columns || [];
                                cols.forEach(col => {
                                    let maxLen = 0;
                                    col.eachCell({ includeEmpty: true }, cell => {
                                        const v = cell.value;
                                        let l = 0;
                                        if (v == null) l = 0;
                                        else if (typeof v === 'object') {
                                            if (Array.isArray(v.richText)) {
                                                l = v.richText.map(t => t.text || '').join('').length;
                                            } else if (v.text != null) {
                                                l = String(v.text).length;
                                            } else {
                                                l = String(v).length;
                                            }
                                        } else {
                                            l = String(v).length;
                                        }
                                        if (l > maxLen) maxLen = l;
                                    });
                                    col.width = Math.min(maxWidth, Math.max(minWidth, maxLen + 2));
                                });
                            }

                            function applyBordersForRange(ws, r1, c1, r2, c2) {
                                // 容错：确保边界有效
                                r1 = Math.max(1, Math.floor(r1));
                                c1 = Math.max(1, Math.floor(c1));
                                r2 = Math.max(r1, Math.floor(r2));
                                c2 = Math.max(c1, Math.floor(c2));
                                for (let r = r1; r <= r2; r++) {
                                    for (let c = c1; c <= c2; c++) {
                                        const cell = ws.getCell(r, c);
                                        cell.border = {
                                            top: { style: 'thin' },
                                            left: { style: 'thin' },
                                            bottom: { style: 'thin' },
                                            right: { style: 'thin' },
                                        };
                                    }
                                }
                            }

                            //（移除未使用的 labelForCategory）

                            // 清洗为合法的 Excel 工作表名，并避免重名冲突
                            function sanitizeSheetName(name, existing = new Set()) {
                                const invalid = /[\\\/*?:\[\]]/g;
                                const baseRaw = String(name).replace(invalid, ' ').trim() || 'Sheet';
                                const cut = (s) => s.length > 31 ? s.slice(0, 31) : s;
                                let candidate = cut(baseRaw);
                                // 如果冲突，尝试追加 (2),(3)...，并保证总长<=31
                                let idx = 2;
                                while (existing.has(candidate)) {
                                    const suffix = ` (${idx})`;
                                    const maxLen = 31 - suffix.length;
                                    candidate = cut(baseRaw.slice(0, Math.max(1, maxLen)) + suffix);
                                    idx++;
                                }
                                existing.add(candidate);
                                return candidate;
                            }

                            // 生成可用于文件名的基础串（去扩展名并替换非法字符）
                            function sanitizeFileBase(name) {
                                return String(name).replace(/\.[^.]+$/, '').replace(/[^\u4e00-\u9fa5\w-]+/g, '_');
                            }

                            // 生成唯一显示名：name, name (2), name (3)...

                            return {
                                tables,
                                fileList,
                                selectedFiles,
                                subtitle,
                                loading,
                                compareMode,
                                multiCompareMode,
                                compareBusy,
                                sheetReady,
                                sjsReady,
                                faReady,
                                sheetBadge,
                                sjsBadge,
                                faBadge,
                                // 回到顶部
                                showTop,
                                scrollToTop,
                                // 颜色分类筛选
                                toggleColorFilter,
                                badgeClass,
                                handleFiles,
                                exportCompare,
                                toggleCompare,
                                toggleMultiCompare,
                                onFileCheckboxChange,
                                selectAllFiles,
                                getTable,
                                removeFile,
                                toggleFilterDropdown,
                                isDropdownOpen,
                                getFilterState,
                                closeDropdown,
                                filteredDistinctValues,
                                isValueChecked,
                                onToggleValue,
                                selectAllValues,
                                clearAllValues,
                                applyFilter,
                                isColumnFiltered,
                                hasActiveFilters,
                                dropdownStyle,
                                filteredRows,
                                rowBgClass,
                                categoryCounts,
                                wiresDiff,
                                // 预览容器控制
                                containerVisible,
                                displayedSelectedFiles,
                                onPreviewContainerAfterLeave,
                                onBeforeEnter,
                                onEnter,
                                onAfterEnter,
                                onBeforeLeave,
                                onLeave,
                                cardWidth,
                                cardStyle,
                                previewWrap
                            };
                        }
                    }).mount('#app');

                    // ========== 页面增强功能 ==========

                    // 性能监控
                    if (window.performance) {
                        window.addEventListener('load', () => {
                            const perfData = performance.getEntriesByType('navigation')[0];
                            console.log(`页面加载时间: ${(perfData.loadEventEnd - perfData.fetchStart).toFixed(2)}ms`);
                        });
                    }

                    // 移动端适配
                    if (/Mobile|Android|iPhone|iPad/i.test(navigator.userAgent)) {
                        document.body.classList.add('mobile-device');

                        // 移动端表格横向滚动提示
                        const addSwipeHint = () => {
                            const tables = document.querySelectorAll('.overflow-auto');
                            tables.forEach(container => {
                                if (container.scrollWidth > container.clientWidth) {
                                    container.setAttribute('data-swipe-hint', '👈 左右滑动查看更多');
                                }
                            });
                        };

                        // 延迟执行，等待表格渲染
                        setTimeout(addSwipeHint, 1000);
                    }

                    // 键盘快捷键支持
                    document.addEventListener('keydown', (e) => {
                        // Ctrl/Cmd + Enter 快速导入文件
                        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                            e.preventDefault();
                            document.getElementById('fileInput')?.click();
                        }

                        // Esc 键关闭所有下拉菜单
                        if (e.key === 'Escape') {
                            const app = document.getElementById('app').__vue_app__;
                            if (app && app._instance) {
                                const vm = app._instance.ctx;
                                // 关闭所有筛选面板
                                Object.keys(vm.filterUI || {}).forEach(fileName => {
                                    const cols = vm.filterUI[fileName] || {};
                                    Object.keys(cols).forEach(colName => {
                                        cols[colName].open = false;
                                    });
                                });
                                vm.openDropdownKey = '';
                            }
                        }
                    });

                    // PWA 支持检测
                    if ('serviceWorker' in navigator) {
                        console.log('浏览器支持 Service Worker，可以考虑添加离线支持');
                    }

                </script>

                <!-- 增强的无障碍支持 -->
                <div id="sr-status" class="sr-only" aria-live="polite" aria-atomic="true"></div>

            </main>
        </div>
    </body>

</html>