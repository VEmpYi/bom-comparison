<!DOCTYPE html>
<html lang="zh-CN">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes">
        <meta name="description" content="ä¸“ä¸šçš„BOMè¡¨æ ¼å¯¹æ¯”åˆ†æå·¥å…·ï¼Œæ”¯æŒExcelå’ŒHTMLæ–‡ä»¶å¯¼å…¥å¯¹æ¯”">
        <meta name="keywords" content="BOM,è¡¨æ ¼å¯¹æ¯”,Excel,æ•°æ®åˆ†æ">
        <title>è¡¨æ ¼ BOM å¯¹æ¯”åˆ†æ</title>

        <!-- Preload critical resources -->
        <link rel="preload" href="https://cdn.tailwindcss.com" as="script">
        <link rel="preload" href="https://unpkg.com/vue@3/dist/vue.global.prod.js" as="script">

        <!-- Tailwind CSS v3 CDN -->
        <script src="https://cdn.tailwindcss.com"></script>
        <!-- Font Awesome 6 CDN with fallback -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
            onerror="this.onerror=null; this.href='https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css'">
        <!-- ExcelJS CDN (deferé¿å…é˜»å¡æ¸²æŸ“) -->
        <script defer src="https://cdn.jsdelivr.net/npm/exceljs@4.4.0/dist/exceljs.min.js"></script>
        <!-- SheetJS (XLSX) for HTML/Table parsing -->
        <script defer src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
        <!-- Vue 3 å…¨å±€æ„å»º CDN with fallback -->
        <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"
            onerror="this.onerror=null; this.src='https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.prod.js'"></script>
        <style>
            /* ========== ç°ä»£åŒ–åŸºç¡€æ ·å¼ ========== */
            :root {
                --primary-blue: #2563eb;
                --primary-green: #059669;
                --primary-red: #dc2626;
                --primary-orange: #ea580c;
                --bg-gradient: linear-gradient(135deg, #f0f9ff 0%, #ffffff 50%, #fef7f7 100%);
                --shadow-soft: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
                --shadow-card: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
                --border-radius: 12px;
                --transition-smooth: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            }

            /* æµ®åŠ¨å¼æ»šåŠ¨æ¡ï¼ˆä¸å ç”¨é¡µé¢å¸ƒå±€ç©ºé—´ï¼‰ */
            html {
                overflow-y: overlay;
                /* æ»šåŠ¨æ¡æµ®åœ¨å†…å®¹ä¸Šæ–¹ */
                scrollbar-gutter: stable;
                /* ä¸ºæ»šåŠ¨æ¡é¢„ç•™ç¨³å®šç©ºé—´ */
            }

            /* å¦‚æœä¸æ”¯æŒ overlayï¼Œåˆ™éšè—æ»šåŠ¨æ¡ */
            @supports not (overflow-y: overlay) {
                html {
                    overflow-y: auto;
                    scrollbar-width: none;
                    /* Firefox */
                    -ms-overflow-style: none;
                    /* Internet Explorer 10+ */
                }

                html::-webkit-scrollbar {
                    display: none;
                    /* WebKit */
                }
            }

            /* ä¼˜é›…çš„æ»šåŠ¨æ¡ï¼ˆæ”¯æŒæ›´å¤šæµè§ˆå™¨ï¼‰ */
            ::-webkit-scrollbar {
                width: 12px;
                height: 12px;
            }

            ::-webkit-scrollbar-track {
                background: transparent;
                /* é€æ˜èƒŒæ™¯ï¼Œä¸å½±å“é¡µé¢å¸ƒå±€ */
            }

            ::-webkit-scrollbar-thumb {
                background: rgba(156, 163, 175, 0.3);
                border-radius: 6px;
                border: 2px solid transparent;
                background-clip: content-box;
                transition: var(--transition-smooth);
            }

            ::-webkit-scrollbar-thumb:hover {
                background: rgba(107, 114, 128, 0.6);
                background-clip: content-box;
            }

            /* æ»šåŠ¨æ¡è§’è½å¤„ç† */
            ::-webkit-scrollbar-corner {
                background: transparent;
            }

            /* Firefox æµ®åŠ¨å¼æ»šåŠ¨æ¡ */
            * {
                scrollbar-width: thin;
                scrollbar-color: rgba(156, 163, 175, 0.3) transparent;
            }

            /* å¦‚æœä¸æ”¯æŒ overlayï¼Œåˆ™å¯¹æ‰€æœ‰å…ƒç´ éšè—æ»šåŠ¨æ¡ */
            @supports not (overflow-y: overlay) {
                * {
                    scrollbar-width: none;
                    /* Firefox */
                    -ms-overflow-style: none;
                    /* Internet Explorer 10+ */
                }

                *::-webkit-scrollbar {
                    display: none;
                    /* WebKit */
                }
            }

            /* ç¡®ä¿é¡µé¢å†…å®¹ä¸å› æ»šåŠ¨æ¡å‡ºç°è€Œåç§» */
            body {
                overflow-y: overlay;
                scrollbar-gutter: stable;
            }

            /* å¦‚æœä¸æ”¯æŒ overlayï¼Œbody ä¹Ÿéšè—æ»šåŠ¨æ¡ */
            @supports not (overflow-y: overlay) {
                body {
                    overflow-y: auto;
                    scrollbar-width: none;
                    -ms-overflow-style: none;
                }

                body::-webkit-scrollbar {
                    display: none;
                }
            }

            /* è¿‡æ¸¡åŠ¨ç”» */
            .fade-enter-active,
            .fade-leave-active {
                transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            }

            .fade-enter-from,
            .fade-leave-to {
                opacity: 0;
                transform: translateY(-8px);
            }

            .fadeout-leave-active {
                transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            }

            .fadeout-leave-to {
                opacity: 0;
                transform: translateY(-8px);
            }

            /* æ»‘åŠ¨è¿‡æ¸¡ */
            .slide-down-enter-active,
            .slide-down-leave-active {
                transition: max-height 0.5s cubic-bezier(0.4, 0, 0.2, 1);
                overflow: hidden;
            }

            .slide-down-enter-from {
                max-height: 0;
                opacity: 0;
            }

            .slide-down-enter-to {
                max-height: 9999px;
                opacity: 1;
            }

            .slide-down-leave-from {
                max-height: 9999px;
                opacity: 1;
            }

            .slide-down-leave-to {
                max-height: 0;
                opacity: 0;
            }

            /* æ»‘åŠ¨è¿‡æ¸¡ - è‡ªé€‚åº”é«˜åº¦ç‰ˆæœ¬ */
            .slide-up-enter-active {
                transition: height 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.4s ease-in-out;
                overflow: hidden;
            }

            .slide-up-leave-active {
                transition: height 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.4s ease-in-out;
                overflow: hidden;
            }

            .slide-up-enter-from {
                height: 0;
                opacity: 0;
            }

            .slide-up-enter-to {
                height: auto;
                opacity: 1;
            }

            .slide-up-leave-from {
                height: auto;
                opacity: 1;
            }

            .slide-up-leave-to {
                height: 0;
                opacity: 0;
            }

            /* å†…å®¹æ·¡å…¥æ·¡å‡º - ç‹¬ç«‹æ§åˆ¶ */
            .content-fade-enter-active {
                transition: opacity 0.3s ease-in-out 0.2s;
                /* å»¶è¿Ÿ0.2så¼€å§‹ï¼Œè®©å®¹å™¨å…ˆå±•å¼€ä¸€ç‚¹ */
            }

            .content-fade-leave-active {
                transition: opacity 0.2s ease-in-out;
                /* å¿«é€Ÿæ·¡å‡ºï¼Œåœ¨å®¹å™¨æ”¶å›å‰å®Œæˆ */
            }

            .content-fade-enter-from {
                opacity: 0;
            }

            .content-fade-enter-to {
                opacity: 1;
            }

            .content-fade-leave-from {
                opacity: 1;
            }

            .content-fade-leave-to {
                opacity: 0.3;
                /* ä¿æŒå¾®å¼±å¯è§åº¦ï¼Œé¿å…å®Œå…¨æ¶ˆå¤± */
            }

            /* é¢„è§ˆå¡ç‰‡åˆ‡æ¢åŠ¨ç”» - ç»Ÿä¸€çš„è¿‡æ¸¡æ•ˆæœ */
            .preview-list-move,
            .preview-list-enter-active,
            .preview-list-leave-active {
                transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            }

            /* é¢„è§ˆå¡ç‰‡åŸºç¡€æ ·å¼ */
            .preview-card {
                /* ç§»é™¤å®½åº¦å’Œflex-basisçš„transitionï¼Œé¿å…ä¸Vue transition-groupå†²çª */
                transition: opacity 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            }

            /* æ–°æ–‡ä»¶è¿›å…¥ï¼šä»å³ä¾§æ»‘å…¥ */
            .preview-list-enter-from {
                opacity: 0;
                transform: translateX(120%) scale(0.9);
            }

            .preview-list-enter-to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }

            /* è¢«æŒ¤æ‰çš„æ–‡ä»¶å‘å·¦æ»‘å‡º */
            .preview-list-leave-from {
                opacity: 1;
                transform: translateX(0) scale(1);
            }

            .preview-list-leave-to {
                opacity: 0;
                transform: translateX(-120%) scale(0.9);
            }

            /* è¢«ç§»é™¤çš„å…ƒç´ ç»å¯¹å®šä½ï¼Œä¸å½±å“å¸ƒå±€ */
            .preview-list-leave-active {
                position: absolute;
                z-index: 0;
                width: calc((100% - 1.5rem) / 2);
                /* ä¿æŒåŸå§‹å®½åº¦ */
            }

            /* ç§»åŠ¨ä¸­çš„å…ƒç´ ä¿æŒåœ¨ä¸Šå±‚ */
            .preview-list-move {
                z-index: 1;
            }

            /* é¢„è§ˆå®¹å™¨æ ·å¼ - ç¡®ä¿åŠ¨ç”»ç©ºé—´ */
            .preview-container {
                position: relative;
                min-height: 200px;
                /* ç¡®ä¿æœ‰è¶³å¤Ÿç©ºé—´è¿›è¡ŒåŠ¨ç”» */
                overflow: hidden;
                /* éšè—æ»‘å‡ºçš„å…ƒç´  */
            }

            /* ç°ä»£åŒ–çš„æŒ‰é’®æ ·å¼ */
            .btn-modern {
                transition: var(--transition-smooth);
                transform: translateY(0);
                box-shadow: var(--shadow-card);
            }

            .btn-modern:hover {
                transform: translateY(-2px);
                box-shadow: var(--shadow-soft);
            }

            .btn-modern:active {
                transform: translateY(0);
            }

            /* å¢å¼ºçš„å¡ç‰‡æ ·å¼ */
            .card-modern {
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.2);
                box-shadow: var(--shadow-card);
                transition: var(--transition-smooth), height 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            }

            .card-modern:hover {
                box-shadow: var(--shadow-soft);
                transform: translateY(-2px);
            }

            /* æ–‡ä»¶åˆ—è¡¨å®¹å™¨hoveræ•ˆæœ */
            .file-list-container {
                background: rgba(255, 255, 255, 0.8);
                border-radius: var(--border-radius);
                box-shadow: var(--shadow-card);
                transition: var(--transition-smooth);
            }

            .file-list-container:hover {
                background: rgba(255, 255, 255, 0.95);
                box-shadow: var(--shadow-soft);
                transform: translateY(-2px);
            }

            /* æ–‡ä»¶åˆ—è¡¨é¡¹hoveræ•ˆæœ */
            .file-item {
                transition: var(--transition-smooth);
                border-radius: var(--border-radius);
            }

            .file-item:hover {
                box-shadow: var(--shadow-soft);
                transform: translateY(-1px);
            }

            .file-item.selected {
                background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
                border: 1px solid #3b82f6;
                box-shadow: var(--shadow-card);
                transform: translateY(-1px);
            }

            .file-item.selected:hover {
                box-shadow: var(--shadow-soft);
                transform: translateY(-2px);
            }

            /* é¢„è§ˆå¡ç‰‡hoveræ•ˆæœ */
            .preview-card {
                background: white;
                border-radius: var(--border-radius);
                box-shadow: var(--shadow-card);
                transition: var(--transition-smooth);
            }

            .preview-card:hover {
                box-shadow: var(--shadow-soft);
                transform: translateY(-3px);
            }

            /* è¡¨æ ¼å®¹å™¨ - ç§»é™¤hoveræ•ˆæœ */
            .table-container {
                border-radius: var(--border-radius);
                overflow: hidden;
            }

            /* ç­›é€‰ä¸‹æ‹‰èœå•hoveræ•ˆæœ */
            .filter-dropdown {
                transition: var(--transition-smooth);
                border-radius: var(--border-radius);
                box-shadow: var(--shadow-card);
            }

            .filter-dropdown:hover {
                box-shadow: var(--shadow-soft);
                transform: translateY(-1px);
            }

            /* è¡¨æ ¼å¢å¼ºæ ·å¼ */
            .table-modern {
                border-collapse: separate;
                border-spacing: 0;
                overflow: hidden;
                border-radius: var(--border-radius);
                box-shadow: var(--shadow-card);
            }

            .table-modern th {
                background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
                position: sticky;
                top: 0;
                z-index: 10;
            }

            .table-modern tbody tr:hover {
                background-color: rgba(59, 130, 246, 0.05);
                transform: scale(1.002);
                transition: var(--transition-smooth);
            }

            /* æ”¹è¿›çš„å…¼å®¹æ€§ */
            .touch-friendly {
                touch-action: manipulation;
                -webkit-tap-highlight-color: transparent;
            }

            /* å¯è®¿é—®æ€§å¢å¼º */
            .focus-visible:focus {
                outline: 2px solid var(--primary-blue);
                outline-offset: 2px;
            }

            /* æ€§èƒ½ä¼˜åŒ– */
            .gpu-accelerated {
                transform: translateZ(0);
                will-change: transform;
            }

            /* å“åº”å¼ä¼˜åŒ– */
            @media (max-width: 768px) {
                .mobile-optimized {
                    padding: 12px;
                    font-size: 14px;
                }

                .btn-mobile {
                    min-height: 44px;
                    /* iOSå»ºè®®çš„æœ€å°è§¦æ‘¸ç›®æ ‡ */
                    padding: 12px 16px;
                }
            }

            /* è€æµè§ˆå™¨å›é€€ */
            @supports not (backdrop-filter: blur(10px)) {
                .card-modern {
                    background: rgba(255, 255, 255, 0.98);
                }
            }
        </style>
    </head>

    <body class="min-h-screen bg-gradient-to-br from-blue-50 via-white to-rose-50">
        <div id="app" class="container mx-auto px-2 py-6 max-w-none w-[95vw]">
            <!-- ç°ä»£åŒ–çš„ä¸»å®¹å™¨ -->
            <main class="card-modern rounded-2xl p-8 gpu-accelerated" role="main">
                <!-- æ ‡é¢˜åŒº - å¢å¼ºå¯è®¿é—®æ€§ -->
                <header class="flex flex-col gap-4 mb-10 relative">
                    <div class="flex items-end gap-4 flex-wrap">
                        <h1
                            class="text-3xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent flex items-center gap-3">
                            <span
                                class="p-3 bg-gradient-to-br from-green-400 to-blue-500 rounded-xl text-white shadow-lg">
                                <i class="fa-solid fa-table" aria-hidden="true"></i>
                            </span>
                            è¡¨æ ¼ BOM å¯¹æ¯”åˆ†æå·¥å…·
                        </h1>
                        <span class="text-lg text-gray-600 font-medium">{{ subtitle }}</span>
                    </div>
                    <p class="text-gray-700 leading-relaxed">
                        ğŸš€ ä¸“ä¸šçš„BOMè¡¨æ ¼å¯¹æ¯”åˆ†æå·¥å…·ï¼Œæ”¯æŒå¯¼å…¥å¤šä»½æ•°æ®ï¼Œå¹¶å¯å¯¹æœ€å¤šä¸¤ä»½æ•°æ®è¿›è¡Œå³æ—¶å¯¹æ¯”ã€‚
                        <strong class="text-amber-600">âš ï¸ æ³¨æ„ï¼šå¯¼å…¥çš„æ–‡ä»¶å¿…é¡»è§£å¯†æ‰å¯ç”¨ã€‚</strong>
                    </p>

                    <!-- çŠ¶æ€å¾½ç« åŒº -->
                    <div class="absolute right-0 top-0 flex flex-col items-end gap-2" aria-live="polite">
                        <transition name="fadeout">
                            <div v-if="sheetBadge.show"
                                :class="['text-sm font-medium text-white px-4 py-2 rounded-full shadow-lg', sheetBadge.bgClass]"
                                role="status">
                                {{ sheetBadge.text }}
                            </div>
                        </transition>
                        <transition name="fadeout">
                            <div v-if="sjsBadge && sjsBadge.show"
                                :class="['text-sm font-medium text-white px-4 py-2 rounded-full shadow-lg', sjsBadge.bgClass]"
                                role="status">
                                {{ sjsBadge.text }}
                            </div>
                        </transition>
                        <transition name="fadeout">
                            <div v-if="faBadge.show"
                                :class="['text-sm font-medium text-white px-4 py-2 rounded-full shadow-lg', faBadge.bgClass]"
                                role="status">
                                {{ faBadge.text }}
                            </div>
                        </transition>
                    </div>
                </header>
                <!-- æ–‡ä»¶å¯¼å…¥åŒº - å¢å¼ºçš„æ‹–æ‹½ä½“éªŒ -->
                <section class="mb-8" aria-labelledby="file-import-heading">
                    <h2 id="file-import-heading"
                        class="block mb-4 text-lg font-bold text-gray-800 flex items-center gap-2">
                        <i class="fa-solid fa-cloud-upload-alt text-blue-500" aria-hidden="true"></i>
                        æ–‡ä»¶å¯¼å…¥
                    </h2>
                    <div class="flex items-center gap-4 flex-wrap">
                        <input id="fileInput" type="file" multiple accept=".xlsx,.xls,.html,.htm" @change="handleFiles"
                            class="sr-only" aria-describedby="file-help" />
                        <label for="fileInput"
                            class="btn-modern px-6 py-3 rounded-xl bg-gradient-to-r from-blue-500 to-blue-600 text-white hover:from-blue-600 hover:to-blue-700 cursor-pointer font-semibold flex items-center gap-2 touch-friendly focus-visible"
                            tabindex="0" @keydown.enter="$refs.fileInput?.click()"
                            @keydown.space.prevent="$refs.fileInput?.click()">
                            <i class="fa-solid fa-folder-open" aria-hidden="true"></i>
                            é€‰æ‹©æ–‡ä»¶
                        </label>
                        <div class="flex flex-col gap-1">
                            <span class="text-sm font-medium text-gray-600">æ”¯æŒæ ¼å¼ï¼šExcel (.xlsx, .xls) å’Œ HTML (.html,
                                .htm)</span>
                            <span id="file-help" class="text-xs text-gray-500">ğŸ’¡ æ”¯æŒæ‰¹é‡å¯¼å…¥ï¼Œå¯åŒæ—¶é€‰æ‹©å¤šä¸ªæ–‡ä»¶</span>
                        </div>
                    </div>
                    <div v-if="loading"
                        class="mt-4 flex items-center gap-3 p-4 bg-blue-50 rounded-xl border border-blue-200"
                        role="status" aria-live="polite">
                        <div class="animate-spin w-5 h-5 border-2 border-blue-500 border-t-transparent rounded-full">
                        </div>
                        <span class="text-blue-700 font-medium">æ­£åœ¨è§£ææ–‡ä»¶ï¼Œè¯·ç¨å€™...</span>
                    </div>
                </section>
                <!-- æ–‡ä»¶åˆ—è¡¨åŒºï¼ˆæ»‘åŠ¨è¿›å…¥/ç¦»å¼€ 1sï¼‰ -->
                <transition name="slide-down">
                    <div v-if="fileList.length" class="mb-8 file-list-container p-4">
                        <div class="font-semibold mb-2 text-gray-700 flex items-center gap-2">
                            <div class="flex items-center gap-2 min-w-0">
                                <i class="fa-solid fa-list"></i>
                                <span class="whitespace-nowrap">å·²å¯¼å…¥æ–‡ä»¶ï¼ˆå…± {{ fileList.length }} ä¸ªï¼‰ï¼š</span>
                                <span class="truncate"
                                    :class="['text-sm', multiCompareMode ? 'text-red-600' : 'text-gray-500']">
                                    {{ multiCompareMode ? 'å‹¾é€‰å¤šä»½æ–‡ä»¶å¯¼å‡ºåˆ†åˆ«å¯¹æ¯”ç»“æœ' : 'å‹¾é€‰æ–‡ä»¶å³å¯é¢„è§ˆï¼ˆæœ€å¤šå¹¶åˆ—2ä¸ªï¼‰' }}
                                </span>
                            </div>
                            <div class="flex-1"></div>
                            <div class="ml-4 flex items-center gap-2">
                                <!-- å¤šæ–‡ä»¶å¯¹æ¯”å¯¼å‡ºæŒ‰é’®ï¼ˆå³ä¾§ï¼Œä½äºâ€œå…¨é€‰â€å·¦ä¾§ï¼‰ -->
                                <button type="button" :class="multiCompareMode
                                    ? 'px-2 py-1 text-xs rounded bg-red-600 text-white hover:bg-red-700'
                                    : 'px-2 py-1 text-xs rounded bg-blue-600 text-white hover:bg-blue-700'"
                                    @click="toggleMultiCompare">
                                    {{ multiCompareMode ? 'å–æ¶ˆå¤šé€‰' : 'å¤šæ–‡ä»¶å¯¹æ¯”å¯¼å‡º' }}
                                </button>
                                <!-- å…¨é€‰æŒ‰é’®ï¼šå ä½éšè—ä»¥é¿å…æŠ–åŠ¨ -->
                                <button type="button" :class="[
                                    'px-2 py-1 text-xs rounded border',
                                    multiCompareMode ? 'border-red-300 text-red-600 hover:bg-red-50' : 'invisible pointer-events-none border-transparent'
                                ]" @click="selectAllFiles">
                                    å…¨é€‰
                                </button>
                            </div>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
                            <label v-for="(file, idx) in fileList" :key="file.name"
                                class="file-item flex items-center gap-2 cursor-pointer bg-blue-50 hover:bg-blue-100 rounded px-2 py-1"
                                :class="{ 'selected': selectedFiles.includes(file.name) }">
                                <input type="checkbox" :checked="selectedFiles.includes(file.name)"
                                    @change="onFileCheckboxChange(file.name, $event.target.checked, file.status)"
                                    :disabled="file.status === 'error'" class="accent-blue-500" />
                                <span class="truncate"><i
                                        class="fa-solid fa-file-excel text-green-500 mr-1"></i>{{ file.name }}</span>
                                <span class="text-xs text-gray-400">({{ file.rows }} è¡Œ)</span>
                                <span class="ml-2">
                                    <i v-if="file.status === 'pending'"
                                        class="fa-solid fa-spinner fa-spin text-blue-400"></i>
                                    <i v-else-if="file.status === 'success'"
                                        class="fa-solid fa-check text-green-500"></i>
                                    <i v-else-if="file.status === 'error'"
                                        class="fa-solid fa-circle-exclamation text-red-500" title="è§£æå¤±è´¥"></i>
                                </span>
                                <span v-if="file.status === 'error'"
                                    class="text-xs text-red-500 ml-2">{{ file.errorMsg }}</span>
                                <button type="button" @click.stop="removeFile(idx)"
                                    class="ml-2 px-2 py-1 text-xs text-red-500 hover:text-white hover:bg-red-500 rounded transition"><i
                                        class="fa-solid fa-trash"></i> åˆ é™¤</button>
                            </label>
                        </div>
                        <div class="mt-2 text-xs" :class="multiCompareMode ? 'text-red-600' : 'text-gray-500'">
                            {{ multiCompareMode ? 'å‹¾é€‰å¤šä»½æ–‡ä»¶å¯¼å‡ºåˆ†åˆ«å¯¹æ¯”ç»“æœ' : 'å‹¾é€‰æ–‡ä»¶è¿›è¡Œé¢„è§ˆï¼ˆæœ€å¤šå¹¶åˆ—2ä¸ªï¼‰' }}
                        </div>
                    </div>
                </transition>
                <!-- å¯¹æ¯”ä»»åŠ¡å¼€å…³ + å›¾ä¾‹ + å¯¼å‡ºæŒ‰é’® -->
                <div class="mb-4 flex items-center justify-between gap-4 flex-wrap">
                    <div class="flex items-center gap-3 flex-wrap">
                        <button type="button" @click="toggleCompare"
                            :disabled="(selectedFiles.length !== 2 && !compareMode) || compareBusy"
                            class="px-3 py-1.5 rounded text-sm font-medium shadow transition flex items-center gap-2"
                            :class="compareBusy ? 'bg-gray-400 text-white cursor-wait' : (compareMode ? 'bg-red-600 text-white hover:bg-red-700' : (selectedFiles.length !== 2 ? 'bg-gray-200 text-gray-400 cursor-not-allowed' : 'bg-blue-600 text-white hover:bg-blue-700'))">
                            <i v-if="compareBusy" class="fa-solid fa-spinner fa-spin"></i>
                            <i v-else :class="compareMode ? 'fa-solid fa-toggle-on' : 'fa-solid fa-toggle-off'"></i>
                            <span>{{ compareBusy ? 'åˆ†æä¸­...' : (compareMode ? 'å…³é—­å¯¹æ¯”' : 'å¯åŠ¨å¯¹æ¯”') }}</span>
                        </button>
                        <span v-if="selectedFiles.length !== 2" class="text-xs text-gray-400">éœ€é€‰æ‹©2ä¸ªæ–‡ä»¶</span>
                        <!-- è‰²å—å›¾ä¾‹ -->
                        <div class="flex items-center gap-3 text-xs text-gray-600">
                            <span class="inline-flex items-center gap-2"><span
                                    class="w-3 h-3 inline-block rounded bg-red-600"></span>è¯¥è¡Œæœªåœ¨å¯¹è¡¨ä¸­æ‰¾åˆ°</span>
                            <span class="inline-flex items-center gap-2"><span
                                    class="w-3 h-3 inline-block rounded bg-orange-500"></span>è¯¥è¡Œè™½æœªæ‰¾åˆ°ï¼Œä½†ä¾›åº”å•†é›¶ä»¶å·åŒ¹é…</span>
                            <span class="inline-flex items-center gap-2"><span
                                    class="w-3 h-3 inline-block rounded bg-blue-600"></span>è¯¥è¡Œåœ¨å¯¹è¡¨æ‰¾åˆ°ï¼Œä½†æ•°é‡ä¸åŒ</span>
                            <span class="inline-flex items-center gap-2"><span
                                    class="w-3 h-3 inline-block rounded bg-green-600"></span>è¯¥è¡Œä¸å¯¹è¡¨ä¸­æ•°æ®ä¸€è‡´</span>
                        </div>
                    </div>
                    <div>
                        <button type="button" @click="exportCompare" :class="[
                            'px-3 py-1.5 rounded text-sm font-medium shadow transition bg-emerald-600 text-white hover:bg-emerald-700',
                            (selectedFiles.length > 0 && sheetReady) ? '' : 'invisible pointer-events-none'
                        ]" :aria-hidden="!(selectedFiles.length > 0 && sheetReady)"
                            :tabindex="(selectedFiles.length > 0 && sheetReady) ? 0 : -1" title="å¯¼å‡ºæ•°æ®">
                            <i class="fa-solid fa-file-arrow-down mr-1"></i>
                            å¯¼å‡ºæ•°æ®
                        </button>
                    </div>
                </div>
                <!-- å¹¶åˆ—é¢„è§ˆåŒº - ä¼˜åŒ–åŠ¨ç”»æ•ˆæœ -->
                <transition name="slide-up" @before-enter="onBeforeEnter" @enter="onEnter" @after-enter="onAfterEnter"
                    @before-leave="onBeforeLeave" @leave="onLeave" @after-leave="onPreviewContainerAfterLeave">
                    <div v-if="containerVisible" ref="previewWrap" class="w-full">
                        <div class="w-full preview-container">
                            <transition-group name="preview-list" tag="div"
                                class="flex w-full flex-wrap gap-6 relative">
                                <div v-for="(fileName, idx) in displayedSelectedFiles" :key="fileName"
                                    class="preview-card p-4" :style="cardStyle(idx, fileName)">
                                    <div
                                        v-if="getTable(fileName) && Array.isArray(getTable(fileName).columns) && Array.isArray(getTable(fileName).data)">
                                        <div class="flex items-center justify-between mb-2">
                                            <span class="font-semibold text-blue-600"><i
                                                    class="fa-solid fa-file-excel text-green-500 mr-1"></i>{{ fileName }}</span>
                                            <div class="flex items-center gap-2">
                                                <div v-if="compareMode" class="flex items-center gap-1">
                                                    <label class="text-xs text-gray-500 mr-2">ç‚¹å‡»å³ä¾§è‰²å—ç­›é€‰</label>
                                                    <button type="button" :class="badgeClass(fileName, 'red')"
                                                        title="ç‚¹å‡»ç­›é€‰ä»…åœ¨å¯¹è¡¨ä¸­æœªæ‰¾åˆ°çš„è¡Œ"
                                                        @click.stop="toggleColorFilter(fileName, 'red')">{{ categoryCounts(fileName).red }}</button>
                                                    <button type="button" :class="badgeClass(fileName, 'orange')"
                                                        title="ç‚¹å‡»ç­›é€‰æœªæ‰¾åˆ°ä½†ä»…åœ¨å¯¹è¡¨ä¸­ä¾›åº”å•†é›¶ä»¶å·åŒ¹é…çš„è¡Œ"
                                                        @click.stop="toggleColorFilter(fileName, 'orange')">{{ categoryCounts(fileName).orange }}</button>
                                                    <button type="button" :class="badgeClass(fileName, 'blue')"
                                                        title="ç‚¹å‡»ç­›é€‰ä»…åœ¨å¯¹è¡¨ä¸­æ•°é‡ä¸åŒçš„è¡Œ"
                                                        @click.stop="toggleColorFilter(fileName, 'blue')">{{ categoryCounts(fileName).blue }}</button>
                                                    <button type="button" :class="badgeClass(fileName, 'green')"
                                                        title="ç‚¹å‡»ç­›é€‰ä»…åœ¨å¯¹è¡¨ä¸­æ•°é‡ç›¸åŒçš„è¡Œ"
                                                        @click.stop="toggleColorFilter(fileName, 'green')">{{ categoryCounts(fileName).green }}</button>
                                                </div>
                                                <span v-if="hasActiveFilters(fileName)"
                                                    class="text-xs text-blue-600">ç­›é€‰å
                                                    {{ filteredRows(fileName).length }} è¡Œ</span>
                                                <span class="text-xs text-gray-700">å…±
                                                    {{ getTable(fileName).data.length }}
                                                    è¡Œ</span>
                                            </div>
                                        </div>
                                        <div class="overflow-auto table-container">
                                            <table class="min-w-full text-sm border border-gray-200 rounded-lg">
                                                <thead>
                                                    <tr class="bg-blue-50">
                                                        <th v-for="col in getTable(fileName).columns" :key="col"
                                                            class="px-2 py-1 font-medium text-gray-700 border-b relative">
                                                            <div class="flex items-center gap-2">
                                                                <span class="truncate" :title="col">{{ col }}</span>
                                                                <button type="button"
                                                                    class="text-gray-500 hover:text-blue-600 filter-btn"
                                                                    :data-filter-key="fileName + '__' + col"
                                                                    @click.stop="toggleFilterDropdown(fileName, col, $event)"
                                                                    :title="isColumnFiltered(fileName, col) ? 'å·²ç­›é€‰' : 'ç­›é€‰'">
                                                                    <i class="fa-solid fa-filter"></i>
                                                                    <span v-if="isColumnFiltered(fileName, col)"
                                                                        class="inline-block w-1.5 h-1.5 rounded-full bg-blue-600 ml-1"></span>
                                                                </button>
                                                            </div>
                                                            <!-- ä¸‹æ‹‰ç­›é€‰é¢æ¿ -->
                                                            <teleport to="body">
                                                                <div v-if="isDropdownOpen(fileName, col)"
                                                                    class="filter-dropdown filter-panel fixed z-[10000] bg-white border rounded shadow-lg w-64 p-2"
                                                                    :style="dropdownStyle(fileName, col)">
                                                                    <div class="mb-2">
                                                                        <input type="text"
                                                                            class="w-full border rounded px-2 py-1 text-xs"
                                                                            placeholder="æœç´¢..."
                                                                            v-model="getFilterState(fileName, col).search">
                                                                    </div>
                                                                    <div class="flex items-center gap-2 mb-2">
                                                                        <button type="button"
                                                                            class="text-xs px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded"
                                                                            @click.stop="selectAllValues(fileName, col)">å…¨é€‰</button>
                                                                        <button type="button"
                                                                            class="text-xs px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded"
                                                                            @click.stop="clearAllValues(fileName, col)">æ¸…ç©º</button>
                                                                    </div>
                                                                    <div
                                                                        class="max-h-56 overflow-auto border rounded p-1 text-sm">
                                                                        <label
                                                                            v-for="val in filteredDistinctValues(fileName, col)"
                                                                            :key="val"
                                                                            class="flex items-center gap-2 px-1 py-0.5 hover:bg-gray-50 cursor-pointer">
                                                                            <input type="checkbox"
                                                                                :checked="isValueChecked(fileName, col, val)"
                                                                                @change="onToggleValue(fileName, col, val, $event.target.checked)">
                                                                            <span class="truncate"
                                                                                :title="val || '(ç©º)'">{{ val || '(ç©º)' }}</span>
                                                                        </label>
                                                                    </div>
                                                                    <div class="flex justify-end gap-2 mt-2">
                                                                        <button
                                                                            class="text-xs px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded"
                                                                            @click.stop="closeDropdown(fileName, col)">å–æ¶ˆ</button>
                                                                        <button
                                                                            class="text-xs px-2 py-1 bg-blue-600 text-white hover:bg-blue-700 rounded"
                                                                            @click.stop="applyFilter(fileName, col)">ç¡®å®š</button>
                                                                    </div>
                                                                </div>
                                                            </teleport>
                                                        </th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr v-for="(row, rIdx) in filteredRows(fileName)" :key="rIdx"
                                                        :class="['transition hover:bg-blue-100', compareMode ? rowBgClass(fileName, row) : '']">
                                                        <td v-for="col in getTable(fileName).columns" :key="col"
                                                            class="px-2 py-1 border-b">
                                                            {{ (row && typeof row === 'object' && col in row) ? row[col] : '' }}
                                                        </td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </div>
                                        <!-- å¯¼çº¿æ•°é‡å·®å€¼ï¼ˆä»…åœ¨å¯¹æ¯”æ¨¡å¼ï¼‰ -->
                                        <div v-if="compareMode" class="mt-3 border-t pt-2">
                                            <div class="text-sm font-medium text-gray-700 mb-1 flex items-center gap-2">
                                                <i class="fa-solid fa-code-compare text-blue-500"></i>å¯¼çº¿æ•°é‡å·®å€¼
                                            </div>
                                            <div v-if="wiresDiff(fileName).length === 0" class="text-xs text-gray-400">
                                                æ— å·®å¼‚æˆ–æ— å¯¼çº¿ç±»å‹
                                            </div>
                                            <div v-else class="overflow-auto">
                                                <table class="min-w-full text-xs border border-gray-200 rounded">
                                                    <thead>
                                                        <tr class="bg-gray-50">
                                                            <th class="px-2 py-1 border-b text-left">é›¶ä»¶å·</th>
                                                            <th class="px-2 py-1 border-b text-left">ç±»å‹</th>
                                                            <th class="px-2 py-1 border-b text-right">æœ¬è¡¨æ•°é‡</th>
                                                            <th class="px-2 py-1 border-b text-right">å¯¹è¡¨æ•°é‡</th>
                                                            <th class="px-2 py-1 border-b text-right">å·®å€¼(æœ¬-å¯¹)</th>
                                                        </tr>
                                                    </thead>
                                                    <tbody>
                                                        <tr v-for="(d, i) in wiresDiff(fileName)" :key="i">
                                                            <td class="px-2 py-1 border-b">{{ d.pn }}</td>
                                                            <td class="px-2 py-1 border-b">{{ d.type }}</td>
                                                            <td class="px-2 py-1 border-b text-right">{{ d.q1 }}
                                                            </td>
                                                            <td class="px-2 py-1 border-b text-right">{{ d.q2 }}
                                                            </td>
                                                            <td class="px-2 py-1 border-b text-right"
                                                                :class="d.diff === 0 ? 'text-gray-500' : (d.diff > 0 ? 'text-green-600' : 'text-red-600')">
                                                                {{ d.diff }}
                                                            </td>
                                                        </tr>
                                                    </tbody>
                                                </table>
                                            </div>
                                        </div>
                                    </div>
                                    <div v-else class="text-red-500 text-sm">è¡¨æ ¼æ•°æ®ä¸å­˜åœ¨æˆ–å·²è¢«åˆ é™¤</div>
                            </transition-group>
                        </div>
                    </div>
                </transition>
                <!-- è§†å£å›åˆ°é¡¶éƒ¨æŒ‰é’®ï¼ˆTeleport åˆ° bodyï¼Œç¡®ä¿è´´å¯è§†åŒºå³ä¸‹è§’ï¼‰ -->
                <teleport to="body">
                    <div
                        :class="['fixed bottom-0 right-0 z-[9999] transform transition-all duration-300', showTop ? 'translate-x-0 opacity-100' : 'translate-x-24 opacity-0 pointer-events-none']">
                        <button @click="scrollToTop" aria-label="å›åˆ°é¡¶éƒ¨" title="å›åˆ°é¡¶éƒ¨"
                            class="w-8 h-8 rounded-lg bg-blue-600 text-white shadow-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-300 flex items-center justify-center">
                            <i class="fa-solid fa-arrow-up text-xs"></i>
                        </button>
                    </div>
                </teleport>
                <script>
                    const { createApp, ref, reactive, onMounted, onUnmounted, watch, nextTick } = Vue;
                    createApp({
                        setup() {
                            // ======================== æ ¸å¿ƒçŠ¶æ€ä¸å¸¸é‡ ========================
                            const tables = reactive([]);
                            const fileList = reactive([]);
                            const selectedFiles = ref([]);

                            // é€šç”¨å¸¸é‡å®šä¹‰
                            const HEADER_TOKENS = new Set(['é›¶ä»¶å·', 'ä¾›åº”å•†é›¶ä»¶å·', 'å®¢æˆ·é›¶ä»¶å·']);
                            const COLUMN_NAMES = {
                                PART_NUMBER: 'é›¶ä»¶å·',
                                SUPPLIER_PART_NUMBER: 'ä¾›åº”å•†é›¶ä»¶å·',
                                CUSTOMER_PART_NUMBER: 'å®¢æˆ·é›¶ä»¶å·',
                                QUANTITY: 'æ•°é‡',
                                TYPE: 'ç±»å‹'
                            };
                            const WIRE_TYPES = new Set(['WIRE', 'çº¿æŸ', 'å¯¼çº¿']);
                            const COLOR_TO_PRIORITY = { red: 0, orange: 1, blue: 2, green: 3 };

                            // ======================== é€šç”¨å·¥å…·å‡½æ•° ========================

                            /* UNUSED: ç”±ä¸‹æ–¹åŒåå‡½æ•°è¦†ç›–ï¼Œä¿ç•™ä¸€å¤„å®šä¹‰å³å¯
                            // æ•°å­—è½¬æ¢å‡½æ•°ï¼ˆå¤„ç†åƒä½åˆ†éš”ç¬¦ï¼Œç©ºå€¼è½¬0ï¼‰
                            function toNumber(v) {
                                if (v == null || v === '') return 0;
                                const n = parseFloat(String(v).replace(/,/g, ''));
                                return isNaN(n) ? 0 : n;
                            }
                            */

                            // è§„èŒƒåŒ–é”®åå‡½æ•°ï¼ˆé›¶ä»¶å·ä¸“ç”¨ï¼‰
                            function normalizeKey(key) {
                                if (key == null) return '';
                                let s = String(key);
                                s = s.replace(/[\u200B-\u200D\uFEFF\u00AD]/g, '');
                                s = s.replace(/[\s\u00A0]+/g, '').trim();
                                return s;
                            }

                            /* UNUSED: æœªåœ¨å½“å‰é€»è¾‘ä¸­è°ƒç”¨
                            // é”™è¯¯å¤„ç†å·¥å…·
                            function handleError(error, context = '') {
                                console.error(`Error ${context}:`, error);
                                const message = error?.message || String(error) || 'Unknown error';
                                alert(`æ“ä½œå¤±è´¥${context ? ' (' + context + ')' : ''}: ${message}`);
                            }
                            */

                            // ======================== é€šç”¨å­—ç¬¦ä¸²å¤„ç† ========================

                            /* UNUSED: é€šç”¨å·¥å…·å½“å‰æœªä½¿ç”¨
                            function safeString(value) { return value != null ? String(value).trim() : ''; }
                            function getStringProp(obj, prop) { return safeString(obj && obj[prop]); }
                            function isEmpty(str) { return !str || !String(str).trim(); }
                            function safeExecute(fn, defaultValue = null, context = '') {
                                try { return fn(); } catch (err) { if (context) console.warn(`Safe execution failed (${context}):`, err); return defaultValue; }
                            }
                            async function safeExecuteAsync(fn, defaultValue = null, context = '') {
                                try { return await fn(); } catch (err) { if (context) console.warn(`Async safe execution failed (${context}):`, err); return defaultValue; }
                            }
                            */

                            // ======================== æ–‡ä»¶è§£æå·¥å…·å‡½æ•° ========================

                            // ç”Ÿæˆå”¯ä¸€æ–‡ä»¶åï¼ˆæ”¯æŒé‡å¤å¯¼å…¥ï¼Œè‡ªåŠ¨æ·»åŠ åç¼€ï¼‰
                            function generateUniqueFileName(originalName) {
                                let displayName = originalName;
                                let counter = 2;
                                while (fileList.some(f => f.name === displayName)) {
                                    displayName = `${originalName} (${counter})`;
                                    counter++;
                                }
                                return displayName;
                            }

                            /* UNUSED: æ—§ç‰ˆè¡¨å¤´ä¸è¡Œæ¸…ç†é€»è¾‘ï¼Œå·²è¢«ç»Ÿä¸€ç®¡é“æ›¿ä»£
                            function isHeaderRow(cellData) { const firstCellText = String(cellData[0] || '').trim(); return HEADER_TOKENS.has(firstCellText); }
                            function cleanDataRows(rows, columns) {
                                return rows.filter(row => {
                                    if (!row || typeof row !== 'object') return false;
                                    const firstCol = String(row[columns[0]] || '').trim();
                                    if (!firstCol || HEADER_TOKENS.has(firstCol) || firstCol.startsWith('Design')) return false;
                                    return true;
                                });
                            }
                            */

                            // å¤„ç†é›¶ä»¶å·å¡«å……å’Œæ•°æ®æ¸…ç†
                            function processPartNumbers(rows, columns) {
                                try {
                                    if (!columns.includes(COLUMN_NAMES.PART_NUMBER)) {
                                        columns.unshift(COLUMN_NAMES.PART_NUMBER);
                                    }

                                    const hasPN = columns.includes(COLUMN_NAMES.PART_NUMBER);
                                    const hasSPN = columns.includes(COLUMN_NAMES.SUPPLIER_PART_NUMBER);

                                    if (!hasPN && !hasSPN) return rows;

                                    return rows.filter((row, index) => {
                                        try {
                                            const pn0 = row[COLUMN_NAMES.PART_NUMBER];
                                            const spn0 = row[COLUMN_NAMES.SUPPLIER_PART_NUMBER];
                                            const pn = normalizeKey(pn0);
                                            const spn = normalizeKey(spn0);

                                            // å¦‚æœé›¶ä»¶å·å’Œä¾›åº”å•†é›¶ä»¶å·éƒ½ä¸ºç©ºï¼Œä¸¢å¼ƒè¯¥è¡Œ
                                            if (!pn && !spn) return false;

                                            // å¦‚æœé›¶ä»¶å·ä¸ºç©ºä½†ä¾›åº”å•†é›¶ä»¶å·æœ‰å€¼ï¼Œå¡«å……é›¶ä»¶å·
                                            if (!pn && spn) {
                                                row[COLUMN_NAMES.PART_NUMBER] = spn0;
                                            }

                                            return true;
                                        } catch (err) {
                                            console.warn(`å¤„ç†ç¬¬${index + 1}è¡Œé›¶ä»¶å·æ•°æ®æ—¶å‡ºé”™:`, err.message);
                                            return false; // è·³è¿‡æœ‰é—®é¢˜çš„è¡Œ
                                        }
                                    });
                                } catch (err) {
                                    throw new Error(`é›¶ä»¶å·å¤„ç†å¤±è´¥: ${err.message}`);
                                }
                            }

                            // å¤„ç†å¯¼çº¿ç±»å‹çš„ä¸‰æ®µå·è§„èŒƒåŒ–
                            function processWireTypes(rows, columns) {
                                const colPN = columns.find(c => c === COLUMN_NAMES.PART_NUMBER);
                                const colType = columns.find(c => c && c.includes(COLUMN_NAMES.TYPE));

                                if (!colPN || !colType) return;

                                const TYPE_SET = WIRE_TYPES;

                                rows.forEach(r => {
                                    const t = r && r[colType];
                                    const aVal = r && r[colPN];
                                    const aStr = (aVal == null ? '' : String(aVal)).trim();

                                    if (TYPE_SET.has(String(t).trim())) {
                                        const parts = aStr.split('-');
                                        if (parts.length === 3) {
                                            r[colPN] = parts[0] + '-' + parts[1];
                                        }
                                    }
                                });
                            }

                            // æŒ‰é›¶ä»¶å·èšåˆæ•°æ®
                            function aggregateByPartNumber(rows, columns) {
                                try {
                                    const colPN = columns.find(c => c === COLUMN_NAMES.PART_NUMBER);
                                    const colQty = columns.find(c => c && c.includes(COLUMN_NAMES.QUANTITY));

                                    if (!colPN || !colQty) return rows;

                                    const map = new Map();
                                    rows.forEach((row, index) => {
                                        try {
                                            const key = String((row && row[colPN]) ?? '').trim();
                                            if (!key) {
                                                console.warn(`ç¬¬${index + 1}è¡Œ: é›¶ä»¶å·ä¸ºç©ºï¼Œè·³è¿‡èšåˆ`);
                                                return;
                                            }

                                            if (!map.has(key)) {
                                                const base = { ...row };
                                                const qtyValue = toNumber(base[colQty]);
                                                if (isNaN(qtyValue)) {
                                                    console.warn(`ç¬¬${index + 1}è¡Œ: æ•°é‡å€¼"${base[colQty]}"æ— æ³•è½¬æ¢ä¸ºæ•°å­—ï¼Œä½¿ç”¨0æ›¿ä»£`);
                                                    base[colQty] = 0;
                                                } else {
                                                    base[colQty] = qtyValue;
                                                }
                                                map.set(key, base);
                                            } else {
                                                const agg = map.get(key);
                                                const currentQty = toNumber(agg[colQty]);
                                                const addQty = toNumber(row[colQty]);
                                                agg[colQty] = currentQty + addQty;
                                            }
                                        } catch (err) {
                                            console.warn(`å¤„ç†ç¬¬${index + 1}è¡Œèšåˆæ—¶å‡ºé”™:`, err.message);
                                        }
                                    });

                                    return Array.from(map.values());
                                } catch (err) {
                                    throw new Error(`æ•°æ®èšåˆå¤±è´¥: ${err.message}`);
                                }
                            }

                            // ======================== HTMLè§£æå·¥å…·å‡½æ•° ========================

                            /* UNUSED: å·²æ”¹ä¸ºä½¿ç”¨ SheetJS è§£æ HTML
                            // function parseHTMLTables(htmlText) {}
                            */

                            // ä½¿ç”¨ SheetJS è§£æ HTMLï¼ŒæŒ‰åŒä¹‰è¯è¯†åˆ«è¡¨å¤´å¹¶è¾“å‡ºè§„èŒƒåˆ—å
                            function parseHTMLWithSheetJS(htmlText) {
                                if (!window.XLSX) return { rows: [], columns: [] };
                                const normalizeHeaderText = (v) => {
                                    if (v == null) return '';
                                    let s = String(v);
                                    s = s.replace(/[\u200B-\u200D\uFEFF\u00AD]/g, '');
                                    s = s.replace(/[\u00A0\s]+/g, ' ').trim();
                                    return s;
                                };
                                const toKey = (s) => normalizeHeaderText(s).toLowerCase();
                                const CANONICAL = {
                                    [COLUMN_NAMES.PART_NUMBER]: new Set(['é›¶ä»¶å·', 'pn', 'part no', 'part number', 'ç‰©æ–™å·', 'æ–™å·', 'ç¼–å·', 'éƒ¨ä»¶å·']),
                                    [COLUMN_NAMES.SUPPLIER_PART_NUMBER]: new Set(['ä¾›åº”å•†é›¶ä»¶å·', 'ä¾›åº”å•†æ–™å·', 'ä¾›åº”å•†pn', 'ä¾›åº”å•†ç¼–å·', 'ä¾›åº”å•†ç‰©æ–™å·']),
                                    [COLUMN_NAMES.CUSTOMER_PART_NUMBER]: new Set(['å®¢æˆ·é›¶ä»¶å·', 'å®¢æˆ·æ–™å·', 'å®¢æˆ·pn']),
                                    [COLUMN_NAMES.TYPE]: new Set(['ç±»å‹', 'å“ç±»', 'ç±»åˆ«', 'type', 'çº¿æŸç±»å‹']),
                                    [COLUMN_NAMES.QUANTITY]: new Set(['æ•°é‡', 'qty', 'æ•°é‡(pcs)', 'æ•°é‡ï¼ˆpcsï¼‰', 'æ•°ç›®'])
                                };
                                const allSynonyms = new Map();
                                Object.entries(CANONICAL).forEach(([canon, set]) => {
                                    Array.from(set).forEach(s => allSynonyms.set(toKey(s), canon));
                                });
                                const wb = XLSX.read(htmlText, { type: 'string' });
                                const aggregatedRows = [];
                                const seenColsOrder = [];
                                const seenColsSet = new Set();
                                (wb.SheetNames || []).forEach(name => {
                                    const ws = wb.Sheets[name];
                                    if (!ws) return;
                                    const AOA = XLSX.utils.sheet_to_json(ws, { header: 1, defval: '' });
                                    if (!Array.isArray(AOA) || !AOA.length) return;
                                    const maxScan = Math.min(10, AOA.length);
                                    let headerIdx = -1, bestCount = -1;
                                    for (let i = 0; i < maxScan; i++) {
                                        const row = AOA[i] || [];
                                        let count = 0; const seen = new Set();
                                        row.forEach(cell => {
                                            const canon = allSynonyms.get(toKey(cell));
                                            if (canon && !seen.has(canon)) { seen.add(canon); count++; }
                                        });
                                        if (count > bestCount) { bestCount = count; headerIdx = i; }
                                    }
                                    if (headerIdx === -1) return;
                                    const rawHeader = (AOA[headerIdx] || []).map(h => normalizeHeaderText(h));
                                    const columns = rawHeader.map(h => allSynonyms.get(toKey(h)) || h);
                                    // è®°å½•åˆ—é¡ºåºï¼ˆåˆå¹¶å¤šä¸ªè¡¨æ—¶ä¿ç•™é¦–æ¬¡å‡ºç°é¡ºåºï¼‰
                                    columns.forEach(c => { if (c && !seenColsSet.has(c)) { seenColsSet.add(c); seenColsOrder.push(c); } });
                                    for (let r = headerIdx + 1; r < AOA.length; r++) {
                                        const row = AOA[r] || [];
                                        // è·³è¿‡ç©ºè¡Œ
                                        if (!row.some(v => String(v || '').trim() !== '')) continue;
                                        const normCells = row.map(v => normalizeHeaderText(v));
                                        const first = normCells[0] || '';
                                        // åˆ é™¤è®¾è®¡è¯´æ˜è¡Œ
                                        if (first.startsWith('Design')) continue;
                                        // ä¸ XLSX è·¯å¾„å¯¹é½çš„â€œé‡å¤è¡¨å¤´â€è§„åˆ™ï¼š
                                        // åªåœ¨ç¬¬ä¸€åˆ—ä¸ºä»¤ç‰Œï¼ˆé›¶ä»¶å·/ä¾›åº”å•†é›¶ä»¶å·/å®¢æˆ·é›¶ä»¶å·ï¼‰æˆ–å¯æ˜ å°„ä¸ºâ€œé›¶ä»¶å·â€æ—¶æ‰åˆ¤å®šä¸ºè¡¨å¤´
                                        const firstCanon = allSynonyms.get(toKey(first));
                                        if ((typeof HEADER_TOKENS !== 'undefined' && HEADER_TOKENS.has(first)) || firstCanon === COLUMN_NAMES.PART_NUMBER) {
                                            continue;
                                        }
                                        const o = {};
                                        for (let c = 0; c < columns.length; c++) {
                                            o[columns[c]] = row[c] != null ? String(row[c]).trim() : '';
                                        }
                                        aggregatedRows.push(o);
                                    }
                                });
                                // éœ€è‡³å°‘åŒ…å«å…³é”®åˆ—
                                const hasKey = seenColsSet.has(COLUMN_NAMES.PART_NUMBER) || seenColsSet.has(COLUMN_NAMES.SUPPLIER_PART_NUMBER);
                                if (!hasKey) return { columns: [], rows: [] };
                                // è§„èŒƒåˆ—é¡ºåºï¼šä¼˜å…ˆå…³é”®åˆ—ï¼Œå…¶ä½™æŒ‰é¦–æ¬¡å‡ºç°é¡ºåº
                                const preferred = [COLUMN_NAMES.PART_NUMBER, COLUMN_NAMES.SUPPLIER_PART_NUMBER, COLUMN_NAMES.CUSTOMER_PART_NUMBER, COLUMN_NAMES.TYPE, COLUMN_NAMES.QUANTITY];
                                const finalColumns = [];
                                preferred.forEach(k => { if (seenColsSet.has(k)) finalColumns.push(k); });
                                seenColsOrder.forEach(c => { if (!finalColumns.includes(c)) finalColumns.push(c); });
                                return { columns: finalColumns, rows: aggregatedRows };
                            }

                            // ======================== Excelè§£æå·¥å…·å‡½æ•° ========================

                            // è§£æExcelæ–‡ä»¶æ•°æ®
                            async function parseExcelFile(fileBuffer, fileName) {
                                try {
                                    const workbook = new ExcelJS.Workbook();
                                    await workbook.xlsx.load(fileBuffer);
                                    const ws = workbook.worksheets[0];
                                    if (!ws) throw new Error('å·¥ä½œè¡¨ä¸ºç©º');
                                    // æ‹‰å¹³æˆ AOAï¼ˆè¡Œã€åˆ—å‡ä»1å¼€å§‹å¡«å……ï¼Œä¿æŒä¸ grid è¯»å–ä¸€è‡´ï¼‰
                                    const grid = [];
                                    const safeCellText = (cell) => {
                                        try {
                                            if (!cell) return '';
                                            if (cell.text != null) return String(cell.text).trim();
                                            const v = cell.value;
                                            if (v == null) return '';
                                            const t = typeof v;
                                            if (t === 'string' || t === 'number' || t === 'boolean') return String(v).trim();
                                            if (v && typeof v === 'object') {
                                                if (Array.isArray(v.richText)) return String(v.richText.map(x => x && x.text || '').join('')).trim();
                                                if (v.result != null) return String(v.result).trim();
                                                if (v.text != null) return String(v.text).trim();
                                            }
                                            // æœ€åå…œåº•ï¼šå¯èƒ½æŸäº›å¯¹è±¡è‡ªå®šä¹‰äº†æ— æ•ˆ toStringï¼Œæ•è·å¼‚å¸¸
                                            try { return String(v).trim(); } catch { return ''; }
                                        } catch { return ''; }
                                    };
                                    let maxRow = 0, maxCol = 0;
                                    ws.eachRow({ includeEmpty: true }, (row, r) => {
                                        maxRow = Math.max(maxRow, r);
                                        row.eachCell({ includeEmpty: true }, (cell, c) => {
                                            maxCol = Math.max(maxCol, c);
                                            if (!grid[r]) grid[r] = [];
                                            grid[r][c] = safeCellText(cell);
                                        });
                                    });
                                    // è§„èŒƒåŒ–ä¸åŒä¹‰è¯è¡¨
                                    const normalizeHeaderText = (v) => {
                                        if (v == null) return '';
                                        let s = String(v);
                                        s = s.replace(/[\u200B-\u200D\uFEFF\u00AD]/g, '');
                                        s = s.replace(/[\u00A0\s]+/g, ' ').trim();
                                        return s;
                                    };
                                    const toKey = (s) => normalizeHeaderText(s).toLowerCase();
                                    const CANONICAL = {
                                        [COLUMN_NAMES.PART_NUMBER]: new Set(['é›¶ä»¶å·', 'pn', 'part no', 'part number', 'ç‰©æ–™å·', 'æ–™å·', 'ç¼–å·', 'éƒ¨ä»¶å·']),
                                        [COLUMN_NAMES.SUPPLIER_PART_NUMBER]: new Set(['ä¾›åº”å•†é›¶ä»¶å·', 'ä¾›åº”å•†æ–™å·', 'ä¾›åº”å•†pn', 'ä¾›åº”å•†ç¼–å·', 'ä¾›åº”å•†ç‰©æ–™å·']),
                                        [COLUMN_NAMES.CUSTOMER_PART_NUMBER]: new Set(['å®¢æˆ·é›¶ä»¶å·', 'å®¢æˆ·æ–™å·', 'å®¢æˆ·pn']),
                                        [COLUMN_NAMES.TYPE]: new Set(['ç±»å‹', 'å“ç±»', 'ç±»åˆ«', 'type', 'çº¿æŸç±»å‹']),
                                        [COLUMN_NAMES.QUANTITY]: new Set(['æ•°é‡', 'qty', 'æ•°é‡(pcs)', 'æ•°é‡ï¼ˆpcsï¼‰', 'æ•°ç›®'])
                                    };
                                    const allSynonyms = new Map();
                                    Object.entries(CANONICAL).forEach(([canon, set]) => {
                                        Array.from(set).forEach(s => allSynonyms.set(toKey(s), canon));
                                    });
                                    // æ‰«æå‰10è¡Œï¼Œé€‰æ‹©åŒä¹‰åŒ¹é…æœ€å¤šçš„ä½œä¸ºè¡¨å¤´
                                    let headerRowIndex = -1, bestCount = -1;
                                    const maxScan = Math.min(10, maxRow);
                                    for (let r = 1; r <= maxScan; r++) {
                                        const row = grid[r] || [];
                                        let count = 0; const seen = new Set();
                                        for (let c = 1; c <= maxCol; c++) {
                                            const canon = allSynonyms.get(toKey(row[c] || ''));
                                            if (canon && !seen.has(canon)) { seen.add(canon); count++; }
                                        }
                                        if (count > bestCount) { bestCount = count; headerRowIndex = r; }
                                    }
                                    if (headerRowIndex === -1) {
                                        // å…œåº•ï¼šå°è¯•ç”¨ç¬¬ä¸€åˆ—ä»¤ç‰Œå®šä½ï¼›å†ä¸è¡Œç”¨ç¬¬1è¡Œ
                                        for (let r = 1; r <= Math.min(maxRow, 100); r++) {
                                            const first = normalizeHeaderText(((grid[r] || [])[1]) || '');
                                            if (typeof HEADER_TOKENS !== 'undefined' && HEADER_TOKENS.has(first)) { headerRowIndex = r; break; }
                                        }
                                        if (headerRowIndex === -1) headerRowIndex = 1;
                                    }
                                    // æ„å»ºè§„èŒƒåˆ—å
                                    const rawHeader = [];
                                    for (let c = 1; c <= maxCol; c++) rawHeader.push(normalizeHeaderText((grid[headerRowIndex] || [])[c] || ''));
                                    const mapped = rawHeader.map(h => allSynonyms.get(toKey(h)) || h);
                                    const columns = [];
                                    const seenCols = new Set();
                                    mapped.forEach(c => { if (c && !seenCols.has(c)) { seenCols.add(c); columns.push(c); } });
                                    // æå–æ•°æ®è¡Œ
                                    const rows = [];
                                    for (let r = headerRowIndex + 1; r <= maxRow; r++) {
                                        // åˆ¤æ–­ç©ºè¡Œ
                                        let any = false; for (let c = 1; c <= maxCol; c++) { if ((grid[r] || [])[c] && String((grid[r] || [])[c]).trim() !== '') { any = true; break; } }
                                        if (!any) continue;
                                        const first = normalizeHeaderText(((grid[r] || [])[1]) || '');
                                        if (first.startsWith('Design')) continue;
                                        const firstCanon = allSynonyms.get(toKey(first));
                                        if ((typeof HEADER_TOKENS !== 'undefined' && HEADER_TOKENS.has(first)) || firstCanon === COLUMN_NAMES.PART_NUMBER) continue;
                                        const o = {};
                                        for (let i = 0; i < columns.length; i++) {
                                            const v = (grid[r] || [])[i + 1];
                                            o[columns[i]] = v != null ? String(v).trim() : '';
                                        }
                                        rows.push(o);
                                    }
                                    const hasKey = columns.includes(COLUMN_NAMES.PART_NUMBER) || columns.includes(COLUMN_NAMES.SUPPLIER_PART_NUMBER);
                                    if (!hasKey) throw new Error('æœªæ£€æµ‹åˆ°å…³é”®åˆ—');
                                    return { rows, columns };
                                } catch (err) {
                                    throw new Error(`Excelè§£æå¤±è´¥: ${err.message}`);
                                }
                            }

                            /* UNUSED: åˆ—åè½¬æ•°å­—
                            function columnToNumber(col) { let result = 0; for (let i = 0; i < col.length; i++) { result = result * 26 + (col.charCodeAt(i) - 64); } return result; }
                            */

                            // ======================== æ•°æ®å¤„ç†æµæ°´çº¿ ========================

                            // å¯¹åŸå§‹æ•°æ®æ‰§è¡Œå®Œæ•´çš„å¤„ç†æµç¨‹
                            function processRawData(rawRows, rawColumns) {
                                try {
                                    // 1. é›¶ä»¶å·å¡«å……å’Œæ•°æ®æ¸…ç†
                                    let rows = processPartNumbers(rawRows, rawColumns);
                                    let columns = [...rawColumns];

                                    // 2. å¯¼çº¿ç±»å‹è§„èŒƒåŒ–
                                    processWireTypes(rows, columns);

                                    // 3. æŒ‰é›¶ä»¶å·èšåˆ
                                    rows = aggregateByPartNumber(rows, columns);

                                    // 4. æ’åºï¼ˆæŒ‰é›¶ä»¶å·è‡ªç„¶å‡åºï¼‰
                                    const colPN = columns.find(c => c === COLUMN_NAMES.PART_NUMBER);
                                    if (colPN) {
                                        rows.sort((a, b) => {
                                            const aVal = String(a[colPN] || '').trim();
                                            const bVal = String(b[colPN] || '').trim();
                                            return aVal.localeCompare(bVal, undefined, {
                                                numeric: true,
                                                sensitivity: 'accent'
                                            });
                                        });
                                    }

                                    return { rows, columns };
                                } catch (err) {
                                    console.error('æ•°æ®å¤„ç†å¤±è´¥:', err);
                                    throw new Error(`æ•°æ®æ¸…æ´—å¤±è´¥: ${err.message || 'æœªçŸ¥é”™è¯¯'}`);
                                }
                            }

                            // ======================== å¯¼å‡ºå·¥å…·å‡½æ•° ========================

                            // Excelæ ·å¼å¸¸é‡
                            const EXCEL_COLORS = {
                                LIGHT_GRAY: 'FFF0F0F0',
                                RED: 'FFFF9999',
                                ORANGE: 'FFFFCC99',
                                BLUE: 'FF99CCFF',
                                GREEN: 'FF99FF99'
                            };

                            // åˆ›å»ºçº¯è‰²å¡«å……
                            function createSolidFill(color) {
                                return { type: 'pattern', pattern: 'solid', fgColor: { argb: color } };
                            }

                            /* UNUSED: ä½¿ç”¨ applyBordersForRange ä»£æ›¿
                            // function applyBordersToRange(worksheet, startRow, startCol, endRow, endCol) {}
                            */

                            /* UNUSED: ä¸‹æ–¹æœ‰æ”¹è¿›ç‰ˆ autoFitColumns
                            // function autoFitColumns(worksheet) {}
                            */

                            // æ¸…ç†æ–‡ä»¶åç”¨äºExcelå·¥ä½œè¡¨
                            function sanitizeSheetName(name, usedNames) {
                                let cleaned = String(name).replace(/[\\\/:\*\?\[\]]/g, '_');
                                cleaned = cleaned.substring(0, 31); // Excelå·¥ä½œè¡¨åé™åˆ¶

                                let candidate = cleaned;
                                let counter = 1;
                                while (usedNames.has(candidate)) {
                                    const suffix = `_${counter}`;
                                    const maxBase = 31 - suffix.length;
                                    candidate = cleaned.substring(0, maxBase) + suffix;
                                    counter++;
                                }
                                usedNames.add(candidate);
                                return candidate;
                            }

                            /* UNUSED: å·²æ”¹ç”¨ sanitizeFileBase æ´¾ç”Ÿæ–‡ä»¶å
                            function sanitizeFileName(name) { return String(name).replace(/[\\\/:\*\?\[\]<>|"]/g, '_'); }
                            */

                            /* UNUSED: ä¸‹æ–¹å·²å®šä¹‰åŒåä¸‹è½½å‡½æ•°
                            // async function downloadWorkbook(workbook, filename) {}
                            */
                            // é¢„è§ˆå®¹å™¨æ˜¾ç¤ºæ§åˆ¶ï¼šä¸ selectedFiles è§£è€¦
                            const containerVisible = ref(false);
                            const displayedSelectedFiles = ref([]);
                            const previewWrap = ref(null);
                            const subtitle = ref('V2.6.1 - Beta ç½‘é¡µç‰ˆ HTMLè§£æè¡¥ä¸ä¸Šçº¿');
                            const loading = ref(false);
                            const compareMode = ref(false);
                            const multiCompareMode = ref(false);
                            const compareBusy = ref(false);
                            const dataEpoch = ref(0); // æ•°æ®ç‰ˆæœ¬å·ï¼šæ¯æ¬¡è£…è½½/åˆ é™¤æ–‡ä»¶åè‡ªå¢ï¼Œç”¨äºç¼“å­˜å¤±æ•ˆ
                            // åŸå§‹è¡Œç´¢å¼•æ˜ å°„ï¼šfileName -> WeakMap(rowObj -> index)
                            const originalIndexMaps = new Map();
                            // æ¯”å¯¹ç»“æœç¼“å­˜ï¼šfileName -> { categories: Int8Array|number[], wiresDiff: Array<{pn,type,q1,q2,diff}> }
                            const compareCache = reactive({});
                            let compareWorker = null;
                            function ensureCompareWorker() {
                                if (compareWorker) return compareWorker;
                                const workerCode = `
                                    self.onmessage = (e) => {
                                        const { left, right } = e.data || {};
                                        const TYPE_SET = new Set(['WIRE','çº¿æŸ','å¯¼çº¿']);
                                        const toNumber = (v) => { if (v == null || v === '') return 0; const n = parseFloat(String(v).replace(/,/g,'')); return isNaN(n)?0:n; };
                                        const leftRows = Array.isArray(left?.rows) ? left.rows : [];
                                        const rightRows = Array.isArray(right?.rows) ? right.rows : [];
                                        // æ„å»ºå³è¡¨ç´¢å¼•ä¸çº¢é›†åˆ
                                        const leftPNSet = new Set();
                                        leftRows.forEach(r=>{ const pn=String((r&&r['é›¶ä»¶å·'])??'').trim(); if(pn) leftPNSet.add(pn); });
                                        const rightByPN = new Map();
                                        rightRows.forEach(r=>{ const pn=String((r&&r['é›¶ä»¶å·'])??'').trim(); if(pn) rightByPN.set(pn,r); });
                                        const rightRedSupplierSet = new Set();
                                        rightRows.forEach(r=>{ const pn=String((r&&r['é›¶ä»¶å·'])??'').trim(); const spn=String((r&&r['ä¾›åº”å•†é›¶ä»¶å·'])??'').trim(); if(!pn||!spn) return; if(!leftPNSet.has(pn)) rightRedSupplierSet.add(spn); });
                                        // è®¡ç®—å·¦->å³åˆ†ç±»
                                        const categoriesL = new Array(leftRows.length).fill(3);
                                        let countsL = {red:0, orange:0, blue:0, green:0};
                                        for (let i=0;i<leftRows.length;i++){
                                            const row = leftRows[i];
                                            const pn = String((row&&row['é›¶ä»¶å·'])??'').trim();
                                            const other = pn? rightByPN.get(pn): undefined;
                                            let cat = 3;
                                            if(!other){
                                                const spn = String((row&&row['ä¾›åº”å•†é›¶ä»¶å·'])??'').trim();
                                                cat = (spn && rightRedSupplierSet.has(spn)) ? 1 : 0;
                                            } else {
                                                const q1 = toNumber(row['æ•°é‡']);
                                                const q2 = toNumber(other['æ•°é‡']);
                                                cat = (q1===q2)?3:2;
                                            }
                                            categoriesL[i]=cat;
                                            if (cat===0) countsL.red++; else if(cat===1) countsL.orange++; else if(cat===2) countsL.blue++; else countsL.green++;
                                        }
                                        // wiresDiffï¼ˆå·¦è¡¨ï¼‰
                                        const wiresL = [];
                                        for(let i=0;i<leftRows.length;i++){
                                            const row = leftRows[i];
                                            const pn = String((row&&row['é›¶ä»¶å·'])??'').trim();
                                            const tp = String((row&&row['ç±»å‹'])??'').trim();
                                            if(!pn || !TYPE_SET.has(tp)) continue;
                                            const other = rightByPN.get(pn);
                                            const q1 = toNumber(row['æ•°é‡']);
                                            const q2 = other? toNumber(other['æ•°é‡']) : 0;
                                            wiresL.push({ pn, type: tp, q1, q2, diff: q1 - q2 });
                                        }
                                        // å³->å·¦ï¼ˆä¸ºå¯¹ç§°æ˜¾ç¤ºé¢„å…ˆç®—å¥½ï¼‰
                                        const rightPNSet = new Set();
                                        rightRows.forEach(r=>{ const pn=String((r&&r['é›¶ä»¶å·'])??'').trim(); if(pn) rightPNSet.add(pn); });
                                        const leftByPN = new Map();
                                        leftRows.forEach(r=>{ const pn=String((r&&r['é›¶ä»¶å·'])??'').trim(); if(pn) leftByPN.set(pn,r); });
                                        const leftRedSupplierSet = new Set();
                                        leftRows.forEach(r=>{ const pn=String((r&&r['é›¶ä»¶å·'])??'').trim(); const spn=String((r&&r['ä¾›åº”å•†é›¶ä»¶å·'])??'').trim(); if(!pn||!spn) return; if(!rightPNSet.has(pn)) leftRedSupplierSet.add(spn); });
                                        const categoriesR = new Array(rightRows.length).fill(3);
                                        let countsR = {red:0, orange:0, blue:0, green:0};
                                        for (let i=0;i<rightRows.length;i++){
                                            const row = rightRows[i];
                                            const pn = String((row&&row['é›¶ä»¶å·'])??'').trim();
                                            const other = pn? leftByPN.get(pn): undefined;
                                            let cat = 3;
                                            if(!other){
                                                const spn = String((row&&row['ä¾›åº”å•†é›¶ä»¶å·'])??'').trim();
                                                cat = (spn && leftRedSupplierSet.has(spn)) ? 1 : 0;
                                            } else {
                                                const q1 = toNumber(row['æ•°é‡']);
                                                const q2 = toNumber(other['æ•°é‡']);
                                                cat = (q1===q2)?3:2;
                                            }
                                            categoriesR[i]=cat;
                                            if (cat===0) countsR.red++; else if(cat===1) countsR.orange++; else if(cat===2) countsR.blue++; else countsR.green++;
                                        }
                                        const wiresR = [];
                                        for(let i=0;i<rightRows.length;i++){
                                            const row = rightRows[i];
                                            const pn = String((row&&row['é›¶ä»¶å·'])??'').trim();
                                            const tp = String((row&&row['ç±»å‹'])??'').trim();
                                            if(!pn || !TYPE_SET.has(tp)) continue;
                                            const other = leftByPN.get(pn);
                                            const q1 = toNumber(row['æ•°é‡']);
                                            const q2 = other? toNumber(other['æ•°é‡']) : 0;
                                            wiresR.push({ pn, type: tp, q1, q2, diff: q1 - q2 });
                                        }
                                        self.postMessage({
                                            left: { name: left?.name, categories: categoriesL, counts: countsL, wires: wiresL },
                                            right: { name: right?.name, categories: categoriesR, counts: countsR, wires: wiresR }
                                        });
                                    };
                                `;
                                const blob = new Blob([workerCode], { type: 'application/javascript' });
                                compareWorker = new Worker(URL.createObjectURL(blob));
                                compareWorker.onmessage = (e) => {
                                    const res = e.data || {};
                                    if (res.left?.name) compareCache[res.left.name] = { categories: res.left.categories, counts: res.left.counts, wires: res.left.wires };
                                    if (res.right?.name) compareCache[res.right.name] = { categories: res.right.categories, counts: res.right.counts, wires: res.right.wires };
                                    compareBusy.value = false;
                                    compareMode.value = true;
                                };
                                // é¿å… worker å†…éƒ¨é”™è¯¯å¯¼è‡´ä¸€ç›´å¤„äºå¿™ç¢Œæ€
                                compareWorker.onerror = (err) => {
                                    console.error('Compare worker error:', err);
                                    compareBusy.value = false;
                                };
                                return compareWorker;
                            }
                            const sheetReady = ref(false);
                            const sjsReady = ref(false);
                            const faReady = ref(false);
                            // ç»Ÿä¸€çš„æç¤ºå¾½æ ‡ï¼ˆå„ä¸€ä¸ªï¼‰ï¼šåŠ è½½ä¸­ä¸ºè“è‰²ï¼ŒåŠ è½½å®Œæˆåˆ‡æ¢ä¸ºç»¿è‰²å¹¶æ·¡å‡º
                            const sheetBadge = reactive({ show: true, bgClass: 'bg-blue-600', text: 'ExcelJS åŠ è½½ä¸­...' });
                            const sjsBadge = reactive({ show: true, bgClass: 'bg-blue-600', text: 'SheetJS åŠ è½½ä¸­...' });
                            const faBadge = reactive({ show: true, bgClass: 'bg-blue-600', text: 'å›¾æ ‡åº“åŠ è½½ä¸­...' });                            // é¢œè‰²ç­›é€‰ï¼šæ¯ä¸ªæ–‡ä»¶æœ€å¤šé€‰ä¸€ç§é¢œè‰²åˆ†ç±»ï¼ˆå†æ¬¡ç‚¹å‡»æ¸…é™¤ï¼‰
                            const colorFilters = reactive({}); // { [fileName]: 'red'|'orange'|'blue'|'green' }

                            // åˆ‡æ¢æŸä¸ªæ–‡ä»¶çš„é¢œè‰²åˆ†ç±»ç­›é€‰ï¼ˆåŒä¸€æ–‡ä»¶ä»…å¯é€‰ä¸€ç§ï¼›å†æ¬¡ç‚¹å‡»å…³é—­ï¼‰
                            function toggleColorFilter(fileName, color) {
                                if (!compareMode.value || displayedSelectedFiles.value.length !== 2) return;
                                colorFilters[fileName] = (colorFilters[fileName] === color) ? undefined : color;
                            }
                            // æ ¹æ®æ˜¯å¦é€‰ä¸­è¿”å›è‰²å—æŒ‰é’®çš„æ ·å¼ç±»å
                            function badgeClass(fileName, color) {
                                const active = colorFilters[fileName] === color;
                                const base = 'text-[10px] px-1.5 py-0.5 rounded min-w-[1.75rem] text-center border transition';
                                const map = {
                                    red: active ? 'bg-red-600 text-white border-red-600' : 'bg-red-50 text-red-700 border-red-100',
                                    orange: active ? 'bg-orange-500 text-white border-orange-500' : 'bg-orange-50 text-orange-700 border-orange-100',
                                    blue: active ? 'bg-blue-600 text-white border-blue-600' : 'bg-blue-50 text-blue-700 border-blue-100',
                                    green: active ? 'bg-green-600 text-white border-green-600' : 'bg-green-50 text-green-700 border-green-100',
                                };
                                return base + ' ' + map[color];
                            }

                            // æ£€æµ‹ Font Awesome å­—ä½“åŠ è½½ï¼ˆä¼˜å…ˆæ£€æµ‹å­—ä½“ï¼Œè€ŒéCSSï¼‰
                            function detectFontAwesome() {
                                if (document.fonts && document.fonts.load) {
                                    const markReady = () => {
                                        if (!faReady.value) faReady.value = true;
                                        faBadge.bgClass = 'bg-green-600';
                                        faBadge.text = 'å›¾æ ‡åº“åŠ è½½å®Œæ¯•';
                                        setTimeout(() => { faBadge.show = false; }, 2000);
                                        console.log('Font Awesome å­—ä½“å·²åŠ è½½');
                                    };
                                    const poll = async () => {
                                        try {
                                            // å°è¯•æ£€æµ‹ solid 900 å­—é‡
                                            const r1 = await document.fonts.load('900 1em "Font Awesome 6 Free"');
                                            if (r1 && r1.length > 0) return markReady();
                                            // é€€åŒ–æ£€æµ‹å¸¸è§„æƒé‡
                                            const r2 = await document.fonts.load('400 1em "Font Awesome 6 Free"');
                                            if (r2 && r2.length > 0) return markReady();
                                            // å“ç‰Œå­—åº“ï¼ˆå¯é€‰ï¼‰
                                            const r3 = await document.fonts.load('400 1em "Font Awesome 6 Brands"');
                                            if (r3 && r3.length > 0) return markReady();
                                        } catch { }
                                        setTimeout(poll, 200);
                                    };
                                    poll();
                                } else {
                                    // åå¤‡ï¼šé€€å›åˆ°link onloadï¼ˆæå°‘æ•°æ—§æµè§ˆå™¨ï¼‰
                                    try {
                                        const links = Array.from(document.getElementsByTagName('link'));
                                        const faLink = links.find(l => (l.href || '').includes('font-awesome') || (l.href || '').includes('all.min.css'));
                                        if (faLink) {
                                            const fallbackMark = () => { if (!faReady.value) faReady.value = true; faBadge.bgClass = 'bg-green-600'; faBadge.text = 'å›¾æ ‡åº“åŠ è½½å®Œæ¯•'; setTimeout(() => { faBadge.show = false; }, 2000); };
                                            if (faLink.sheet) { fallbackMark(); }
                                            else { faLink.addEventListener('load', fallbackMark); }
                                        }
                                    } catch { }
                                }
                            }
                            detectFontAwesome();

                            // è½®è¯¢æ£€æµ‹ ExcelJS / SheetJS æ˜¯å¦å·²åŠ è½½
                            const checkTimer = setInterval(() => {
                                if (window && window.ExcelJS && !sheetReady.value) {
                                    sheetReady.value = true;
                                    sheetBadge.bgClass = 'bg-green-600';
                                    sheetBadge.text = 'ExcelJS åŠ è½½å®Œæ¯•';
                                    setTimeout(() => { sheetBadge.show = false; }, 2000);
                                    console.log('ExcelJS å·²åŠ è½½');
                                }
                                if (window && window.XLSX && !sjsReady.value) {
                                    sjsReady.value = true;
                                    sjsBadge.bgClass = 'bg-green-600';
                                    sjsBadge.text = 'SheetJS åŠ è½½å®Œæ¯•';
                                    setTimeout(() => { sjsBadge.show = false; }, 2000);
                                    console.log('SheetJS å·²åŠ è½½');
                                }
                                if (sheetReady.value && sjsReady.value) clearInterval(checkTimer);
                            }, 100);

                            // å›åˆ°é¡¶éƒ¨ï¼šæ˜¾ç¤º/éšè—é€»è¾‘ï¼ˆä¸ä¾èµ–å…·ä½“æ»šåŠ¨å®¹å™¨ï¼Œæ•è·ä»»ä½•æ»šåŠ¨ï¼‰
                            const showTop = ref(false);
                            const atTop = () => {
                                const y = window.scrollY || document.documentElement.scrollTop || document.body.scrollTop || 0;
                                if (y > 0) return false;
                                // æ£€æŸ¥å¸¸è§å¯æ»šå®¹å™¨æ˜¯å¦æ»šåŠ¨
                                const scrollers = document.querySelectorAll('[class*="overflow-"], [style*="overflow"], table, tbody');
                                for (const el of scrollers) {
                                    try {
                                        const cs = getComputedStyle(el);
                                        const oy = cs.overflowY || cs.overflow;
                                        if (/(auto|scroll)/.test(oy) && el.scrollHeight > el.clientHeight && el.scrollTop > 0) {
                                            return false;
                                        }
                                    } catch { }
                                }
                                return true;
                            };
                            const updateBackTop = () => { showTop.value = !atTop(); };
                            const forceShowBackTop = () => {
                                // ä¸å¼ºåˆ¶æ˜¾ç¤ºï¼Œå»¶åä¸€æ¬¡åˆ¤æ–­ï¼Œé¿å…åœ¨é¡¶ç«¯ä¸Šæ»šæ—¶è¯¯æ˜¾
                                if (typeof requestAnimationFrame === 'function') {
                                    requestAnimationFrame(updateBackTop);
                                } else {
                                    setTimeout(updateBackTop, 0);
                                }
                            };
                            // å›åˆ°é¡µé¢é¡¶éƒ¨ï¼ˆå¹³æ»‘æ»šåŠ¨ï¼‰
                            function scrollToTop() { window.scrollTo({ top: 0, behavior: 'smooth' }); }
                            onMounted(() => {
                                window.addEventListener('scroll', updateBackTop, { passive: true });
                                document.addEventListener('scroll', updateBackTop, { passive: true, capture: true });
                                document.addEventListener('wheel', forceShowBackTop, { passive: true });
                                document.addEventListener('touchmove', forceShowBackTop, { passive: true });
                                // ç‚¹å‡»å¤–éƒ¨å…³é—­ç­›é€‰é¢æ¿
                                const onDocClick = (e) => {
                                    const path = e.composedPath ? e.composedPath() : [];
                                    const isPanel = path.some(el => el && el.classList && el.classList.contains('filter-panel'));
                                    const isBtn = path.some(el => el && el.classList && el.classList.contains('filter-btn'));
                                    if (isPanel || isBtn) return;
                                    Object.keys(filterUI).forEach(fn => {
                                        const cols = filterUI[fn] || {};
                                        Object.keys(cols).forEach(cn => { cols[cn].open = false; });
                                    });
                                    openDropdownKey.value = '';
                                };
                                document.addEventListener('click', onDocClick, { capture: true });
                                // æ»šåŠ¨/ç¼©æ”¾æ—¶é‡ç®—æ‰“å¼€é¢æ¿ä½ç½®
                                const recompute = () => {
                                    const key = openDropdownKey.value;
                                    if (!key) return;
                                    const btn = document.querySelector(`.filter-btn[data-filter-key="${CSS.escape(key)}"]`);
                                    if (!btn) return;
                                    const rect = btn.getBoundingClientRect();
                                    dropdownPositions[key] = { top: rect.bottom + 4, left: rect.left };
                                };
                                window.addEventListener('resize', recompute, { passive: true });
                                window.addEventListener('scroll', recompute, { passive: true });
                                updateBackTop();
                                // å­˜åˆ°å®ä¾‹ä¸Šä»¥ä¾¿å¸è½½æ—¶ç§»é™¤
                                window.__bom_onDocClick = onDocClick;
                                window.__bom_recompute = recompute;
                            });
                            onUnmounted(() => {
                                window.removeEventListener('scroll', updateBackTop);
                                document.removeEventListener('scroll', updateBackTop, { capture: true });
                                document.removeEventListener('wheel', forceShowBackTop);
                                document.removeEventListener('touchmove', forceShowBackTop);
                                if (window.__bom_onDocClick) document.removeEventListener('click', window.__bom_onDocClick, { capture: true });
                                if (window.__bom_recompute) {
                                    window.removeEventListener('resize', window.__bom_recompute);
                                    window.removeEventListener('scroll', window.__bom_recompute);
                                }
                            });

                            // æ§åˆ¶é¢„è§ˆå®¹å™¨çš„æ˜¾ç¤º/éšè—ä¸å†…å®¹åˆ‡æ¢ - ä¼˜åŒ–ç‰ˆæœ¬ï¼š
                            // - å±•å¼€ï¼šå®¹å™¨å…ˆå±•å¼€ï¼Œå†…å®¹å»¶è¿Ÿæ·¡å…¥
                            // - æ”¶å›ï¼šå†…å®¹å…ˆæ·¡å‡ºä½†ä¿æŒåŠé€æ˜ï¼Œå®¹å™¨å†æ”¶å›
                            watch(selectedFiles, (newVal, oldVal) => {
                                const n = (newVal || []).length;
                                const o = (oldVal || []).length;

                                // è®¡ç®—é¢„è§ˆæ–‡ä»¶åˆ—è¡¨ï¼ˆæœ€å¤š2ä¸ªï¼Œéµå¾ªæŒ¤æ‰è§„åˆ™ï¼‰
                                let previewFiles = [];
                                if (n > 0) {
                                    if (n <= 2) {
                                        // 1-2ä¸ªæ–‡ä»¶ï¼šç›´æ¥é¢„è§ˆ
                                        previewFiles = [...newVal];
                                    } else {
                                        // è¶…è¿‡2ä¸ªæ–‡ä»¶ï¼šåªé¢„è§ˆæœ€å2ä¸ªï¼ˆæœ€æ–°é€‰æ‹©çš„2ä¸ªï¼‰
                                        previewFiles = newVal.slice(-2);
                                    }
                                }

                                if (previewFiles.length > 0 && !containerVisible.value) {
                                    // åˆæ¬¡æ˜¾ç¤ºï¼šç«‹å³æ¸²æŸ“å†…å®¹å¹¶å±•å¼€å¤–å±‚
                                    displayedSelectedFiles.value = [...previewFiles];
                                    containerVisible.value = true;
                                    return;
                                }
                                if (previewFiles.length === 0) {
                                    // æ— é¢„è§ˆï¼šç«‹å³æ¸…ç©ºé¢„è§ˆå†…å®¹ï¼Œè®©é¢„è§ˆåˆ—è¡¨åŠ¨ç”»ç”Ÿæ•ˆ
                                    compareMode.value = false;
                                    displayedSelectedFiles.value = []; // ç«‹å³æ¸…ç©ºï¼Œè§¦å‘é¢„è§ˆåˆ—è¡¨çš„é€€å‡ºåŠ¨ç”»
                                    if (containerVisible.value) {
                                        // å»¶è¿Ÿä¸€ç‚¹å†å…³é—­å®¹å™¨ï¼Œè®©é¢„è§ˆåˆ—è¡¨åŠ¨ç”»å…ˆå®Œæˆ
                                        setTimeout(() => {
                                            containerVisible.value = false;
                                        }, 100);
                                    }
                                    return;
                                }
                                // å…¶ä»–æƒ…å†µï¼šç›´æ¥æ›´æ–°é¢„è§ˆå†…å®¹
                                displayedSelectedFiles.value = [...previewFiles];
                            }, { deep: true });                            // é¢„è§ˆå®¹å™¨è¿‡æ¸¡ç¦»å¼€åæ¸…ç©ºå†…éƒ¨å†…å®¹ - ä¼˜åŒ–ç‰ˆæœ¬
                            function onPreviewContainerAfterLeave() {
                                // å¤–å±‚å®¹å™¨æ”¶å›å®Œæ¯•åæ¸…ç©ºå†…å®¹ï¼Œä¸ºä¸‹æ¬¡å±•å¼€åšå‡†å¤‡
                                if ((selectedFiles.value || []).length === 0) {
                                    displayedSelectedFiles.value = [];
                                }
                            }

                            // é¢„è§ˆå®¹å™¨è‡ªé€‚åº”é«˜åº¦è¿‡æ¸¡é’©å­å‡½æ•°
                            function onBeforeEnter(el) {
                                el.style.height = '0';
                                el.style.opacity = '0';
                            }

                            function onEnter(el, done) {
                                // å¼ºåˆ¶é‡ç»˜
                                el.offsetHeight;

                                // è·å–è‡ªç„¶é«˜åº¦
                                el.style.height = 'auto';
                                const height = el.offsetHeight;

                                // é‡ç½®ä¸º0å¼€å§‹åŠ¨ç”»
                                el.style.height = '0';

                                // ä¸‹ä¸€å¸§å¼€å§‹åŠ¨ç”»
                                requestAnimationFrame(() => {
                                    el.style.height = height + 'px';
                                    el.style.opacity = '1';

                                    // åŠ¨ç”»å®Œæˆåè°ƒç”¨done
                                    setTimeout(done, 600);
                                });
                            }

                            function onAfterEnter(el) {
                                // åŠ¨ç”»å®Œæˆåç§»é™¤å›ºå®šé«˜åº¦ï¼Œæ¢å¤è‡ªé€‚åº”
                                el.style.height = 'auto';
                            }

                            function onBeforeLeave(el) {
                                // è®°å½•å½“å‰é«˜åº¦
                                el.style.height = el.offsetHeight + 'px';
                                el.style.opacity = '1';
                            } function onLeave(el, done) {
                                // å¼ºåˆ¶é‡ç»˜
                                el.offsetHeight;

                                // ä¸‹ä¸€å¸§å¼€å§‹æ”¶èµ·åŠ¨ç”»
                                requestAnimationFrame(() => {
                                    el.style.height = '0';
                                    el.style.opacity = '0';

                                    // åŠ¨ç”»å®Œæˆåè°ƒç”¨done
                                    setTimeout(done, 600);
                                });
                            }

                            // è®¡ç®—å¡ç‰‡å®½åº¦ï¼šå•å¡ 100%ï¼ŒåŒå¡ç­‰åˆ†
                            function cardWidth(idx, fileName) {
                                const len = displayedSelectedFiles.value.length;
                                if (len === 1) return '100%';
                                // len >= 2 æ—¶ï¼Œç›´æ¥è¿”å›åŠå®½ï¼Œç¡®ä¿1â†’2å’Œ2â†’3æ—¶æ–°å¡ç‰‡å®½åº¦ä¸€è‡´
                                return 'calc((100% - 1.5rem) / 2)';
                            }

                            // è¿”å›å¡ç‰‡æ ·å¼ï¼ˆå®½åº¦ã€æŠ˜è¡Œæ§åˆ¶ç­‰ï¼‰
                            function cardStyle(idx, fileName) {
                                const w = cardWidth(idx, fileName);
                                return {
                                    width: w,
                                    flexBasis: w,
                                    flexShrink: 0,
                                    minWidth: 0,
                                    overflow: 'hidden'
                                };
                            }                            // æ–‡ä»¶è§£æä¸æ•°æ®è£…è½½å…¥å£
                            async function handleFiles(e) {
                                // å¯¼å…¥æµç¨‹æ€»è§ˆï¼ˆæ–°ç‰ˆè§„åˆ™ï¼‰ï¼š
                                // 1) ç”Ÿæˆå”¯ä¸€æ˜¾ç¤ºåï¼ˆå…è®¸é‡å¤å¯¼å…¥ï¼Œname, name (2), name (3)...ï¼‰
                                // 2) HTMLï¼šåœ¨æ¯ä¸ª <table> å†…å¯»æ‰¾â€œç¬¬ä¸€åˆ—ä¸º é›¶ä»¶å·/ä¾›åº”å•†é›¶ä»¶å·/å®¢æˆ·é›¶ä»¶å·â€çš„è¡Œä½œä¸ºè¡¨å¤´ï¼›
                                //    åˆ é™¤åç»­è¯¯å…¥çš„è¡¨å¤´è¡Œã€åŒ…å«åˆå¹¶å•å…ƒæ ¼çš„è¡Œï¼ˆcolspan/rowspan>1ï¼‰ã€ç¬¬ä¸€åˆ—ä»¥ Design å¼€å¤´çš„è¡Œï¼›æŒ‰è¡¨å¤´å¯¹é½å¡«å……æ•°æ®ã€‚
                                // 3) Excelï¼šè¯»å–å®Œæ•´ç½‘æ ¼å¹¶è¯†åˆ«åˆå¹¶åŒºåŸŸï¼›åŒæ ·æŒ‰â€œç¬¬ä¸€åˆ—ä»¤ç‰Œâ€è¯†åˆ«è¡¨å¤´å¹¶åˆ é™¤è¯¯å…¥è¡¨å¤´/åˆå¹¶/Design è¡Œï¼›
                                //    è‹¥æ‰¾ä¸åˆ°è¡¨å¤´åˆ™å›é€€åˆ°â€œåˆ—1..åˆ—Nâ€çš„ä¸´æ—¶åˆ—åç­–ç•¥ï¼Œå°½é‡ä¿è¯å¯ç”¨ã€‚
                                // 4) PN å¡«å……ï¼šè‹¥â€œé›¶ä»¶å·â€ä¸ºç©ºä¸”â€œä¾›åº”å•†é›¶ä»¶å·â€ä¹Ÿä¸ºç©ºï¼Œåˆ™ä¸¢å¼ƒè¯¥è¡Œï¼›è‹¥â€œé›¶ä»¶å·â€ä¸ºç©ºä½†â€œä¾›åº”å•†é›¶ä»¶å·â€æœ‰å€¼ï¼Œåˆ™å°†â€œé›¶ä»¶å·â€å¡«ä¸ºã€ä¾›åº”å•†é›¶ä»¶å·ã€‘ã€‚
                                // 5) è§„èŒƒåŒ–ä¸èšåˆï¼šå¯¹å¯¼çº¿/WIRE/çº¿æŸä¸‰æ®µå·è§„èŒƒä¸ºå‰ä¸¤æ®µï¼›æŒ‰â€œé›¶ä»¶å·â€èšåˆå¹¶æ±‡æ€»â€œæ•°é‡â€ã€‚
                                // 6) æ’åºï¼šæŒ‰â€œé›¶ä»¶å·â€è‡ªç„¶å‡åºï¼ˆæ•°å­—å‹å¥½ã€å¿½ç•¥ä¸­è‹±æ–‡å¤§å°å†™å·®å¼‚ï¼‰ã€‚
                                const files = Array.from(e.target.files || []);
                                if (!files.length) return;
                                // æŒ‰éœ€æ ¡éªŒä¾èµ–ï¼šå«Exceléœ€ExcelJSï¼Œå«HTMLéœ€SheetJS
                                const needExcel = files.some(f => !/\.html?$/i.test(f.name));
                                const needSheet = files.some(f => /\.html?$/i.test(f.name));
                                if (needExcel && !window.ExcelJS) { alert('ExcelJS è¿˜åœ¨åŠ è½½ä¸­ï¼Œè¯·ç¨åå†è¯•'); return; }
                                if (needSheet && !window.XLSX) { alert('SheetJS è¿˜åœ¨åŠ è½½ä¸­ï¼Œè¯·ç¨åå†è¯•'); return; }
                                loading.value = true;
                                await Promise.all(files.map(file => new Promise(resolve => {
                                    // ä¸å†è·³è¿‡åŒåæ–‡ä»¶ï¼šç”Ÿæˆä¸€ä¸ªå”¯ä¸€å¯æ˜¾ç¤ºåç§°ï¼ˆname, name (2), name (3)...ï¼‰
                                    const displayName = generateUniqueFileName(file.name);
                                    const table = { name: displayName, columns: [], data: [], status: 'pending', errorMsg: '' };
                                    tables.push(table);
                                    fileList.push({ name: displayName, rows: 0, status: 'pending', errorMsg: '' });
                                    const reader = new FileReader();
                                    reader.onload = async (evt) => {
                                        try {
                                            let rows = [];
                                            let columns = [];
                                            if (file.name.endsWith('.html') || file.name.endsWith('.htm')) {
                                                const html = evt.target.result;
                                                const parsed = parseHTMLWithSheetJS(html);
                                                rows = parsed.rows;
                                                columns = parsed.columns;
                                            } else {
                                                const lower = file.name.toLowerCase();
                                                if (lower.endsWith('.xls')) {
                                                    throw new Error('æš‚ä¸æ”¯æŒ .xlsï¼ˆè¯·å¦å­˜ä¸º .xlsx åå¯¼å…¥ï¼‰');
                                                }
                                                const parsed = await parseExcelFile(evt.target.result, file.name);
                                                rows = parsed.rows;
                                                columns = parsed.columns;
                                            }
                                            // ä¸¥æ ¼å¤ç”¨ XLSX çš„ç»Ÿä¸€æ¸…æ´—ç®¡é“
                                            const cleaned = processRawData(rows, columns);
                                            table.columns = cleaned.columns;
                                            table.data = cleaned.rows;
                                            table.status = 'success';
                                            table.errorMsg = '';
                                            const f = fileList.find(f => f.name === displayName);
                                            f.rows = table.data.length;
                                            f.status = 'success';
                                            f.errorMsg = '';
                                            // æ•°æ®å˜æ›´ï¼šå¤±æ•ˆç¼“å­˜ & bump ç‰ˆæœ¬
                                            dataEpoch.value++;
                                            delete compareCache[displayName];
                                        } catch (err) {
                                            // æ ¹æ®é”™è¯¯ç±»å‹æä¾›å…·ä½“çš„é”™è¯¯ä¿¡æ¯
                                            let errorMessage = '';
                                            const originalError = err && err.message ? err.message : err;

                                            if (typeof originalError === 'string') {
                                                if (originalError.includes('Excelè§£æå¤±è´¥')) {
                                                    errorMessage = `Excelæ–‡ä»¶æ ¼å¼é”™è¯¯: ${originalError.replace('Excelè§£æå¤±è´¥: ', '')}`;
                                                } else if (originalError.includes('é›¶ä»¶å·æ•°æ®æ¸…ç†å¤±è´¥')) {
                                                    errorMessage = `æ•°æ®æ¸…æ´—é˜¶æ®µ - ${originalError}`;
                                                } else if (originalError.includes('å¯¼çº¿ç±»å‹å¤„ç†æˆ–æ•°æ®èšåˆå¤±è´¥')) {
                                                    errorMessage = `æ•°æ®å¤„ç†é˜¶æ®µ - ${originalError}`;
                                                } else if (originalError.includes('æ•°æ®æ’åºå¤±è´¥')) {
                                                    errorMessage = `æ•°æ®æ•´ç†é˜¶æ®µ - ${originalError}`;
                                                } else if (originalError.includes('æš‚ä¸æ”¯æŒ')) {
                                                    errorMessage = `æ–‡ä»¶æ ¼å¼ä¸æ”¯æŒ: ${originalError}`;
                                                } else if (originalError.includes('Excelæ–‡ä»¶æ— æœ‰æ•ˆSheet')) {
                                                    errorMessage = `Excelæ–‡ä»¶ç»“æ„é”™è¯¯: æ–‡ä»¶ä¸­æ²¡æœ‰æœ‰æ•ˆçš„å·¥ä½œè¡¨`;
                                                } else if (originalError.includes('Excelä¸ºç©º')) {
                                                    errorMessage = `Excelæ–‡ä»¶å†…å®¹é”™è¯¯: å·¥ä½œè¡¨ä¸ºç©ºæˆ–æ²¡æœ‰æ•°æ®`;
                                                } else {
                                                    errorMessage = `æ–‡ä»¶è§£æå¤±è´¥: ${originalError}`;
                                                }
                                            } else {
                                                errorMessage = `æ–‡ä»¶è§£æè¿‡ç¨‹ä¸­å‡ºç°æœªçŸ¥é”™è¯¯`;
                                            }

                                            table.status = 'error';
                                            table.errorMsg = errorMessage;
                                            table.columns = [];
                                            table.data = [];
                                            const f = fileList.find(f => f.name === displayName);
                                            if (f) {
                                                f.rows = 0;
                                                f.status = 'error';
                                                f.errorMsg = errorMessage;
                                            }
                                            console.error('æ–‡ä»¶è§£æå¼‚å¸¸:', file.name, 'é”™è¯¯è¯¦æƒ…:', err);
                                        }
                                        resolve();
                                    };
                                    if (file.name.endsWith('.html') || file.name.endsWith('.htm')) {
                                        reader.readAsText(file);
                                    } else {
                                        reader.readAsArrayBuffer(file);
                                    }
                                })));
                                loading.value = false;
                            }

                            // åˆ é™¤æ–‡ä»¶
                            // ä»åˆ—è¡¨ä¸é€‰ä¸­é›†åˆä¸­ç§»é™¤æ–‡ä»¶
                            function removeFile(idx) {
                                if (idx < 0 || idx >= fileList.length) return;
                                const name = fileList[idx].name;
                                const tIdx = tables.findIndex(t => t.name === name);
                                if (tIdx !== -1) tables.splice(tIdx, 1);
                                fileList.splice(idx, 1);
                                const selIdx = selectedFiles.value.indexOf(name);
                                if (selIdx !== -1) selectedFiles.value.splice(selIdx, 1);
                                // æ•°æ®å˜æ›´ï¼šå¤±æ•ˆç¼“å­˜ & bump ç‰ˆæœ¬
                                dataEpoch.value++;
                                delete compareCache[name];
                            }

                            //ï¼ˆå·²ç§»é™¤ï¼‰ç‚¹å‡»æ–‡ä»¶æ¡ç›®åˆ‡æ¢é¢„è§ˆåŠŸèƒ½ç”± onFileCheckboxChange ç»Ÿä¸€å¤„ç†

                            // æ–‡ä»¶é€‰æ‹©é€»è¾‘ - åˆ†ç¦»é€‰æ‹©å’Œé¢„è§ˆï¼š
                            // 1. æ–‡ä»¶é€‰æ‹©ï¼šå¤šé€‰æ¨¡å¼ä¸‹æ— é™åˆ¶ï¼Œæ™®é€šæ¨¡å¼ä¸‹æœ€å¤š2ä¸ª
                            // 2. æ–‡ä»¶é¢„è§ˆï¼šæ— è®ºå“ªç§æ¨¡å¼ï¼Œé¢„è§ˆåŒºæœ€å¤šæ˜¾ç¤º2ä¸ªæ–‡ä»¶ï¼Œéµå¾ªæŒ¤æ‰è§„åˆ™
                            function onFileCheckboxChange(name, checked, status) {
                                if (status === 'error') return;
                                const i = selectedFiles.value.indexOf(name);

                                if (checked) {
                                    if (i === -1) {
                                        // æ–‡ä»¶é€‰æ‹©é€»è¾‘
                                        if (multiCompareMode.value) {
                                            // å¤šé€‰æ¨¡å¼ï¼šå¯ä»¥é€‰æ‹©æ— é™ä¸ªæ–‡ä»¶
                                            selectedFiles.value.push(name);
                                        } else {
                                            // æ™®é€šæ¨¡å¼ï¼šæœ€å¤šé€‰æ‹©2ä¸ªæ–‡ä»¶
                                            if (selectedFiles.value.length >= 2) {
                                                selectedFiles.value.shift(); // ç§»é™¤æœ€æ—©é€‰æ‹©çš„æ–‡ä»¶
                                            }
                                            selectedFiles.value.push(name);
                                        }
                                    }
                                } else {
                                    // å–æ¶ˆé€‰æ‹©
                                    if (i >= 0) selectedFiles.value.splice(i, 1);
                                }
                            }
                            // å¤šæ–‡ä»¶å¯¹æ¯”æ¨¡å¼å¼€å…³ - æ”¹è¿›ç‰ˆæœ¬ï¼š
                            // - è¿›å…¥æ—¶ï¼šä¿æŒå·²é€‰æ‹©çš„æ–‡ä»¶å’Œé¢„è§ˆçŠ¶æ€
                            // - é€€å‡ºæ—¶ï¼šä¿æŒå·²é€‰æ‹©çš„æ–‡ä»¶å’Œé¢„è§ˆçŠ¶æ€ï¼Œå¹¶æ¸…ç©ºæ‰€æœ‰é€‰ä¸­æ–‡ä»¶
                            function toggleMultiCompare() {
                                multiCompareMode.value = !multiCompareMode.value;
                                if (multiCompareMode.value) {
                                    // è¿›å…¥å¤šé€‰æ¨¡å¼ï¼šä¿æŒé¢„è§ˆçŠ¶æ€å’Œå·²é€‰æ‹©çš„æ–‡ä»¶
                                    compareMode.value = false;
                                    // ä¸å…³é—­é¢„è§ˆå®¹å™¨ï¼Œä¸æ¸…ç©ºå·²é€‰æ‹©æ–‡ä»¶
                                } else {
                                    // é€€å‡ºå¤šé€‰æ¨¡å¼ï¼ˆç‚¹å‡»"å–æ¶ˆå¤šé€‰"ï¼‰ï¼šæ¸…ç©ºæ‰€æœ‰å·²é€‰æ‹©çš„æ–‡ä»¶
                                    selectedFiles.value = [];
                                    containerVisible.value = false;
                                    compareMode.value = false;
                                }
                            }

                            // å¤šé€‰æ¨¡å¼ä¸‹ä¸€é”®å…¨é€‰ï¼ˆè¿‡æ»¤è§£æå¤±è´¥çš„é¡¹ï¼‰
                            function selectAllFiles() {
                                if (!multiCompareMode.value) return;
                                const all = fileList.filter(f => f.status !== 'error').map(f => f.name);
                                selectedFiles.value.splice(0, selectedFiles.value.length, ...all);
                            }

                            // è·å–è¡¨æ ¼
                            // æ ¹æ®æ˜¾ç¤ºåè·å–è¡¨å¯¹è±¡ï¼ˆcolumnsã€data ç­‰ï¼‰
                            function getTable(name) {
                                const t = tables.find(t => t.name === name);
                                if (!t || !t.columns || !t.data) {
                                    return { columns: [], data: [], status: 'error', errorMsg: 'æœªæ‰¾åˆ°' };
                                }
                                return t;
                            }

                            const filterUI = reactive({}); // ä¸‹æ‹‰å¼€å…³ä¸ä¸´æ—¶æœç´¢/é€‰æ‹©
                            const activeFilters = reactive({}); // ç”Ÿæ•ˆçš„æŒ‰åˆ—ç­›é€‰: { [fileName]: { [col]: Set(values) } }
                            // Teleport ç­›é€‰é¢æ¿å®šä½ï¼ˆfixed åˆ°è§†å£ï¼‰ï¼Œkey ç”± fileName__col ç»„æˆ
                            const dropdownPositions = reactive({}); // { [key]: { top, left } }
                            const openDropdownKey = ref('');

                            // è·å–ç­›é€‰é¢æ¿çš„ä¸´æ—¶çŠ¶æ€å¯¹è±¡ï¼ˆä¸å­˜åœ¨åˆ™åˆå§‹åŒ–ï¼‰
                            function keyOf(fileName, col) {
                                if (!filterUI[fileName]) filterUI[fileName] = {};
                                if (!filterUI[fileName][col]) filterUI[fileName][col] = { open: false, search: '', temp: new Set() };
                                return filterUI[fileName][col];
                            }

                            // æ‰“å¼€/å…³é—­åˆ—ç­›é€‰ä¸‹æ‹‰é¢æ¿ï¼Œå¹¶è®¡ç®—å®šä½
                            function toggleFilterDropdown(fileName, col, evt) {
                                const k = keyOf(fileName, col);
                                k.open = !k.open;
                                // åˆå§‹åŒ–ä¸´æ—¶é›†åˆä¸ºå½“å‰å·²é€‰å€¼
                                const selected = activeFilters[fileName] && activeFilters[fileName][col] ? activeFilters[fileName][col] : new Set();
                                k.temp = new Set(Array.from(selected));
                                // è®°å½•æ‰“å¼€çš„é¢æ¿ä½ç½®ï¼ˆæŒ‰é’®çš„å¯è§†åŒºåŸŸ rectï¼‰
                                const key = `${fileName}__${col}`;
                                if (k.open && evt && evt.currentTarget) {
                                    const rect = evt.currentTarget.getBoundingClientRect();
                                    dropdownPositions[key] = { top: rect.bottom + 4, left: rect.left };
                                    openDropdownKey.value = key;
                                } else if (!k.open && openDropdownKey.value === key) {
                                    openDropdownKey.value = '';
                                }
                            }
                            // å…³é—­åˆ—ç­›é€‰é¢æ¿
                            function closeDropdown(fileName, col) {
                                const k = keyOf(fileName, col);
                                k.open = false;
                                if (openDropdownKey.value === `${fileName}__${col}`) openDropdownKey.value = '';
                            }
                            // åˆ¤æ–­åˆ—ç­›é€‰é¢æ¿æ˜¯å¦æ‰“å¼€
                            function isDropdownOpen(fileName, col) { return !!(filterUI[fileName] && filterUI[fileName][col] && filterUI[fileName][col].open); }

                            // è·å–åˆ—ç­›é€‰çš„ä¸´æ—¶çŠ¶æ€ï¼ˆå«æœç´¢ä¸ä¸´æ—¶å‹¾é€‰ï¼‰
                            function getFilterState(fileName, col) { return keyOf(fileName, col); }

                            // è®¡ç®—ä¸‹æ‹‰ç­›é€‰é¢æ¿çš„ fixed å®šä½æ ·å¼
                            function dropdownStyle(fileName, col) {
                                const key = `${fileName}__${col}`;
                                const pos = dropdownPositions[key] || { top: 0, left: 0 };
                                const panelWidth = 256; // w-64
                                const panelHeight = 320; // ä¼°ç®—é«˜åº¦ï¼Œå†…éƒ¨æ»šåŠ¨
                                let top = pos.top;
                                let left = pos.left;
                                const vw = window.innerWidth || document.documentElement.clientWidth;
                                const vh = window.innerHeight || document.documentElement.clientHeight;
                                if (left + panelWidth > vw - 8) left = Math.max(8, vw - panelWidth - 8);
                                if (top + panelHeight > vh - 8) top = Math.max(8, vh - panelHeight - 8);
                                return `top:${top}px;left:${left}px;`;
                            }

                            // æ”¶é›†æŒ‡å®šåˆ—çš„å»é‡å€¼åˆ—è¡¨ï¼ˆåŸºäºå½“å‰è¡¨æ•°æ®ï¼Œä¸å—åˆ—ç­›é€‰å½±å“ï¼‰
                            function collectDistinctValues(fileName, col) {
                                const table = getTable(fileName);
                                const set = new Set();
                                (table.data || []).forEach(r => set.add(String((r && r[col]) ?? '')));
                                return Array.from(set);
                            }

                            // åœ¨å»é‡å€¼åŸºç¡€ä¸Šåº”ç”¨æœç´¢è¿‡æ»¤å¹¶æ’åºï¼ˆä¾›ä¸‹æ‹‰é¢æ¿æ˜¾ç¤ºï¼‰
                            function filteredDistinctValues(fileName, col) {
                                const state = getFilterState(fileName, col);
                                const search = (state.search || '').toLowerCase();
                                const collator = new Intl.Collator('zh-CN', { numeric: true, sensitivity: 'base' });
                                return collectDistinctValues(fileName, col)
                                    .filter(v => v.toLowerCase().includes(search))
                                    .sort((a, b) => collator.compare(a, b));
                            }

                            // åˆ¤æ–­å€¼æ˜¯å¦åœ¨ä¸´æ—¶å‹¾é€‰é›†åˆä¸­
                            function isValueChecked(fileName, col, val) { return getFilterState(fileName, col).temp.has(String(val ?? '')); }
                            // åˆ‡æ¢ä¸‹æ‹‰é¡¹çš„ä¸´æ—¶å‹¾é€‰çŠ¶æ€
                            function onToggleValue(fileName, col, val, checked) {
                                const state = getFilterState(fileName, col);
                                const key = String(val ?? '');
                                if (checked) state.temp.add(key); else state.temp.delete(key);
                            }
                            // å‹¾é€‰å½“å‰åˆ—çš„å…¨éƒ¨å¯é€‰å€¼
                            function selectAllValues(fileName, col) {
                                const state = getFilterState(fileName, col);
                                state.temp = new Set(collectDistinctValues(fileName, col).map(v => String(v ?? '')));
                            }
                            // æ¸…é™¤å½“å‰åˆ—çš„å…¨éƒ¨å‹¾é€‰å€¼
                            function clearAllValues(fileName, col) { getFilterState(fileName, col).temp = new Set(); }

                            // åº”ç”¨åˆ—ç­›é€‰ï¼ˆå°†ä¸´æ—¶å‹¾é€‰å†™å…¥æ­£å¼ç­›é€‰é›†åˆï¼‰
                            function applyFilter(fileName, col) {
                                if (!activeFilters[fileName]) activeFilters[fileName] = {};
                                activeFilters[fileName][col] = new Set(Array.from(getFilterState(fileName, col).temp));
                                closeDropdown(fileName, col);
                            }

                            // åˆ¤æ–­æŸåˆ—æ˜¯å¦å­˜åœ¨æœ‰æ•ˆçš„ç­›é€‰æ¡ä»¶
                            function isColumnFiltered(fileName, col) {
                                return !!(activeFilters[fileName] && activeFilters[fileName][col] && activeFilters[fileName][col].size > 0);
                            }

                            // æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä»»æ„åˆ—ç­›é€‰
                            function hasActiveFilters(fileName) {
                                const f = activeFilters[fileName] || {};
                                return Object.values(f).some(set => set && set.size > 0);
                            }

                            // ä»…åº”ç”¨åˆ—å€¼ç­›é€‰ï¼ˆä¸åº”ç”¨é¢œè‰²ç­›é€‰ï¼‰ï¼Œç”¨äºè®¡æ•°ç­‰
                            function baseFilteredRows(fileName) {
                                const table = getTable(fileName);
                                const rows = table.data || [];
                                const filters = activeFilters[fileName] || {};
                                const cols = table.columns || [];
                                const hasAny = Object.values(filters).some(set => set && set.size > 0);
                                return hasAny ? rows.filter(r => cols.every(col => {
                                    const set = filters[col];
                                    if (!set || set.size === 0) return true;
                                    const key = String((r && r[col]) ?? '');
                                    return set.has(key);
                                })) : rows;
                            }

                            // ç»¼åˆåˆ—ç­›é€‰ä¸é¢œè‰²åˆ†ç±»ç­›é€‰ï¼Œè¿”å›æœ€ç»ˆç”¨äºæ¸²æŸ“çš„è¡Œ
                            function filteredRows(fileName) {
                                const table = getTable(fileName);
                                const cols = table.columns || [];
                                let result = baseFilteredRows(fileName);
                                // é¢œè‰²åˆ†ç±»ç­›é€‰ï¼ˆä»…åœ¨å¯¹æ¯”æ¨¡å¼ä¸”é€‰äº†ä¸¤è¡¨æ—¶ç”Ÿæ•ˆï¼‰
                                if (compareMode.value && displayedSelectedFiles.value.length === 2 && colorFilters[fileName]) {
                                    const want = COLOR_TO_PRIORITY[colorFilters[fileName]];
                                    result = result.filter(r => categoryPriority(fileName, r) === want);
                                }
                                // å¯¹æ¯”æ¨¡å¼ä¸‹ï¼ŒæŒ‰åº•è‰²ä¼˜å…ˆçº§æ’åºï¼šçº¢(0) æ©™(1) è“(2) ç»¿(3)
                                if (compareMode.value && displayedSelectedFiles.value.length === 2 && cols.includes('é›¶ä»¶å·')) {
                                    const collator = new Intl.Collator('zh-CN', { numeric: true, sensitivity: 'base' });
                                    result = [...result].sort((a, b) => {
                                        const pa = categoryPriority(fileName, a);
                                        const pb = categoryPriority(fileName, b);
                                        if (pa !== pb) return pa - pb;
                                        const as = String((a && a['é›¶ä»¶å·']) ?? '').trim();
                                        const bs = String((b && b['é›¶ä»¶å·']) ?? '').trim();
                                        return collator.compare(as, bs);
                                    });
                                }
                                return result;
                            }

                            // å¼€å…³å¯¹æ¯”æ¨¡å¼ï¼›å¼€å¯æ—¶çŸ­æš‚è¿›å…¥å¿™ç¢Œæ€
                            async function toggleCompare() {
                                if (compareMode.value) { compareMode.value = false; return; }
                                if (compareBusy.value) return;
                                if (displayedSelectedFiles.value.length !== 2) return;
                                const [f1, f2] = displayedSelectedFiles.value;
                                const t1 = getTable(f1); const t2 = getTable(f2);
                                if (!t1?.data?.length && !t2?.data?.length) { compareMode.value = true; return; }
                                // æ„å»ºåŸå§‹ç´¢å¼•æ˜ å°„ï¼ˆç”¨äºæŠŠ worker åˆ†ç±»ç»“æœæŒ‰è¡Œå¯¹è±¡æ‰¾å›ï¼‰
                                const makeIndexMap = (name, data) => {
                                    const map = new WeakMap();
                                    data.forEach((row, idx) => map.set(row, idx));
                                    originalIndexMaps.set(name, map);
                                };
                                makeIndexMap(f1, t1.data || []);
                                makeIndexMap(f2, t2.data || []);
                                // å°†å“åº”å¼è¡Œå¯¹è±¡è½¬æ¢ä¸ºå¯å…‹éš†çš„æ™®é€šå¯¹è±¡ï¼Œé¿å… postMessage DataCloneError
                                const toPlainRows = (rows) => (Array.isArray(rows) ? rows : []).map(r => Object.fromEntries(Object.entries(r)));
                                const leftPayload = { name: f1, rows: toPlainRows(t1.data) };
                                const rightPayload = { name: f2, rows: toPlainRows(t2.data) };
                                compareBusy.value = true;
                                const worker = ensureCompareWorker();
                                try {
                                    worker.postMessage({ left: leftPayload, right: rightPayload });
                                } catch (err) {
                                    console.error('postMessage failed:', err);
                                    compareBusy.value = false;
                                    // ä¿æŒ compareMode å…³é—­çŠ¶æ€
                                }
                            }

                            // è·å–ä¸å½“å‰æ–‡ä»¶æˆå¯¹çš„å¦ä¸€ä¸ªæ–‡ä»¶åï¼ˆä»…åœ¨é¢„è§ˆäº†ä¸¤ä¸ªæ–‡ä»¶æ—¶æœ‰æ•ˆï¼‰
                            function getOtherFileName(current) {
                                if (displayedSelectedFiles.value.length !== 2) return null;
                                return displayedSelectedFiles.value[0] === current ? displayedSelectedFiles.value[1] : displayedSelectedFiles.value[0];
                            }

                            // å°†æ•°é‡å­—æ®µè½¬æ¢ä¸ºæ•°å­—ï¼ˆå…¼å®¹åƒä½åˆ†éš”é€—å·ï¼Œç©ºå€¼ä¸º 0ï¼‰
                            function toNumber(v) {
                                if (v == null || v === '') return 0;
                                const n = parseFloat(String(v).replace(/,/g, ''));
                                return isNaN(n) ? 0 : n;
                            }

                            // ä¸ºå¯¹è¡¨æ„å»ºæŒ‰â€œé›¶ä»¶å·/ä¾›åº”å•†é›¶ä»¶å·â€çš„å¿«é€Ÿç´¢å¼•
                            function buildIndexes(otherName) {
                                const other = getTable(otherName);
                                const byPN = new Map();
                                const bySupplier = new Map();
                                if (other && Array.isArray(other.data)) {
                                    other.data.forEach(r => {
                                        const pn = String((r && r['é›¶ä»¶å·']) ?? '').trim();
                                        const spn = String((r && r['ä¾›åº”å•†é›¶ä»¶å·']) ?? '').trim();
                                        if (pn) byPN.set(pn, r);
                                        if (spn) bySupplier.set(spn, r);
                                    });
                                }
                                return { byPN, bySupplier };
                            }

                            // æ„å»ºâ€œäº¤å‰ç´¢å¼•â€ï¼šç”¨äºæŒ‰ä½ çš„å®šä¹‰è®¡ç®—â€œæ©™è‰²â€ï¼ˆåŒæ–¹å‡ä¸ºçº¢çš„ä¾›åº”å•†é›¶ä»¶å·äº¤é›†ï¼‰
                            // æ„å»ºäº¤å‰ç´¢å¼•ï¼šç”¨äºåˆ¤æ–­æ©™è‰²ï¼ˆæœ¬è¡¨çº¢ã€ä¸”ä¾›åº”å•†å·è½åœ¨å¯¹è¡¨çº¢é›†åˆå†…ï¼‰ä¸è“ç»¿
                            function buildCrossIndex(currentName) {
                                const otherName = getOtherFileName(currentName);
                                const current = getTable(currentName);
                                const other = getTable(otherName);
                                const currentPNSet = new Set();
                                const otherByPN = new Map();
                                const otherRedSupplierSet = new Set();
                                if (current && Array.isArray(current.data)) {
                                    current.data.forEach(r => {
                                        const pn = String((r && r['é›¶ä»¶å·']) ?? '').trim();
                                        if (pn) currentPNSet.add(pn);
                                    });
                                }
                                if (other && Array.isArray(other.data)) {
                                    other.data.forEach(r => {
                                        const pn = String((r && r['é›¶ä»¶å·']) ?? '').trim();
                                        if (pn) otherByPN.set(pn, r);
                                    });
                                    // å¦ä¸€å¼ è¡¨çš„â€œçº¢è‰²â€é›†åˆï¼ˆç›¸å¯¹äºå½“å‰è¡¨ï¼‰ï¼šPN ä¸åœ¨å½“å‰è¡¨ä¸­
                                    other.data.forEach(r => {
                                        const pn = String((r && r['é›¶ä»¶å·']) ?? '').trim();
                                        const spn = String((r && r['ä¾›åº”å•†é›¶ä»¶å·']) ?? '').trim();
                                        if (!pn || !spn) return;
                                        if (!currentPNSet.has(pn)) {
                                            otherRedSupplierSet.add(spn);
                                        }
                                    });
                                }
                                return { otherByPN, otherRedSupplierSet };
                            }

                            // è®¡ç®—ä¸€è¡Œçš„å¯¹æ¯”åˆ†ç±»ä¼˜å…ˆçº§ï¼šçº¢(0)/æ©™(1)/è“(2)/ç»¿(3)
                            function categoryPriority(fileName, row) {
                                if (!compareMode.value) return 3; // é»˜è®¤å½“ä½œç»¿è‰²
                                const otherName = getOtherFileName(fileName);
                                if (!otherName) return 3;
                                const pn = String((row && row['é›¶ä»¶å·']) ?? '').trim();
                                const { otherByPN, otherRedSupplierSet } = buildCrossIndex(fileName);
                                const otherRow = pn ? otherByPN.get(pn) : undefined;
                                if (!otherRow) {
                                    // æœ¬è¡¨çº¢ï¼šè‹¥ä¾›åº”å•†é›¶ä»¶å·è½åœ¨å¯¹è¡¨çº¢é›†åˆå†…ï¼Œåˆ™æ©™ï¼Œå¦åˆ™çº¢
                                    const spn = String((row && row['ä¾›åº”å•†é›¶ä»¶å·']) ?? '').trim();
                                    if (spn && otherRedSupplierSet.has(spn)) return 1; // æ©™
                                    return 0; // çº¢
                                }
                                // PN å‘½ä¸­ï¼šæ¯”è¾ƒæ•°é‡
                                const q1 = toNumber(row['æ•°é‡']);
                                const q2 = toNumber(otherRow['æ•°é‡']);
                                if (q1 === q2) return 3; // ç»¿
                                return 2; // è“
                            }

                            // æ ¹æ®åˆ†ç±»ä¼˜å…ˆçº§è¿”å›è¡¨æ ¼è¡Œçš„èƒŒæ™¯è‰² class
                            function rowBgClass(fileName, row) {
                                // ä½¿ç”¨ worker ç»“æœä¼˜å…ˆï¼ˆé¿å…åœ¨æ¸²æŸ“æ—¶é‡å¤è®¡ç®—ï¼‰
                                const cache = compareCache[fileName];
                                let p;
                                if (cache && Array.isArray(cache.categories)) {
                                    const idxMap = originalIndexMaps.get(fileName);
                                    const idx = idxMap ? idxMap.get(row) : undefined;
                                    p = (typeof idx === 'number') ? cache.categories[idx] : undefined;
                                }
                                if (p == null) p = categoryPriority(fileName, row);
                                switch (p) {
                                    case 0: return 'bg-red-50';
                                    case 1: return 'bg-orange-50';
                                    case 2: return 'bg-blue-50';
                                    case 3: return 'bg-green-50';
                                    default: return '';
                                }
                            }

                            // ç»Ÿè®¡å½“å‰æ–‡ä»¶åœ¨å››ç§åˆ†ç±»ä¸‹çš„è¡Œæ•°ï¼ˆåŸºäºåŸºç¡€åˆ—ç­›é€‰ï¼Œä¸å«é¢œè‰²ç­›é€‰ï¼‰
                            function categoryCounts(fileName) {
                                // ä¼˜å…ˆä½¿ç”¨ worker ç»Ÿè®¡ç»“æœ
                                const cache = compareCache[fileName];
                                if (cache && cache.counts) return cache.counts;
                                // å›é€€åˆ°åŒæ­¥è®¡ç®—
                                const counts = { red: 0, orange: 0, blue: 0, green: 0 };
                                const table = getTable(fileName);
                                if (!compareMode.value || displayedSelectedFiles.value.length !== 2 || !(table.columns || []).includes('é›¶ä»¶å·')) return counts;
                                const { otherByPN, otherRedSupplierSet } = buildCrossIndex(fileName);
                                const rows = baseFilteredRows(fileName) || [];
                                rows.forEach(row => {
                                    const pn = String((row && row['é›¶ä»¶å·']) ?? '').trim();
                                    const otherRow = pn ? otherByPN.get(pn) : undefined;
                                    if (!otherRow) {
                                        const spn = String((row && row['ä¾›åº”å•†é›¶ä»¶å·']) ?? '').trim();
                                        if (spn && otherRedSupplierSet.has(spn)) counts.orange++; else counts.red++;
                                    } else {
                                        const q1 = toNumber(row['æ•°é‡']);
                                        const q2 = toNumber(otherRow['æ•°é‡']);
                                        if (q1 === q2) counts.green++; else counts.blue++;
                                    }
                                });
                                return counts;
                            }

                            // è®¡ç®—â€œå¯¼çº¿æ•°é‡å·®å€¼â€åˆ—è¡¨ï¼ˆè“è‰²ç±»ä¸”ç±»å‹ä¸ºå¯¼çº¿/WIRE/çº¿æŸï¼‰ï¼Œè¿”å› [{ pn, type, q1, q2, diff }]
                            // è®¡ç®—å¯¼çº¿ç±»çš„æ•°é‡å·®å€¼åˆ—è¡¨ï¼ˆåŒ…å«æ‰€æœ‰å¯¼çº¿ç±»å‹ï¼Œå³è¡¨æœªæ‰¾åˆ°æ—¶æ•°é‡ä¸º0ï¼‰
                            function wiresDiff(fileName) {
                                // ä¼˜å…ˆä½¿ç”¨ worker ç»“æœï¼ˆå†åœ¨ UI ä¾§åº”ç”¨åˆ—ç­›é€‰ï¼‰
                                const cache = compareCache[fileName];
                                let list = cache && Array.isArray(cache.wires) ? cache.wires : null;
                                if (!list) {
                                    // åŒæ­¥å›é€€
                                    if (!compareMode.value || displayedSelectedFiles.value.length !== 2) return [];
                                    const table = getTable(fileName);
                                    if (!table || !(table.columns || []).includes('é›¶ä»¶å·')) return [];
                                    const TYPE_SET = new Set(['WIRE', 'çº¿æŸ', 'å¯¼çº¿']);
                                    const otherName = getOtherFileName(fileName);
                                    const { byPN } = buildIndexes(otherName);
                                    const rows = filteredRows(fileName) || [];
                                    const tmp = [];
                                    rows.forEach(row => {
                                        const pn = String((row && row['é›¶ä»¶å·']) ?? '').trim();
                                        const tp = String((row && row['ç±»å‹']) ?? '').trim();
                                        if (!pn || !TYPE_SET.has(tp)) return;
                                        const otherRow = byPN.get(pn);
                                        const q1 = toNumber(row['æ•°é‡']);
                                        const q2 = otherRow ? toNumber(otherRow['æ•°é‡']) : 0;
                                        tmp.push({ pn, type: tp, q1, q2, diff: q1 - q2 });
                                    });
                                    list = tmp;
                                }
                                // å¥—ç”¨å½“å‰åˆ—ç­›é€‰ï¼ˆåªæ˜¾ç¤ºå½“å‰ç­›é€‰åçš„ PNï¼‰
                                const visible = new Set((filteredRows(fileName) || []).map(r => String((r && r['é›¶ä»¶å·']) ?? '').trim()));
                                return (list || []).filter(d => visible.has(d.pn));
                            }

                            // ======================== é€šç”¨å¯¼å‡ºå·¥å…·ï¼ˆå¯å¤ç”¨ï¼‰ ========================
                            const COLORS = {
                                LIGHT_RED: 'FFFFC8C8',   // #FFC8C8 - æœªæ‰¾åˆ°
                                ORANGE: 'FFF4B382',      // #F4B382 - ä¾›åº”å•†é›¶ä»¶å·åŒ¹é…
                                LIGHT_BLUE: 'FF99CCFF',  // #99CCFF - æ•°é‡ä¸ä¸€è‡´
                                LIGHT_GREEN: 'FFC8FFC8', // #C8FFC8 - å®Œå…¨ä¸€è‡´
                                GRAY: 'FFDCDCDC',        // #DCDCDC - æ ‡é¢˜èƒŒæ™¯
                                LIGHT_GRAY: 'FFF0F0F0',  // #F0F0F0 - è¡¨å¤´èƒŒæ™¯
                            };
                            const fillSolid = (argb) => ({ type: 'pattern', pattern: 'solid', fgColor: { argb } });
                            function priorityFill(p) {
                                switch (p) {
                                    case 0: return fillSolid(COLORS.LIGHT_RED);
                                    case 1: return fillSolid(COLORS.ORANGE);
                                    case 2: return fillSolid(COLORS.LIGHT_BLUE);
                                    case 3: return fillSolid(COLORS.LIGHT_GREEN);
                                    default: return undefined;
                                }
                            }
                            function markText(p) { return ['æœªæ‰¾åˆ°', 'ä¾›åº”å•†åŒ¹é…', 'æ•°é‡ä¸åŒ', 'æ•°é‡ç›¸åŒ'][p] || ''; }

                            // ä½¿ç”¨å½“å‰ UI é€‰æ‹©ä¸æ’åºå¯¼å‡ºï¼ˆæ¨¡æ‹Ÿâ€œå¯åŠ¨å¯¹æ¯”åç‚¹å‡»å¯¼å‡ºâ€çš„è¡Œä¸ºï¼‰
                            async function exportCurrentSelection() {
                                const n = selectedFiles.value.length;
                                if (n === 0) return;
                                const wb = new ExcelJS.Workbook();
                                if (n === 1) {
                                    const f = selectedFiles.value[0];
                                    const t = getTable(f);
                                    const cols = (t.columns || []).slice();
                                    const rows = filteredRows(f) || [];
                                    const ws = wb.addWorksheet(sanitizeSheetName(f, new Set()));
                                    ws.addRow(cols); ws.getRow(1).font = { bold: true }; ws.getRow(1).fill = fillSolid(COLORS.LIGHT_GRAY);
                                    rows.forEach(r => ws.addRow(cols.map(c => r[c])));
                                    // è®¾ç½®åˆ—æ ¼å¼ï¼šé™¤â€œæ•°é‡â€å¤–ï¼Œå…¨éƒ¨æŒ‰æ–‡æœ¬æ˜¾ç¤ºä»¥ä¿ç•™å‰å¯¼é›¶
                                    const qtyIdx_ws = cols.indexOf('æ•°é‡');
                                    ws.columns = cols.map((name, idx) => ({ header: name, key: `c${idx}`, width: Math.max(10, String(name || '').length + 2), numFmt: (idx === qtyIdx_ws ? undefined : '@') }));
                                    // ç¡®ä¿æ•°é‡åˆ—æ˜¯æ•°å€¼
                                    if (qtyIdx_ws !== -1) {
                                        for (let r = 2; r <= ws.rowCount; r++) {
                                            const cell = ws.getRow(r).getCell(qtyIdx_ws + 1);
                                            const n = toNumber(cell.value);
                                            cell.value = n;
                                        }
                                    }
                                    applyBordersForRange(ws, 1, 1, rows.length + 1, cols.length);
                                    autoFitColumns(ws);
                                    await downloadWorkbook(wb, `${sanitizeFileBase(f)}.xlsx`);
                                    return;
                                }

                                const [f1, f2] = selectedFiles.value;
                                const t1 = getTable(f1), t2 = getTable(f2);
                                const cols1 = (t1.columns || []).slice();
                                const cols2 = (t2.columns || []).slice();
                                if (compareMode.value) {
                                    // ç€è‰²å¯¹æ¯”è¡¨ A
                                    const wsA = wb.addWorksheet(sanitizeSheetName(f1, new Set()));
                                    wsA.addRow([...cols1, 'å¯¹æ¯”æ ‡è®°']); wsA.getRow(1).font = { bold: true }; wsA.getRow(1).fill = fillSolid(COLORS.LIGHT_GRAY);
                                    (filteredRows(f1) || []).forEach(r => {
                                        const p = categoryPriority(f1, r);
                                        const vals = [...cols1.map(c => r[c]), markText(p)];
                                        const row = wsA.addRow(vals);
                                        const fill = priorityFill(p); if (fill) for (let c = 1; c <= vals.length; c++) row.getCell(c).fill = fill;
                                    });
                                    // åˆ—æ ¼å¼ï¼šé™¤â€œæ•°é‡â€å¤–æ–‡æœ¬ï¼Œæ•°é‡ä¸ºæ•°å€¼
                                    const qtyIdx_A = cols1.indexOf('æ•°é‡');
                                    wsA.columns = [...cols1, 'å¯¹æ¯”æ ‡è®°'].map((name, idx) => ({ header: name, key: `a${idx}`, width: Math.max(10, String(name || '').length + 2), numFmt: (idx === qtyIdx_A ? undefined : '@') }));
                                    if (qtyIdx_A !== -1) {
                                        for (let r = 2; r <= wsA.rowCount; r++) {
                                            const cell = wsA.getRow(r).getCell(qtyIdx_A + 1);
                                            const n = toNumber(cell.value);
                                            cell.value = n;
                                        }
                                    }
                                    applyBordersForRange(wsA, 1, 1, wsA.rowCount, wsA.columnCount);
                                    autoFitColumns(wsA);

                                    // ç€è‰²å¯¹æ¯”è¡¨ B
                                    const wsB = wb.addWorksheet(sanitizeSheetName(f2, new Set(wb.worksheets.map(w => w.name))));
                                    wsB.addRow([...cols2, 'å¯¹æ¯”æ ‡è®°']); wsB.getRow(1).font = { bold: true }; wsB.getRow(1).fill = fillSolid(COLORS.LIGHT_GRAY);
                                    (filteredRows(f2) || []).forEach(r => {
                                        const p = categoryPriority(f2, r);
                                        const vals = [...cols2.map(c => r[c]), markText(p)];
                                        const row = wsB.addRow(vals);
                                        const fill = priorityFill(p); if (fill) for (let c = 1; c <= vals.length; c++) row.getCell(c).fill = fill;
                                    });
                                    // åˆ—æ ¼å¼ï¼šé™¤â€œæ•°é‡â€å¤–æ–‡æœ¬ï¼Œæ•°é‡ä¸ºæ•°å€¼
                                    const qtyIdx_B = cols2.indexOf('æ•°é‡');
                                    wsB.columns = [...cols2, 'å¯¹æ¯”æ ‡è®°'].map((name, idx) => ({ header: name, key: `b${idx}`, width: Math.max(10, String(name || '').length + 2), numFmt: (idx === qtyIdx_B ? undefined : '@') }));
                                    if (qtyIdx_B !== -1) {
                                        for (let r = 2; r <= wsB.rowCount; r++) {
                                            const cell = wsB.getRow(r).getCell(qtyIdx_B + 1);
                                            const n = toNumber(cell.value);
                                            cell.value = n;
                                        }
                                    }
                                    applyBordersForRange(wsB, 1, 1, wsB.rowCount, wsB.columnCount);
                                    autoFitColumns(wsB);

                                    // æ±‡æ€»é¡µï¼ˆä½¿ç”¨ç°æœ‰ç»Ÿè®¡ä¸å·®å€¼å‡½æ•°ï¼‰
                                    const wsS = wb.addWorksheet(sanitizeSheetName('å¯¹æ¯”ç»“æœ', new Set(wb.worksheets.map(w => w.name))));
                                    wsS.getCell('A1').value = 'å›¾ä¾‹'; wsS.getCell('A1').fill = fillSolid(COLORS.GRAY);
                                    const legends = [
                                        { text: 'é›¶ä»¶å·ä¸å­˜åœ¨', color: COLORS.LIGHT_RED },
                                        { text: 'ä¾›åº”å•†é›¶ä»¶å·åŒ¹é…', color: COLORS.ORANGE },
                                        { text: 'æ•°é‡ä¸ä¸€è‡´', color: COLORS.LIGHT_BLUE },
                                        { text: 'å®Œå…¨ä¸€è‡´', color: COLORS.LIGHT_GREEN },
                                    ];
                                    for (let i = 0; i < legends.length; i++) { const r = 3 + i; wsS.getCell(r, 1).value = legends[i].text; wsS.getCell(r, 1).fill = fillSolid(legends[i].color); }
                                    const cntA = categoryCounts(f1); const cntB = categoryCounts(f2);
                                    const colsBase = ['é›¶ä»¶å·', 'ä¾›åº”å•†é›¶ä»¶å·', 'ç±»å‹', 'æ•°é‡'];
                                    // A é¢è®¡æ•° + æ˜ç»†ï¼ˆæŒ‰å½“å‰ filteredRows é¡ºåºï¼‰
                                    wsS.getCell('C1').value = sanitizeSheetName(f1); wsS.getCell('C1').fill = fillSolid(COLORS.GRAY);
                                    [cntA.red, cntA.orange, cntA.blue, cntA.green].forEach((val, i) => { const cell = wsS.getCell(2, 3 + i); cell.value = val; cell.fill = fillSolid([COLORS.LIGHT_RED, COLORS.ORANGE, COLORS.LIGHT_BLUE, COLORS.LIGHT_GREEN][i]); });
                                    colsBase.forEach((c, k) => { const cell = wsS.getCell(3, 3 + k); cell.value = c; cell.fill = fillSolid(COLORS.LIGHT_GRAY); cell.font = { bold: true }; });
                                    (filteredRows(f1) || []).forEach((r, i) => {
                                        const p = categoryPriority(f1, r);
                                        const vals = [r['é›¶ä»¶å·'], r['ä¾›åº”å•†é›¶ä»¶å·'], r['ç±»å‹'], r['æ•°é‡']];
                                        for (let j = 0; j < vals.length; j++) { const cell = wsS.getCell(4 + i, 3 + j); cell.value = vals[j]; const fill = priorityFill(p); if (fill) cell.fill = fill; }
                                    });
                                    // B é¢
                                    wsS.getCell('H1').value = sanitizeSheetName(f2); wsS.getCell('H1').fill = fillSolid(COLORS.GRAY);
                                    [cntB.red, cntB.orange, cntB.blue, cntB.green].forEach((val, i) => { const cell = wsS.getCell(2, 8 + i); cell.value = val; cell.fill = fillSolid([COLORS.LIGHT_RED, COLORS.ORANGE, COLORS.LIGHT_BLUE, COLORS.LIGHT_GREEN][i]); });
                                    colsBase.forEach((c, k) => { const cell = wsS.getCell(3, 8 + k); cell.value = c; cell.fill = fillSolid(COLORS.LIGHT_GRAY); cell.font = { bold: true }; });
                                    (filteredRows(f2) || []).forEach((r, i) => {
                                        const p = categoryPriority(f2, r);
                                        const vals = [r['é›¶ä»¶å·'], r['ä¾›åº”å•†é›¶ä»¶å·'], r['ç±»å‹'], r['æ•°é‡']];
                                        for (let j = 0; j < vals.length; j++) { const cell = wsS.getCell(4 + i, 8 + j); cell.value = vals[j]; const fill = priorityFill(p); if (fill) cell.fill = fill; }
                                    });
                                    // è®¾ç½®æ˜ç»†åˆ—æ ¼å¼ï¼ˆC:F å’Œ H:Kï¼‰ï¼šé™¤â€œæ•°é‡â€å¤–æ–‡æœ¬
                                    const qtyOffset = 3; // Cåˆ—ä¸º3
                                    const setDetailFormats = (startCol) => {
                                        const headers = ['é›¶ä»¶å·', 'ä¾›åº”å•†é›¶ä»¶å·', 'ç±»å‹', 'æ•°é‡'];
                                        headers.forEach((h, idx) => {
                                            const colIndex = startCol + idx;
                                            const isQty = (h === 'æ•°é‡');
                                            wsS.getColumn(colIndex).numFmt = isQty ? undefined : '@';
                                            if (isQty) {
                                                for (let r = 4; r <= wsS.rowCount; r++) {
                                                    const cell = wsS.getCell(r, colIndex);
                                                    const n = toNumber(cell.value);
                                                    cell.value = n;
                                                }
                                            }
                                        });
                                    };
                                    setDetailFormats(3); // C:F
                                    setDetailFormats(8); // H:K
                                    // å¯¼çº¿å·®å€¼åˆ—è¡¨ï¼ˆå¤ç”¨ wiresDiff æ’åºä¸è¿‡æ»¤ï¼‰
                                    wsS.getCell('M1').value = 'å¯¼çº¿é•¿åº¦å·®å€¼è®¡ç®—'; wsS.getCell('M1').fill = fillSolid(COLORS.GRAY);
                                    const head3 = ['é›¶ä»¶å·', 'ç±»å‹', 'å·¦è¡¨æ•°é‡', 'å³è¡¨æ•°é‡', 'å·®å€¼(å·¦-å³)'];
                                    head3.forEach((h, k) => { const cell = wsS.getCell(3, 13 + k); cell.value = h; cell.fill = fillSolid(COLORS.LIGHT_GRAY); cell.font = { bold: true }; });
                                    (wiresDiff(f1) || []).forEach((d, i) => {
                                        const vals = [d.pn, d.type, d.q1, d.q2, d.diff];
                                        const fill = d.diff > 0 ? fillSolid(COLORS.LIGHT_GREEN) : (d.diff < 0 ? fillSolid(COLORS.LIGHT_RED) : undefined);
                                        for (let j = 0; j < vals.length; j++) { const cell = wsS.getCell(4 + i, 13 + j); cell.value = vals[j]; if (fill) cell.fill = fill; }
                                    });
                                    // è®¾ç½®å¯¼çº¿å·®å€¼åŒºåŸŸåˆ—æ ¼å¼ï¼šM(N)=æ–‡æœ¬ï¼ŒO/P/Q=æ•°å€¼
                                    wsS.getColumn(13).numFmt = '@'; // é›¶ä»¶å·
                                    wsS.getColumn(14).numFmt = '@'; // ç±»å‹
                                    [15, 16, 17].forEach(ci => { wsS.getColumn(ci).numFmt = undefined; });
                                    for (let r = 4; r <= wsS.rowCount; r++) {
                                        [15, 16, 17].forEach(ci => { const cell = wsS.getCell(r, ci); const n = toNumber(cell.value); cell.value = n; });
                                    }
                                    const maxRow = Math.max(6, wsS.rowCount);
                                    applyBordersForRange(wsS, 1, 1, maxRow, 17);
                                    autoFitColumns(wsS);
                                    await downloadWorkbook(wb, `å¯¹æ¯”ç»“æœ_${sanitizeFileBase(f1)}_VS_${sanitizeFileBase(f2)}.xlsx`);
                                } else {
                                    // ä¸¤è¡¨åŸæ ·å¯¼å‡ºï¼ˆæŒ‰ filteredRows å½“å‰é¡ºåºï¼‰
                                    const ws1 = wb.addWorksheet(sanitizeSheetName(f1, new Set()));
                                    ws1.addRow(cols1); ws1.getRow(1).font = { bold: true }; ws1.getRow(1).fill = fillSolid(COLORS.LIGHT_GRAY);
                                    (filteredRows(f1) || []).forEach(r => ws1.addRow(cols1.map(c => r[c])));
                                    const qtyIdx_1 = cols1.indexOf('æ•°é‡');
                                    ws1.columns = cols1.map((name, idx) => ({ header: name, key: `x1_${idx}`, width: Math.max(10, String(name || '').length + 2), numFmt: (idx === qtyIdx_1 ? undefined : '@') }));
                                    if (qtyIdx_1 !== -1) {
                                        for (let r = 2; r <= ws1.rowCount; r++) {
                                            const cell = ws1.getRow(r).getCell(qtyIdx_1 + 1);
                                            const n = toNumber(cell.value);
                                            cell.value = n;
                                        }
                                    }
                                    applyBordersForRange(ws1, 1, 1, ws1.rowCount, ws1.columnCount); autoFitColumns(ws1);

                                    const ws2 = wb.addWorksheet(sanitizeSheetName(f2, new Set(wb.worksheets.map(w => w.name))));
                                    ws2.addRow(cols2); ws2.getRow(1).font = { bold: true }; ws2.getRow(1).fill = fillSolid(COLORS.LIGHT_GRAY);
                                    (filteredRows(f2) || []).forEach(r => ws2.addRow(cols2.map(c => r[c])));
                                    const qtyIdx_2 = cols2.indexOf('æ•°é‡');
                                    ws2.columns = cols2.map((name, idx) => ({ header: name, key: `x2_${idx}`, width: Math.max(10, String(name || '').length + 2), numFmt: (idx === qtyIdx_2 ? undefined : '@') }));
                                    if (qtyIdx_2 !== -1) {
                                        for (let r = 2; r <= ws2.rowCount; r++) {
                                            const cell = ws2.getRow(r).getCell(qtyIdx_2 + 1);
                                            const n = toNumber(cell.value);
                                            cell.value = n;
                                        }
                                    }
                                    applyBordersForRange(ws2, 1, 1, ws2.rowCount, ws2.columnCount); autoFitColumns(ws2);

                                    await downloadWorkbook(wb, `ä¸¤è¡¨å¯¼å‡º_${sanitizeFileBase(f1)}_ä¸_${sanitizeFileBase(f2)}.xlsx`);
                                }
                            }

                            async function downloadWorkbook(wb, filename) {
                                const buffer = await wb.xlsx.writeBuffer();
                                const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url; a.download = filename; a.click();
                                URL.revokeObjectURL(url);
                            }

                            // å¯¼å‡ºï¼šä½¿ç”¨ç°æœ‰ UI é€»è¾‘ï¼›å¤šé€‰æ—¶æ¨¡æ‹Ÿäººå·¥â€œå¯åŠ¨å¯¹æ¯”+å¯¼å‡ºâ€çš„é€å¯¹æµç¨‹
                            async function exportCompare() {
                                try {
                                    if (!window.ExcelJS || selectedFiles.value.length === 0) return;
                                    const n = selectedFiles.value.length;
                                    // å·¥å…·: ç›´æ¥è¿è¡Œä¸€æ¬¡å¯¹æ¯”ï¼ˆä¸ä¾èµ–åˆ‡æ¢æŒ‰é’®ï¼‰ï¼Œå¹¶ç­‰å¾…ç¼“å­˜å°±ç»ª
                                    const runCompareFor = async (f1, f2) => {
                                        const t1 = getTable(f1), t2 = getTable(f2);
                                        const makeIndexMap = (name, data) => { const map = new WeakMap(); (data || []).forEach((row, idx) => map.set(row, idx)); originalIndexMaps.set(name, map); };
                                        makeIndexMap(f1, t1.data || []);
                                        makeIndexMap(f2, t2.data || []);
                                        const toPlainRows = (rows) => (Array.isArray(rows) ? rows : []).map(r => Object.fromEntries(Object.entries(r)));
                                        const leftPayload = { name: f1, rows: toPlainRows(t1.data) };
                                        const rightPayload = { name: f2, rows: toPlainRows(t2.data) };
                                        const worker = ensureCompareWorker();
                                        compareBusy.value = true;
                                        worker.postMessage({ left: leftPayload, right: rightPayload });
                                    };
                                    const waitForCompareCache = async (a, b, timeoutMs = 15000) => {
                                        const start = Date.now();
                                        return new Promise((resolve, reject) => {
                                            const tick = () => {
                                                const ready = compareCache[a] && compareCache[b] && compareCache[a].categories && compareCache[b].categories && !compareBusy.value && compareMode.value;
                                                if (ready) return resolve(true);
                                                if (Date.now() - start > timeoutMs) return reject(new Error('å¯¹æ¯”è€—æ—¶è¿‡é•¿ï¼Œå·²è¶…æ—¶'));
                                                setTimeout(tick, 50);
                                            };
                                            tick();
                                        });
                                    };
                                    // å¤šäºä¸¤ä¸ªæ–‡ä»¶ï¼šä¸¤ä¸¤æˆå¯¹åˆ†åˆ«å¯¼å‡ºï¼ˆæ¯å¯¹ï¼šå…ˆå¯¹æ¯”å¹¶ç­‰å¾…ç»“æœ -> å†å¯¼å‡ºå¸¦é¢œè‰²çš„å¯¹æ¯”è¡¨ï¼‰
                                    if (n > 2) {
                                        const originalSel = [...selectedFiles.value];
                                        const originalCompare = compareMode.value;
                                        try {
                                            for (let i = 0; i < originalSel.length - 1; i++) {
                                                for (let j = i + 1; j < originalSel.length; j++) {
                                                    const a = originalSel[i];
                                                    const b = originalSel[j];
                                                    selectedFiles.value = [a, b];
                                                    await runCompareFor(a, b);
                                                    try { await waitForCompareCache(a, b); } catch (e) { /* å…œåº•ï¼šå…è®¸ç»§ç»­å¯¼å‡ºï¼Œä½†å¯èƒ½ä¸ºéç€è‰²ç‰ˆ */ }
                                                    await exportCurrentSelection();
                                                }
                                            }
                                        } finally {
                                            selectedFiles.value = originalSel;
                                            compareMode.value = originalCompare && originalSel.length === 2; // ä»…å½“åŸæœ¬æ˜¯åŒé€‰æ—¶ä¿ç•™
                                        }
                                        return;
                                    }

                                    // å•ä¸ªæ–‡ä»¶ï¼šå¯¼å‡ºå•è¡¨
                                    if (n === 1) {
                                        await exportCurrentSelection();
                                        return;
                                    }

                                    // æ°å¥½ä¸¤ä¸ªæ–‡ä»¶ï¼šå…ˆå¯¹æ¯”å¹¶ç­‰å¾…ç»“æœï¼Œå†å¯¼å‡º
                                    const [a, b] = selectedFiles.value;
                                    await runCompareFor(a, b);
                                    try { await waitForCompareCache(a, b); } catch (e) { /* å…œåº•ç»§ç»­ */ }
                                    await exportCurrentSelection();
                                } catch (e) {
                                    alert('å¯¼å‡ºå¤±è´¥ï¼š' + (e && e.message ? e.message : e));
                                }
                            }
                            // è‡ªåŠ¨é€‚é…åˆ—å®½ï¼ˆåŸºäºæ–‡æœ¬é•¿åº¦ï¼Œè®¾ç½®ä¸Šä¸‹é™ï¼‰
                            function autoFitColumns(ws, minWidth = 10, maxWidth = 40) {
                                const cols = ws.columns || [];
                                cols.forEach(col => {
                                    let maxLen = 0;
                                    col.eachCell({ includeEmpty: true }, cell => {
                                        const v = cell.value;
                                        let l = 0;
                                        if (v == null) l = 0;
                                        else if (typeof v === 'object') {
                                            if (Array.isArray(v.richText)) {
                                                l = v.richText.map(t => t.text || '').join('').length;
                                            } else if (v.text != null) {
                                                l = String(v.text).length;
                                            } else {
                                                l = String(v).length;
                                            }
                                        } else {
                                            l = String(v).length;
                                        }
                                        if (l > maxLen) maxLen = l;
                                    });
                                    col.width = Math.min(maxWidth, Math.max(minWidth, maxLen + 2));
                                });
                            }

                            function applyBordersForRange(ws, r1, c1, r2, c2) {
                                // å®¹é”™ï¼šç¡®ä¿è¾¹ç•Œæœ‰æ•ˆ
                                r1 = Math.max(1, Math.floor(r1));
                                c1 = Math.max(1, Math.floor(c1));
                                r2 = Math.max(r1, Math.floor(r2));
                                c2 = Math.max(c1, Math.floor(c2));
                                for (let r = r1; r <= r2; r++) {
                                    for (let c = c1; c <= c2; c++) {
                                        const cell = ws.getCell(r, c);
                                        cell.border = {
                                            top: { style: 'thin' },
                                            left: { style: 'thin' },
                                            bottom: { style: 'thin' },
                                            right: { style: 'thin' },
                                        };
                                    }
                                }
                            }

                            //ï¼ˆç§»é™¤æœªä½¿ç”¨çš„ labelForCategoryï¼‰

                            // æ¸…æ´—ä¸ºåˆæ³•çš„ Excel å·¥ä½œè¡¨åï¼Œå¹¶é¿å…é‡åå†²çª
                            function sanitizeSheetName(name, existing = new Set()) {
                                const invalid = /[\\\/*?:\[\]]/g;
                                const baseRaw = String(name).replace(invalid, ' ').trim() || 'Sheet';
                                const cut = (s) => s.length > 31 ? s.slice(0, 31) : s;
                                let candidate = cut(baseRaw);
                                // å¦‚æœå†²çªï¼Œå°è¯•è¿½åŠ  (2),(3)...ï¼Œå¹¶ä¿è¯æ€»é•¿<=31
                                let idx = 2;
                                while (existing.has(candidate)) {
                                    const suffix = ` (${idx})`;
                                    const maxLen = 31 - suffix.length;
                                    candidate = cut(baseRaw.slice(0, Math.max(1, maxLen)) + suffix);
                                    idx++;
                                }
                                existing.add(candidate);
                                return candidate;
                            }

                            // ç”Ÿæˆå¯ç”¨äºæ–‡ä»¶åçš„åŸºç¡€ä¸²ï¼ˆå»æ‰©å±•åå¹¶æ›¿æ¢éæ³•å­—ç¬¦ï¼‰
                            function sanitizeFileBase(name) {
                                return String(name).replace(/\.[^.]+$/, '').replace(/[^\u4e00-\u9fa5\w-]+/g, '_');
                            }

                            // ç”Ÿæˆå”¯ä¸€æ˜¾ç¤ºåï¼šname, name (2), name (3)...

                            return {
                                tables,
                                fileList,
                                selectedFiles,
                                subtitle,
                                loading,
                                compareMode,
                                multiCompareMode,
                                compareBusy,
                                sheetReady,
                                sjsReady,
                                faReady,
                                sheetBadge,
                                sjsBadge,
                                faBadge,
                                // å›åˆ°é¡¶éƒ¨
                                showTop,
                                scrollToTop,
                                // é¢œè‰²åˆ†ç±»ç­›é€‰
                                toggleColorFilter,
                                badgeClass,
                                handleFiles,
                                exportCompare,
                                toggleCompare,
                                toggleMultiCompare,
                                onFileCheckboxChange,
                                selectAllFiles,
                                getTable,
                                removeFile,
                                toggleFilterDropdown,
                                isDropdownOpen,
                                getFilterState,
                                closeDropdown,
                                filteredDistinctValues,
                                isValueChecked,
                                onToggleValue,
                                selectAllValues,
                                clearAllValues,
                                applyFilter,
                                isColumnFiltered,
                                hasActiveFilters,
                                dropdownStyle,
                                filteredRows,
                                rowBgClass,
                                categoryCounts,
                                wiresDiff,
                                // é¢„è§ˆå®¹å™¨æ§åˆ¶
                                containerVisible,
                                displayedSelectedFiles,
                                onPreviewContainerAfterLeave,
                                onBeforeEnter,
                                onEnter,
                                onAfterEnter,
                                onBeforeLeave,
                                onLeave,
                                cardWidth,
                                cardStyle,
                                previewWrap
                            };
                        }
                    }).mount('#app');

                    // ========== é¡µé¢å¢å¼ºåŠŸèƒ½ ==========

                    // æ€§èƒ½ç›‘æ§
                    if (window.performance) {
                        window.addEventListener('load', () => {
                            const perfData = performance.getEntriesByType('navigation')[0];
                            console.log(`é¡µé¢åŠ è½½æ—¶é—´: ${(perfData.loadEventEnd - perfData.fetchStart).toFixed(2)}ms`);
                        });
                    }

                    // ç§»åŠ¨ç«¯é€‚é…
                    if (/Mobile|Android|iPhone|iPad/i.test(navigator.userAgent)) {
                        document.body.classList.add('mobile-device');

                        // ç§»åŠ¨ç«¯è¡¨æ ¼æ¨ªå‘æ»šåŠ¨æç¤º
                        const addSwipeHint = () => {
                            const tables = document.querySelectorAll('.overflow-auto');
                            tables.forEach(container => {
                                if (container.scrollWidth > container.clientWidth) {
                                    container.setAttribute('data-swipe-hint', 'ğŸ‘ˆ å·¦å³æ»‘åŠ¨æŸ¥çœ‹æ›´å¤š');
                                }
                            });
                        };

                        // å»¶è¿Ÿæ‰§è¡Œï¼Œç­‰å¾…è¡¨æ ¼æ¸²æŸ“
                        setTimeout(addSwipeHint, 1000);
                    }

                    // é”®ç›˜å¿«æ·é”®æ”¯æŒ
                    document.addEventListener('keydown', (e) => {
                        // Ctrl/Cmd + Enter å¿«é€Ÿå¯¼å…¥æ–‡ä»¶
                        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                            e.preventDefault();
                            document.getElementById('fileInput')?.click();
                        }

                        // Esc é”®å…³é—­æ‰€æœ‰ä¸‹æ‹‰èœå•
                        if (e.key === 'Escape') {
                            const app = document.getElementById('app').__vue_app__;
                            if (app && app._instance) {
                                const vm = app._instance.ctx;
                                // å…³é—­æ‰€æœ‰ç­›é€‰é¢æ¿
                                Object.keys(vm.filterUI || {}).forEach(fileName => {
                                    const cols = vm.filterUI[fileName] || {};
                                    Object.keys(cols).forEach(colName => {
                                        cols[colName].open = false;
                                    });
                                });
                                vm.openDropdownKey = '';
                            }
                        }
                    });

                    // PWA æ”¯æŒæ£€æµ‹
                    if ('serviceWorker' in navigator) {
                        console.log('æµè§ˆå™¨æ”¯æŒ Service Workerï¼Œå¯ä»¥è€ƒè™‘æ·»åŠ ç¦»çº¿æ”¯æŒ');
                    }

                </script>

                <!-- å¢å¼ºçš„æ— éšœç¢æ”¯æŒ -->
                <div id="sr-status" class="sr-only" aria-live="polite" aria-atomic="true"></div>

            </main>
        </div>
    </body>

</html>