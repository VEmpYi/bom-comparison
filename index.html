<!DOCTYPE html>
<html lang="zh-CN">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes">
        <meta name="description" content="ä¸“ä¸šçš„BOMè¡¨æ ¼å¯¹æ¯”åˆ†æå·¥å…·ï¼Œæ”¯æŒExcelå’ŒHTMLæ–‡ä»¶å¯¼å…¥å¯¹æ¯”">
        <meta name="keywords" content="BOM,è¡¨æ ¼å¯¹æ¯”,Excel,æ•°æ®åˆ†æ">
        <title>è¡¨æ ¼ BOM å¯¹æ¯”åˆ†æ</title>

        <!-- Preload critical resources -->
        <link rel="preload" href="https://cdn.tailwindcss.com" as="script">
        <link rel="preload" href="https://unpkg.com/vue@3/dist/vue.global.prod.js" as="script">

        <!-- Tailwind CSS v3 CDN -->
        <script src="https://cdn.tailwindcss.com"></script>
        <!-- Font Awesome 6 CDN with fallback -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
            onerror="this.onerror=null; this.href='https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css'">
        <!-- ExcelJS CDN (deferé¿å…é˜»å¡æ¸²æŸ“) -->
        <script defer src="https://cdn.jsdelivr.net/npm/exceljs@4.4.0/dist/exceljs.min.js"></script>
        <!-- Vue 3 å…¨å±€æ„å»º CDN with fallback -->
        <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"
            onerror="this.onerror=null; this.src='https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.prod.js'"></script>
        <style>
            /* ========== ç°ä»£åŒ–åŸºç¡€æ ·å¼ ========== */
            :root {
                --primary-blue: #2563eb;
                --primary-green: #059669;
                --primary-red: #dc2626;
                --primary-orange: #ea580c;
                --bg-gradient: linear-gradient(135deg, #f0f9ff 0%, #ffffff 50%, #fef7f7 100%);
                --shadow-soft: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
                --shadow-card: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
                --border-radius: 12px;
                --transition-smooth: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            }

            /* æµ®åŠ¨å¼æ»šåŠ¨æ¡ï¼ˆä¸å ç”¨é¡µé¢å¸ƒå±€ç©ºé—´ï¼‰ */
            html {
                overflow-y: overlay;
                /* æ»šåŠ¨æ¡æµ®åœ¨å†…å®¹ä¸Šæ–¹ */
                scrollbar-gutter: stable;
                /* ä¸ºæ»šåŠ¨æ¡é¢„ç•™ç¨³å®šç©ºé—´ */
            }

            /* å¦‚æœä¸æ”¯æŒ overlayï¼Œåˆ™éšè—æ»šåŠ¨æ¡ */
            @supports not (overflow-y: overlay) {
                html {
                    overflow-y: auto;
                    scrollbar-width: none;
                    /* Firefox */
                    -ms-overflow-style: none;
                    /* Internet Explorer 10+ */
                }

                html::-webkit-scrollbar {
                    display: none;
                    /* WebKit */
                }
            }

            /* ä¼˜é›…çš„æ»šåŠ¨æ¡ï¼ˆæ”¯æŒæ›´å¤šæµè§ˆå™¨ï¼‰ */
            ::-webkit-scrollbar {
                width: 12px;
                height: 12px;
            }

            ::-webkit-scrollbar-track {
                background: transparent;
                /* é€æ˜èƒŒæ™¯ï¼Œä¸å½±å“é¡µé¢å¸ƒå±€ */
            }

            ::-webkit-scrollbar-thumb {
                background: rgba(156, 163, 175, 0.3);
                border-radius: 6px;
                border: 2px solid transparent;
                background-clip: content-box;
                transition: var(--transition-smooth);
            }

            ::-webkit-scrollbar-thumb:hover {
                background: rgba(107, 114, 128, 0.6);
                background-clip: content-box;
            }

            /* æ»šåŠ¨æ¡è§’è½å¤„ç† */
            ::-webkit-scrollbar-corner {
                background: transparent;
            }

            /* Firefox æµ®åŠ¨å¼æ»šåŠ¨æ¡ */
            * {
                scrollbar-width: thin;
                scrollbar-color: rgba(156, 163, 175, 0.3) transparent;
            }

            /* å¦‚æœä¸æ”¯æŒ overlayï¼Œåˆ™å¯¹æ‰€æœ‰å…ƒç´ éšè—æ»šåŠ¨æ¡ */
            @supports not (overflow-y: overlay) {
                * {
                    scrollbar-width: none;
                    /* Firefox */
                    -ms-overflow-style: none;
                    /* Internet Explorer 10+ */
                }

                *::-webkit-scrollbar {
                    display: none;
                    /* WebKit */
                }
            }

            /* ç¡®ä¿é¡µé¢å†…å®¹ä¸å› æ»šåŠ¨æ¡å‡ºç°è€Œåç§» */
            body {
                overflow-y: overlay;
                scrollbar-gutter: stable;
            }

            /* å¦‚æœä¸æ”¯æŒ overlayï¼Œbody ä¹Ÿéšè—æ»šåŠ¨æ¡ */
            @supports not (overflow-y: overlay) {
                body {
                    overflow-y: auto;
                    scrollbar-width: none;
                    -ms-overflow-style: none;
                }

                body::-webkit-scrollbar {
                    display: none;
                }
            }

            /* è¿‡æ¸¡åŠ¨ç”» */
            .fade-enter-active,
            .fade-leave-active {
                transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            }

            .fade-enter-from,
            .fade-leave-to {
                opacity: 0;
                transform: translateY(-8px);
            }

            .fadeout-leave-active {
                transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            }

            .fadeout-leave-to {
                opacity: 0;
                transform: translateY(-8px);
            }

            /* æ»‘åŠ¨è¿‡æ¸¡ */
            .slide-down-enter-active,
            .slide-down-leave-active {
                transition: max-height 0.5s cubic-bezier(0.4, 0, 0.2, 1);
                overflow: hidden;
            }

            .slide-down-enter-from {
                max-height: 0;
                opacity: 0;
            }

            .slide-down-enter-to {
                max-height: 9999px;
                opacity: 1;
            }

            .slide-down-leave-from {
                max-height: 9999px;
                opacity: 1;
            }

            .slide-down-leave-to {
                max-height: 0;
                opacity: 0;
            }

            /* æ»‘åŠ¨è¿‡æ¸¡ - è‡ªé€‚åº”é«˜åº¦ç‰ˆæœ¬ */
            .slide-up-enter-active {
                transition: height 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.4s ease-in-out;
                overflow: hidden;
            }

            .slide-up-leave-active {
                transition: height 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.4s ease-in-out;
                overflow: hidden;
            }

            .slide-up-enter-from {
                height: 0;
                opacity: 0;
            }

            .slide-up-enter-to {
                height: auto;
                opacity: 1;
            }

            .slide-up-leave-from {
                height: auto;
                opacity: 1;
            }

            .slide-up-leave-to {
                height: 0;
                opacity: 0;
            }

            /* å†…å®¹æ·¡å…¥æ·¡å‡º - ç‹¬ç«‹æ§åˆ¶ */
            .content-fade-enter-active {
                transition: opacity 0.3s ease-in-out 0.2s;
                /* å»¶è¿Ÿ0.2så¼€å§‹ï¼Œè®©å®¹å™¨å…ˆå±•å¼€ä¸€ç‚¹ */
            }

            .content-fade-leave-active {
                transition: opacity 0.2s ease-in-out;
                /* å¿«é€Ÿæ·¡å‡ºï¼Œåœ¨å®¹å™¨æ”¶å›å‰å®Œæˆ */
            }

            .content-fade-enter-from {
                opacity: 0;
            }

            .content-fade-enter-to {
                opacity: 1;
            }

            .content-fade-leave-from {
                opacity: 1;
            }

            .content-fade-leave-to {
                opacity: 0.3;
                /* ä¿æŒå¾®å¼±å¯è§åº¦ï¼Œé¿å…å®Œå…¨æ¶ˆå¤± */
            }

            /* é¢„è§ˆå¡ç‰‡åˆ‡æ¢åŠ¨ç”» - ç»Ÿä¸€çš„è¿‡æ¸¡æ•ˆæœ */
            .preview-list-move,
            .preview-list-enter-active,
            .preview-list-leave-active {
                transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            }

            /* é¢„è§ˆå¡ç‰‡åŸºç¡€æ ·å¼ */
            .preview-card {
                /* ç§»é™¤å®½åº¦å’Œflex-basisçš„transitionï¼Œé¿å…ä¸Vue transition-groupå†²çª */
                transition: opacity 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            }

            /* æ–°æ–‡ä»¶è¿›å…¥ï¼šä»å³ä¾§æ»‘å…¥ */
            .preview-list-enter-from {
                opacity: 0;
                transform: translateX(120%) scale(0.9);
            }

            .preview-list-enter-to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }

            /* è¢«æŒ¤æ‰çš„æ–‡ä»¶å‘å·¦æ»‘å‡º */
            .preview-list-leave-from {
                opacity: 1;
                transform: translateX(0) scale(1);
            }

            .preview-list-leave-to {
                opacity: 0;
                transform: translateX(-120%) scale(0.9);
            }

            /* è¢«ç§»é™¤çš„å…ƒç´ ç»å¯¹å®šä½ï¼Œä¸å½±å“å¸ƒå±€ */
            .preview-list-leave-active {
                position: absolute;
                z-index: 0;
                width: calc((100% - 1.5rem) / 2);
                /* ä¿æŒåŸå§‹å®½åº¦ */
            }

            /* ç§»åŠ¨ä¸­çš„å…ƒç´ ä¿æŒåœ¨ä¸Šå±‚ */
            .preview-list-move {
                z-index: 1;
            }

            /* é¢„è§ˆå®¹å™¨æ ·å¼ - ç¡®ä¿åŠ¨ç”»ç©ºé—´ */
            .preview-container {
                position: relative;
                min-height: 200px;
                /* ç¡®ä¿æœ‰è¶³å¤Ÿç©ºé—´è¿›è¡ŒåŠ¨ç”» */
                overflow: hidden;
                /* éšè—æ»‘å‡ºçš„å…ƒç´  */
            }

            /* ç°ä»£åŒ–çš„æŒ‰é’®æ ·å¼ */
            .btn-modern {
                transition: var(--transition-smooth);
                transform: translateY(0);
                box-shadow: var(--shadow-card);
            }

            .btn-modern:hover {
                transform: translateY(-2px);
                box-shadow: var(--shadow-soft);
            }

            .btn-modern:active {
                transform: translateY(0);
            }

            /* å¢å¼ºçš„å¡ç‰‡æ ·å¼ */
            .card-modern {
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.2);
                box-shadow: var(--shadow-card);
                transition: var(--transition-smooth), height 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            }

            .card-modern:hover {
                box-shadow: var(--shadow-soft);
                transform: translateY(-2px);
            }

            /* æ–‡ä»¶åˆ—è¡¨å®¹å™¨hoveræ•ˆæœ */
            .file-list-container {
                background: rgba(255, 255, 255, 0.8);
                border-radius: var(--border-radius);
                box-shadow: var(--shadow-card);
                transition: var(--transition-smooth);
            }

            .file-list-container:hover {
                background: rgba(255, 255, 255, 0.95);
                box-shadow: var(--shadow-soft);
                transform: translateY(-2px);
            }

            /* æ–‡ä»¶åˆ—è¡¨é¡¹hoveræ•ˆæœ */
            .file-item {
                transition: var(--transition-smooth);
                border-radius: var(--border-radius);
            }

            .file-item:hover {
                box-shadow: var(--shadow-soft);
                transform: translateY(-1px);
            }

            .file-item.selected {
                background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
                border: 1px solid #3b82f6;
                box-shadow: var(--shadow-card);
                transform: translateY(-1px);
            }

            .file-item.selected:hover {
                box-shadow: var(--shadow-soft);
                transform: translateY(-2px);
            }

            /* é¢„è§ˆå¡ç‰‡hoveræ•ˆæœ */
            .preview-card {
                background: white;
                border-radius: var(--border-radius);
                box-shadow: var(--shadow-card);
                transition: var(--transition-smooth);
            }

            .preview-card:hover {
                box-shadow: var(--shadow-soft);
                transform: translateY(-3px);
            }

            /* è¡¨æ ¼å®¹å™¨ - ç§»é™¤hoveræ•ˆæœ */
            .table-container {
                border-radius: var(--border-radius);
                overflow: hidden;
            }

            /* ç­›é€‰ä¸‹æ‹‰èœå•hoveræ•ˆæœ */
            .filter-dropdown {
                transition: var(--transition-smooth);
                border-radius: var(--border-radius);
                box-shadow: var(--shadow-card);
            }

            .filter-dropdown:hover {
                box-shadow: var(--shadow-soft);
                transform: translateY(-1px);
            }

            /* è¡¨æ ¼å¢å¼ºæ ·å¼ */
            .table-modern {
                border-collapse: separate;
                border-spacing: 0;
                overflow: hidden;
                border-radius: var(--border-radius);
                box-shadow: var(--shadow-card);
            }

            .table-modern th {
                background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
                position: sticky;
                top: 0;
                z-index: 10;
            }

            .table-modern tbody tr:hover {
                background-color: rgba(59, 130, 246, 0.05);
                transform: scale(1.002);
                transition: var(--transition-smooth);
            }

            /* æ”¹è¿›çš„å…¼å®¹æ€§ */
            .touch-friendly {
                touch-action: manipulation;
                -webkit-tap-highlight-color: transparent;
            }

            /* å¯è®¿é—®æ€§å¢å¼º */
            .focus-visible:focus {
                outline: 2px solid var(--primary-blue);
                outline-offset: 2px;
            }

            /* æ€§èƒ½ä¼˜åŒ– */
            .gpu-accelerated {
                transform: translateZ(0);
                will-change: transform;
            }

            /* å“åº”å¼ä¼˜åŒ– */
            @media (max-width: 768px) {
                .mobile-optimized {
                    padding: 12px;
                    font-size: 14px;
                }

                .btn-mobile {
                    min-height: 44px;
                    /* iOSå»ºè®®çš„æœ€å°è§¦æ‘¸ç›®æ ‡ */
                    padding: 12px 16px;
                }
            }

            /* è€æµè§ˆå™¨å›é€€ */
            @supports not (backdrop-filter: blur(10px)) {
                .card-modern {
                    background: rgba(255, 255, 255, 0.98);
                }
            }
        </style>
    </head>

    <body class="min-h-screen bg-gradient-to-br from-blue-50 via-white to-rose-50">
        <div id="app" class="container mx-auto px-2 py-6 max-w-none w-[95vw]">
            <!-- ç°ä»£åŒ–çš„ä¸»å®¹å™¨ -->
            <main class="card-modern rounded-2xl p-8 gpu-accelerated" role="main">
                <!-- æ ‡é¢˜åŒº - å¢å¼ºå¯è®¿é—®æ€§ -->
                <header class="flex flex-col gap-4 mb-10 relative">
                    <div class="flex items-end gap-4 flex-wrap">
                        <h1
                            class="text-3xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent flex items-center gap-3">
                            <span
                                class="p-3 bg-gradient-to-br from-green-400 to-blue-500 rounded-xl text-white shadow-lg">
                                <i class="fa-solid fa-table" aria-hidden="true"></i>
                            </span>
                            è¡¨æ ¼ BOM å¯¹æ¯”åˆ†æå·¥å…·
                        </h1>
                        <span class="text-lg text-gray-600 font-medium">{{ subtitle }}</span>
                    </div>
                    <p class="text-gray-700 leading-relaxed">
                        ğŸš€ ä¸“ä¸šçš„BOMè¡¨æ ¼å¯¹æ¯”åˆ†æå·¥å…·ï¼Œæ”¯æŒå¯¼å…¥å¤šä»½æ•°æ®ï¼Œå¹¶å¯å¯¹æœ€å¤šä¸¤ä»½æ•°æ®è¿›è¡Œå³æ—¶å¯¹æ¯”ã€‚
                        <strong class="text-amber-600">âš ï¸ æ³¨æ„ï¼šå¯¼å…¥çš„æ–‡ä»¶å¿…é¡»è§£å¯†æ‰å¯ç”¨ã€‚</strong>
                    </p>

                    <!-- çŠ¶æ€å¾½ç« åŒº -->
                    <div class="absolute right-0 top-0 flex flex-col items-end gap-2" aria-live="polite">
                        <transition name="fadeout">
                            <div v-if="sheetBadge.show"
                                :class="['text-sm font-medium text-white px-4 py-2 rounded-full shadow-lg', sheetBadge.bgClass]"
                                role="status">
                                {{ sheetBadge.text }}
                            </div>
                        </transition>
                        <transition name="fadeout">
                            <div v-if="faBadge.show"
                                :class="['text-sm font-medium text-white px-4 py-2 rounded-full shadow-lg', faBadge.bgClass]"
                                role="status">
                                {{ faBadge.text }}
                            </div>
                        </transition>
                    </div>
                </header>
                <!-- æ–‡ä»¶å¯¼å…¥åŒº - å¢å¼ºçš„æ‹–æ‹½ä½“éªŒ -->
                <section class="mb-8" aria-labelledby="file-import-heading">
                    <h2 id="file-import-heading"
                        class="block mb-4 text-lg font-bold text-gray-800 flex items-center gap-2">
                        <i class="fa-solid fa-cloud-upload-alt text-blue-500" aria-hidden="true"></i>
                        æ–‡ä»¶å¯¼å…¥
                    </h2>
                    <div class="flex items-center gap-4 flex-wrap">
                        <input id="fileInput" type="file" multiple accept=".xlsx,.xls,.html,.htm" @change="handleFiles"
                            class="sr-only" aria-describedby="file-help" />
                        <label for="fileInput"
                            class="btn-modern px-6 py-3 rounded-xl bg-gradient-to-r from-blue-500 to-blue-600 text-white hover:from-blue-600 hover:to-blue-700 cursor-pointer font-semibold flex items-center gap-2 touch-friendly focus-visible"
                            tabindex="0" @keydown.enter="$refs.fileInput?.click()"
                            @keydown.space.prevent="$refs.fileInput?.click()">
                            <i class="fa-solid fa-folder-open" aria-hidden="true"></i>
                            é€‰æ‹©æ–‡ä»¶
                        </label>
                        <div class="flex flex-col gap-1">
                            <span class="text-sm font-medium text-gray-600">æ”¯æŒæ ¼å¼ï¼šExcel (.xlsx, .xls) å’Œ HTML (.html,
                                .htm)</span>
                            <span id="file-help" class="text-xs text-gray-500">ğŸ’¡ æ”¯æŒæ‰¹é‡å¯¼å…¥ï¼Œå¯åŒæ—¶é€‰æ‹©å¤šä¸ªæ–‡ä»¶</span>
                        </div>
                    </div>
                    <div v-if="loading"
                        class="mt-4 flex items-center gap-3 p-4 bg-blue-50 rounded-xl border border-blue-200"
                        role="status" aria-live="polite">
                        <div class="animate-spin w-5 h-5 border-2 border-blue-500 border-t-transparent rounded-full">
                        </div>
                        <span class="text-blue-700 font-medium">æ­£åœ¨è§£ææ–‡ä»¶ï¼Œè¯·ç¨å€™...</span>
                    </div>
                </section>
                <!-- æ–‡ä»¶åˆ—è¡¨åŒºï¼ˆæ»‘åŠ¨è¿›å…¥/ç¦»å¼€ 1sï¼‰ -->
                <transition name="slide-down">
                    <div v-if="fileList.length" class="mb-8 file-list-container p-4">
                        <div class="font-semibold mb-2 text-gray-700 flex items-center gap-2">
                            <div class="flex items-center gap-2 min-w-0">
                                <i class="fa-solid fa-list"></i>
                                <span class="whitespace-nowrap">å·²å¯¼å…¥æ–‡ä»¶ï¼ˆå…± {{ fileList.length }} ä¸ªï¼‰ï¼š</span>
                                <span class="truncate"
                                    :class="['text-sm', multiCompareMode ? 'text-red-600' : 'text-gray-500']">
                                    {{ multiCompareMode ? 'å‹¾é€‰å¤šä»½æ–‡ä»¶å¯¼å‡ºåˆ†åˆ«å¯¹æ¯”ç»“æœ' : 'å‹¾é€‰æ–‡ä»¶å³å¯é¢„è§ˆï¼ˆæœ€å¤šå¹¶åˆ—2ä¸ªï¼‰' }}
                                </span>
                            </div>
                            <div class="flex-1"></div>
                            <div class="ml-4 flex items-center gap-2">
                                <!-- å¤šæ–‡ä»¶å¯¹æ¯”å¯¼å‡ºæŒ‰é’®ï¼ˆå³ä¾§ï¼Œä½äºâ€œå…¨é€‰â€å·¦ä¾§ï¼‰ -->
                                <button type="button" :class="multiCompareMode
                                    ? 'px-2 py-1 text-xs rounded bg-red-600 text-white hover:bg-red-700'
                                    : 'px-2 py-1 text-xs rounded bg-blue-600 text-white hover:bg-blue-700'"
                                    @click="toggleMultiCompare">
                                    {{ multiCompareMode ? 'å–æ¶ˆå¤šé€‰' : 'å¤šæ–‡ä»¶å¯¹æ¯”å¯¼å‡º' }}
                                </button>
                                <!-- å…¨é€‰æŒ‰é’®ï¼šå ä½éšè—ä»¥é¿å…æŠ–åŠ¨ -->
                                <button type="button" :class="[
                                    'px-2 py-1 text-xs rounded border',
                                    multiCompareMode ? 'border-red-300 text-red-600 hover:bg-red-50' : 'invisible pointer-events-none border-transparent'
                                ]" @click="selectAllFiles">
                                    å…¨é€‰
                                </button>
                            </div>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
                            <label v-for="(file, idx) in fileList" :key="file.name"
                                class="file-item flex items-center gap-2 cursor-pointer bg-blue-50 hover:bg-blue-100 rounded px-2 py-1"
                                :class="{ 'selected': selectedFiles.includes(file.name) }">
                                <input type="checkbox" :checked="selectedFiles.includes(file.name)"
                                    @change="onFileCheckboxChange(file.name, $event.target.checked, file.status)"
                                    :disabled="file.status === 'error'" class="accent-blue-500" />
                                <span class="truncate"><i
                                        class="fa-solid fa-file-excel text-green-500 mr-1"></i>{{ file.name }}</span>
                                <span class="text-xs text-gray-400">({{ file.rows }} è¡Œ)</span>
                                <span class="ml-2">
                                    <i v-if="file.status === 'pending'"
                                        class="fa-solid fa-spinner fa-spin text-blue-400"></i>
                                    <i v-else-if="file.status === 'success'"
                                        class="fa-solid fa-check text-green-500"></i>
                                    <i v-else-if="file.status === 'error'"
                                        class="fa-solid fa-circle-exclamation text-red-500" title="è§£æå¤±è´¥"></i>
                                </span>
                                <span v-if="file.status === 'error'"
                                    class="text-xs text-red-500 ml-2">{{ file.errorMsg }}</span>
                                <button type="button" @click.stop="removeFile(idx)"
                                    class="ml-2 px-2 py-1 text-xs text-red-500 hover:text-white hover:bg-red-500 rounded transition"><i
                                        class="fa-solid fa-trash"></i> åˆ é™¤</button>
                            </label>
                        </div>
                        <div class="mt-2 text-xs" :class="multiCompareMode ? 'text-red-600' : 'text-gray-500'">
                            {{ multiCompareMode ? 'å‹¾é€‰å¤šä»½æ–‡ä»¶å¯¼å‡ºåˆ†åˆ«å¯¹æ¯”ç»“æœ' : 'å‹¾é€‰æ–‡ä»¶è¿›è¡Œé¢„è§ˆï¼ˆæœ€å¤šå¹¶åˆ—2ä¸ªï¼‰' }}
                        </div>
                    </div>
                </transition>
                <!-- å¯¹æ¯”ä»»åŠ¡å¼€å…³ + å›¾ä¾‹ + å¯¼å‡ºæŒ‰é’® -->
                <div class="mb-4 flex items-center justify-between gap-4 flex-wrap">
                    <div class="flex items-center gap-3 flex-wrap">
                        <button type="button" @click="toggleCompare"
                            :disabled="(selectedFiles.length !== 2 && !compareMode) || compareBusy"
                            class="px-3 py-1.5 rounded text-sm font-medium shadow transition flex items-center gap-2"
                            :class="compareBusy ? 'bg-gray-400 text-white cursor-wait' : (compareMode ? 'bg-red-600 text-white hover:bg-red-700' : (selectedFiles.length !== 2 ? 'bg-gray-200 text-gray-400 cursor-not-allowed' : 'bg-blue-600 text-white hover:bg-blue-700'))">
                            <i v-if="compareBusy" class="fa-solid fa-spinner fa-spin"></i>
                            <i v-else :class="compareMode ? 'fa-solid fa-toggle-on' : 'fa-solid fa-toggle-off'"></i>
                            <span>{{ compareBusy ? 'åˆ†æä¸­...' : (compareMode ? 'å…³é—­å¯¹æ¯”' : 'å¯åŠ¨å¯¹æ¯”') }}</span>
                        </button>
                        <span v-if="selectedFiles.length !== 2" class="text-xs text-gray-400">éœ€é€‰æ‹©2ä¸ªæ–‡ä»¶</span>
                        <!-- è‰²å—å›¾ä¾‹ -->
                        <div class="flex items-center gap-3 text-xs text-gray-600">
                            <span class="inline-flex items-center gap-2"><span
                                    class="w-3 h-3 inline-block rounded bg-red-600"></span>è¯¥è¡Œæœªåœ¨å¯¹è¡¨ä¸­æ‰¾åˆ°</span>
                            <span class="inline-flex items-center gap-2"><span
                                    class="w-3 h-3 inline-block rounded bg-orange-500"></span>è¯¥è¡Œè™½æœªæ‰¾åˆ°ï¼Œä½†ä¾›åº”å•†é›¶ä»¶å·åŒ¹é…</span>
                            <span class="inline-flex items-center gap-2"><span
                                    class="w-3 h-3 inline-block rounded bg-blue-600"></span>è¯¥è¡Œåœ¨å¯¹è¡¨æ‰¾åˆ°ï¼Œä½†æ•°é‡ä¸åŒ</span>
                            <span class="inline-flex items-center gap-2"><span
                                    class="w-3 h-3 inline-block rounded bg-green-600"></span>è¯¥è¡Œä¸å¯¹è¡¨ä¸­æ•°æ®ä¸€è‡´</span>
                        </div>
                    </div>
                    <div>
                        <button type="button" @click="exportCompare" :class="[
                            'px-3 py-1.5 rounded text-sm font-medium shadow transition bg-emerald-600 text-white hover:bg-emerald-700',
                            (selectedFiles.length > 0 && sheetReady) ? '' : 'invisible pointer-events-none'
                        ]" :aria-hidden="!(selectedFiles.length > 0 && sheetReady)"
                            :tabindex="(selectedFiles.length > 0 && sheetReady) ? 0 : -1" title="å¯¼å‡ºæ•°æ®">
                            <i class="fa-solid fa-file-arrow-down mr-1"></i>
                            å¯¼å‡ºæ•°æ®
                        </button>
                    </div>
                </div>
                <!-- å¹¶åˆ—é¢„è§ˆåŒº - ä¼˜åŒ–åŠ¨ç”»æ•ˆæœ -->
                <transition name="slide-up" @before-enter="onBeforeEnter" @enter="onEnter" @after-enter="onAfterEnter"
                    @before-leave="onBeforeLeave" @leave="onLeave" @after-leave="onPreviewContainerAfterLeave">
                    <div v-if="containerVisible" ref="previewWrap" class="w-full">
                        <div class="w-full preview-container">
                            <transition-group name="preview-list" tag="div"
                                class="flex w-full flex-wrap gap-6 relative">
                                <div v-for="(fileName, idx) in displayedSelectedFiles" :key="fileName"
                                    class="preview-card p-4" :style="cardStyle(idx, fileName)">
                                    <div
                                        v-if="getTable(fileName) && Array.isArray(getTable(fileName).columns) && Array.isArray(getTable(fileName).data)">
                                        <div class="flex items-center justify-between mb-2">
                                            <span class="font-semibold text-blue-600"><i
                                                    class="fa-solid fa-file-excel text-green-500 mr-1"></i>{{ fileName }}</span>
                                            <div class="flex items-center gap-2">
                                                <div v-if="compareMode" class="flex items-center gap-1">
                                                    <label class="text-xs text-gray-500 mr-2">ç‚¹å‡»å³ä¾§è‰²å—ç­›é€‰</label>
                                                    <button type="button" :class="badgeClass(fileName, 'red')"
                                                        title="ç‚¹å‡»ç­›é€‰ä»…åœ¨å¯¹è¡¨ä¸­æœªæ‰¾åˆ°çš„è¡Œ"
                                                        @click.stop="toggleColorFilter(fileName, 'red')">{{ categoryCounts(fileName).red }}</button>
                                                    <button type="button" :class="badgeClass(fileName, 'orange')"
                                                        title="ç‚¹å‡»ç­›é€‰æœªæ‰¾åˆ°ä½†ä»…åœ¨å¯¹è¡¨ä¸­ä¾›åº”å•†é›¶ä»¶å·åŒ¹é…çš„è¡Œ"
                                                        @click.stop="toggleColorFilter(fileName, 'orange')">{{ categoryCounts(fileName).orange }}</button>
                                                    <button type="button" :class="badgeClass(fileName, 'blue')"
                                                        title="ç‚¹å‡»ç­›é€‰ä»…åœ¨å¯¹è¡¨ä¸­æ•°é‡ä¸åŒçš„è¡Œ"
                                                        @click.stop="toggleColorFilter(fileName, 'blue')">{{ categoryCounts(fileName).blue }}</button>
                                                    <button type="button" :class="badgeClass(fileName, 'green')"
                                                        title="ç‚¹å‡»ç­›é€‰ä»…åœ¨å¯¹è¡¨ä¸­æ•°é‡ç›¸åŒçš„è¡Œ"
                                                        @click.stop="toggleColorFilter(fileName, 'green')">{{ categoryCounts(fileName).green }}</button>
                                                </div>
                                                <span v-if="hasActiveFilters(fileName)"
                                                    class="text-xs text-blue-600">ç­›é€‰å
                                                    {{ filteredRows(fileName).length }} è¡Œ</span>
                                                <span class="text-xs text-gray-700">å…±
                                                    {{ getTable(fileName).data.length }}
                                                    è¡Œ</span>
                                            </div>
                                        </div>
                                        <div class="overflow-auto table-container">
                                            <table class="min-w-full text-sm border border-gray-200 rounded-lg">
                                                <thead>
                                                    <tr class="bg-blue-50">
                                                        <th v-for="col in getTable(fileName).columns" :key="col"
                                                            class="px-2 py-1 font-medium text-gray-700 border-b relative">
                                                            <div class="flex items-center gap-2">
                                                                <span class="truncate" :title="col">{{ col }}</span>
                                                                <button type="button"
                                                                    class="text-gray-500 hover:text-blue-600 filter-btn"
                                                                    :data-filter-key="fileName + '__' + col"
                                                                    @click.stop="toggleFilterDropdown(fileName, col, $event)"
                                                                    :title="isColumnFiltered(fileName, col) ? 'å·²ç­›é€‰' : 'ç­›é€‰'">
                                                                    <i class="fa-solid fa-filter"></i>
                                                                    <span v-if="isColumnFiltered(fileName, col)"
                                                                        class="inline-block w-1.5 h-1.5 rounded-full bg-blue-600 ml-1"></span>
                                                                </button>
                                                            </div>
                                                            <!-- ä¸‹æ‹‰ç­›é€‰é¢æ¿ -->
                                                            <teleport to="body">
                                                                <div v-if="isDropdownOpen(fileName, col)"
                                                                    class="filter-dropdown filter-panel fixed z-[10000] bg-white border rounded shadow-lg w-64 p-2"
                                                                    :style="dropdownStyle(fileName, col)">
                                                                    <div class="mb-2">
                                                                        <input type="text"
                                                                            class="w-full border rounded px-2 py-1 text-xs"
                                                                            placeholder="æœç´¢..."
                                                                            v-model="getFilterState(fileName, col).search">
                                                                    </div>
                                                                    <div class="flex items-center gap-2 mb-2">
                                                                        <button type="button"
                                                                            class="text-xs px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded"
                                                                            @click.stop="selectAllValues(fileName, col)">å…¨é€‰</button>
                                                                        <button type="button"
                                                                            class="text-xs px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded"
                                                                            @click.stop="clearAllValues(fileName, col)">æ¸…ç©º</button>
                                                                    </div>
                                                                    <div
                                                                        class="max-h-56 overflow-auto border rounded p-1 text-sm">
                                                                        <label
                                                                            v-for="val in filteredDistinctValues(fileName, col)"
                                                                            :key="val"
                                                                            class="flex items-center gap-2 px-1 py-0.5 hover:bg-gray-50 cursor-pointer">
                                                                            <input type="checkbox"
                                                                                :checked="isValueChecked(fileName, col, val)"
                                                                                @change="onToggleValue(fileName, col, val, $event.target.checked)">
                                                                            <span class="truncate"
                                                                                :title="val || '(ç©º)'">{{ val || '(ç©º)' }}</span>
                                                                        </label>
                                                                    </div>
                                                                    <div class="flex justify-end gap-2 mt-2">
                                                                        <button
                                                                            class="text-xs px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded"
                                                                            @click.stop="closeDropdown(fileName, col)">å–æ¶ˆ</button>
                                                                        <button
                                                                            class="text-xs px-2 py-1 bg-blue-600 text-white hover:bg-blue-700 rounded"
                                                                            @click.stop="applyFilter(fileName, col)">ç¡®å®š</button>
                                                                    </div>
                                                                </div>
                                                            </teleport>
                                                        </th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr v-for="(row, rIdx) in filteredRows(fileName)" :key="rIdx"
                                                        :class="['transition hover:bg-blue-100', compareMode ? rowBgClass(fileName, row) : '']">
                                                        <td v-for="col in getTable(fileName).columns" :key="col"
                                                            class="px-2 py-1 border-b">
                                                            {{ (row && typeof row === 'object' && col in row) ? row[col] : '' }}
                                                        </td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </div>
                                        <!-- å¯¼çº¿æ•°é‡å·®å€¼ï¼ˆä»…åœ¨å¯¹æ¯”æ¨¡å¼ï¼‰ -->
                                        <div v-if="compareMode" class="mt-3 border-t pt-2">
                                            <div class="text-sm font-medium text-gray-700 mb-1 flex items-center gap-2">
                                                <i class="fa-solid fa-code-compare text-blue-500"></i>å¯¼çº¿æ•°é‡å·®å€¼
                                            </div>
                                            <div v-if="wiresDiff(fileName).length === 0" class="text-xs text-gray-400">
                                                æ— å·®å¼‚æˆ–æ— å¯¼çº¿ç±»å‹
                                            </div>
                                            <div v-else class="overflow-auto">
                                                <table class="min-w-full text-xs border border-gray-200 rounded">
                                                    <thead>
                                                        <tr class="bg-gray-50">
                                                            <th class="px-2 py-1 border-b text-left">é›¶ä»¶å·</th>
                                                            <th class="px-2 py-1 border-b text-left">ç±»å‹</th>
                                                            <th class="px-2 py-1 border-b text-right">æœ¬è¡¨æ•°é‡</th>
                                                            <th class="px-2 py-1 border-b text-right">å¯¹è¡¨æ•°é‡</th>
                                                            <th class="px-2 py-1 border-b text-right">å·®å€¼(æœ¬-å¯¹)</th>
                                                        </tr>
                                                    </thead>
                                                    <tbody>
                                                        <tr v-for="(d, i) in wiresDiff(fileName)" :key="i">
                                                            <td class="px-2 py-1 border-b">{{ d.pn }}</td>
                                                            <td class="px-2 py-1 border-b">{{ d.type }}</td>
                                                            <td class="px-2 py-1 border-b text-right">{{ d.q1 }}
                                                            </td>
                                                            <td class="px-2 py-1 border-b text-right">{{ d.q2 }}
                                                            </td>
                                                            <td class="px-2 py-1 border-b text-right"
                                                                :class="d.diff === 0 ? 'text-gray-500' : (d.diff > 0 ? 'text-green-600' : 'text-red-600')">
                                                                {{ d.diff }}
                                                            </td>
                                                        </tr>
                                                    </tbody>
                                                </table>
                                            </div>
                                        </div>
                                    </div>
                                    <div v-else class="text-red-500 text-sm">è¡¨æ ¼æ•°æ®ä¸å­˜åœ¨æˆ–å·²è¢«åˆ é™¤</div>
                            </transition-group>
                        </div>
                    </div>
                </transition>
                <!-- è§†å£å›åˆ°é¡¶éƒ¨æŒ‰é’®ï¼ˆTeleport åˆ° bodyï¼Œç¡®ä¿è´´å¯è§†åŒºå³ä¸‹è§’ï¼‰ -->
                <teleport to="body">
                    <div
                        :class="['fixed bottom-0 right-0 z-[9999] transform transition-all duration-300', showTop ? 'translate-x-0 opacity-100' : 'translate-x-24 opacity-0 pointer-events-none']">
                        <button @click="scrollToTop" aria-label="å›åˆ°é¡¶éƒ¨" title="å›åˆ°é¡¶éƒ¨"
                            class="w-8 h-8 rounded-lg bg-blue-600 text-white shadow-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-300 flex items-center justify-center">
                            <i class="fa-solid fa-arrow-up text-xs"></i>
                        </button>
                    </div>
                </teleport>
                <script>
                    const { createApp, ref, reactive, onMounted, onUnmounted, watch, nextTick } = Vue;
                    createApp({
                        setup() {
                            // ======================== æ ¸å¿ƒçŠ¶æ€ä¸å¸¸é‡ ========================
                            const tables = reactive([]);
                            const fileList = reactive([]);
                            const selectedFiles = ref([]);

                            // é€šç”¨å¸¸é‡å®šä¹‰
                            const HEADER_TOKENS = new Set(['é›¶ä»¶å·', 'ä¾›åº”å•†é›¶ä»¶å·', 'å®¢æˆ·é›¶ä»¶å·']);
                            const COLUMN_NAMES = {
                                PART_NUMBER: 'é›¶ä»¶å·',
                                SUPPLIER_PART_NUMBER: 'ä¾›åº”å•†é›¶ä»¶å·',
                                CUSTOMER_PART_NUMBER: 'å®¢æˆ·é›¶ä»¶å·',
                                QUANTITY: 'æ•°é‡',
                                TYPE: 'ç±»å‹'
                            };
                            const WIRE_TYPES = new Set(['WIRE', 'çº¿æŸ', 'å¯¼çº¿']);
                            const COLOR_TO_PRIORITY = { red: 0, orange: 1, blue: 2, green: 3 };

                            // ======================== é€šç”¨å·¥å…·å‡½æ•° ========================

                            // æ•°å­—è½¬æ¢å‡½æ•°ï¼ˆå¤„ç†åƒä½åˆ†éš”ç¬¦ï¼Œç©ºå€¼è½¬0ï¼‰
                            function toNumber(v) {
                                if (v == null || v === '') return 0;
                                const n = parseFloat(String(v).replace(/,/g, ''));
                                return isNaN(n) ? 0 : n;
                            }

                            // è§„èŒƒåŒ–é”®åå‡½æ•°ï¼ˆé›¶ä»¶å·ä¸“ç”¨ï¼‰
                            function normalizeKey(key) {
                                if (key == null) return '';
                                let s = String(key);
                                s = s.replace(/[\u200B-\u200D\uFEFF\u00AD]/g, '');
                                s = s.replace(/[\s\u00A0]+/g, '').trim();
                                return s;
                            }

                            // é”™è¯¯å¤„ç†å·¥å…·
                            function handleError(error, context = '') {
                                console.error(`Error ${context}:`, error);
                                const message = error?.message || String(error) || 'Unknown error';
                                alert(`æ“ä½œå¤±è´¥${context ? ' (' + context + ')' : ''}: ${message}`);
                            }

                            // ======================== é€šç”¨å­—ç¬¦ä¸²å¤„ç† ========================

                            // å®‰å…¨çš„å­—ç¬¦ä¸²æå–ï¼ˆå¤„ç†null/undefinedï¼Œè‡ªåŠ¨trimï¼‰
                            function safeString(value) {
                                return value != null ? String(value).trim() : '';
                            }

                            // å®‰å…¨è·å–å¯¹è±¡å±æ€§çš„å­—ç¬¦ä¸²å€¼
                            function getStringProp(obj, prop) {
                                return safeString(obj && obj[prop]);
                            }

                            // æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦ä¸ºç©ºï¼ˆnullã€undefinedã€ç©ºå­—ç¬¦ä¸²ã€åªåŒ…å«ç©ºç™½ï¼‰
                            function isEmpty(str) {
                                return !str || !String(str).trim();
                            }

                            // å®‰å…¨æ‰§è¡Œå‡½æ•°ï¼ˆç»Ÿä¸€å¼‚å¸¸å¤„ç†ï¼‰
                            function safeExecute(fn, defaultValue = null, context = '') {
                                try {
                                    return fn();
                                } catch (err) {
                                    if (context) {
                                        console.warn(`Safe execution failed (${context}):`, err);
                                    }
                                    return defaultValue;
                                }
                            }

                            // å¼‚æ­¥å®‰å…¨æ‰§è¡Œ
                            async function safeExecuteAsync(fn, defaultValue = null, context = '') {
                                try {
                                    return await fn();
                                } catch (err) {
                                    if (context) {
                                        console.warn(`Async safe execution failed (${context}):`, err);
                                    }
                                    return defaultValue;
                                }
                            }

                            // ======================== æ–‡ä»¶è§£æå·¥å…·å‡½æ•° ========================

                            // ç”Ÿæˆå”¯ä¸€æ–‡ä»¶åï¼ˆæ”¯æŒé‡å¤å¯¼å…¥ï¼Œè‡ªåŠ¨æ·»åŠ åç¼€ï¼‰
                            function generateUniqueFileName(originalName) {
                                let displayName = originalName;
                                let counter = 2;
                                while (fileList.some(f => f.name === displayName)) {
                                    displayName = `${originalName} (${counter})`;
                                    counter++;
                                }
                                return displayName;
                            }

                            // æ£€æŸ¥æ˜¯å¦ä¸ºè¡¨å¤´è¡Œï¼ˆåŒ…å«æŒ‡å®šçš„ä»¤ç‰Œï¼‰
                            function isHeaderRow(cellData) {
                                const firstCellText = String(cellData[0] || '').trim();
                                return HEADER_TOKENS.has(firstCellText);
                            }

                            // æ¸…ç†æ•°æ®è¡Œï¼ˆç§»é™¤æ— æ•ˆè¡Œï¼‰
                            function cleanDataRows(rows, columns) {
                                return rows.filter(row => {
                                    if (!row || typeof row !== 'object') return false;

                                    const firstCol = String(row[columns[0]] || '').trim();

                                    // è·³è¿‡ç©ºè¡Œã€è¡¨å¤´è¡Œã€Designå¼€å¤´çš„è¡Œ
                                    if (!firstCol || HEADER_TOKENS.has(firstCol) || firstCol.startsWith('Design')) {
                                        return false;
                                    }

                                    return true;
                                });
                            }

                            // å¤„ç†é›¶ä»¶å·å¡«å……å’Œæ•°æ®æ¸…ç†
                            function processPartNumbers(rows, columns) {
                                try {
                                    if (!columns.includes(COLUMN_NAMES.PART_NUMBER)) {
                                        columns.unshift(COLUMN_NAMES.PART_NUMBER);
                                    }

                                    const hasPN = columns.includes(COLUMN_NAMES.PART_NUMBER);
                                    const hasSPN = columns.includes(COLUMN_NAMES.SUPPLIER_PART_NUMBER);

                                    if (!hasPN && !hasSPN) return rows;

                                    return rows.filter((row, index) => {
                                        try {
                                            const pn0 = row[COLUMN_NAMES.PART_NUMBER];
                                            const spn0 = row[COLUMN_NAMES.SUPPLIER_PART_NUMBER];
                                            const pn = normalizeKey(pn0);
                                            const spn = normalizeKey(spn0);

                                            // å¦‚æœé›¶ä»¶å·å’Œä¾›åº”å•†é›¶ä»¶å·éƒ½ä¸ºç©ºï¼Œä¸¢å¼ƒè¯¥è¡Œ
                                            if (!pn && !spn) return false;

                                            // å¦‚æœé›¶ä»¶å·ä¸ºç©ºä½†ä¾›åº”å•†é›¶ä»¶å·æœ‰å€¼ï¼Œå¡«å……é›¶ä»¶å·
                                            if (!pn && spn) {
                                                row[COLUMN_NAMES.PART_NUMBER] = spn0;
                                            }

                                            return true;
                                        } catch (err) {
                                            console.warn(`å¤„ç†ç¬¬${index + 1}è¡Œé›¶ä»¶å·æ•°æ®æ—¶å‡ºé”™:`, err.message);
                                            return false; // è·³è¿‡æœ‰é—®é¢˜çš„è¡Œ
                                        }
                                    });
                                } catch (err) {
                                    throw new Error(`é›¶ä»¶å·å¤„ç†å¤±è´¥: ${err.message}`);
                                }
                            }

                            // å¤„ç†å¯¼çº¿ç±»å‹çš„ä¸‰æ®µå·è§„èŒƒåŒ–
                            function processWireTypes(rows, columns) {
                                const colPN = columns.find(c => c === COLUMN_NAMES.PART_NUMBER);
                                const colType = columns.find(c => c && c.includes(COLUMN_NAMES.TYPE));

                                if (!colPN || !colType) return;

                                const TYPE_SET = WIRE_TYPES;

                                rows.forEach(r => {
                                    const t = r && r[colType];
                                    const aVal = r && r[colPN];
                                    const aStr = (aVal == null ? '' : String(aVal)).trim();

                                    if (TYPE_SET.has(String(t).trim())) {
                                        const parts = aStr.split('-');
                                        if (parts.length === 3) {
                                            r[colPN] = parts[0] + '-' + parts[1];
                                        }
                                    }
                                });
                            }

                            // æŒ‰é›¶ä»¶å·èšåˆæ•°æ®
                            function aggregateByPartNumber(rows, columns) {
                                try {
                                    const colPN = columns.find(c => c === COLUMN_NAMES.PART_NUMBER);
                                    const colQty = columns.find(c => c && c.includes(COLUMN_NAMES.QUANTITY));

                                    if (!colPN || !colQty) return rows;

                                    const map = new Map();
                                    rows.forEach((row, index) => {
                                        try {
                                            const key = String((row && row[colPN]) ?? '').trim();
                                            if (!key) {
                                                console.warn(`ç¬¬${index + 1}è¡Œ: é›¶ä»¶å·ä¸ºç©ºï¼Œè·³è¿‡èšåˆ`);
                                                return;
                                            }

                                            if (!map.has(key)) {
                                                const base = { ...row };
                                                const qtyValue = toNumber(base[colQty]);
                                                if (isNaN(qtyValue)) {
                                                    console.warn(`ç¬¬${index + 1}è¡Œ: æ•°é‡å€¼"${base[colQty]}"æ— æ³•è½¬æ¢ä¸ºæ•°å­—ï¼Œä½¿ç”¨0æ›¿ä»£`);
                                                    base[colQty] = 0;
                                                } else {
                                                    base[colQty] = qtyValue;
                                                }
                                                map.set(key, base);
                                            } else {
                                                const agg = map.get(key);
                                                const currentQty = toNumber(agg[colQty]);
                                                const addQty = toNumber(row[colQty]);
                                                agg[colQty] = currentQty + addQty;
                                            }
                                        } catch (err) {
                                            console.warn(`å¤„ç†ç¬¬${index + 1}è¡Œèšåˆæ—¶å‡ºé”™:`, err.message);
                                        }
                                    });

                                    return Array.from(map.values());
                                } catch (err) {
                                    throw new Error(`æ•°æ®èšåˆå¤±è´¥: ${err.message}`);
                                }
                            }

                            // ======================== HTMLè§£æå·¥å…·å‡½æ•° ========================

                            // è§£æHTMLä¸­çš„è¡¨æ ¼æ•°æ®
                            function parseHTMLTables(htmlText) {
                                const parser = new DOMParser();
                                const doc = parser.parseFromString(htmlText, 'text/html');
                                const tables = doc.querySelectorAll('table');

                                const allRows = [];
                                const detectedCols = [];

                                tables.forEach((table, idx) => {
                                    try {
                                        const tableRows = table.querySelectorAll('tr');
                                        const matrix = Array.from(tableRows).map(tr => {
                                            const tds = tr.querySelectorAll('td, th');
                                            const texts = Array.from(tds).map(td => (td.textContent || '').trim());
                                            const hasMerge = Array.from(tds).some(td => {
                                                const cs = parseInt(td.getAttribute('colspan') || '1', 10);
                                                const rs = parseInt(td.getAttribute('rowspan') || '1', 10);
                                                return (cs > 1 || rs > 1);
                                            });
                                            return { texts, hasMerge };
                                        });

                                        const hdrIdx = matrix.findIndex(r => r.texts[0] && HEADER_TOKENS.has(r.texts[0].trim()));
                                        if (hdrIdx === -1) return; // éæ•°æ®è¡¨

                                        const headers = matrix[hdrIdx].texts.map(s => String(s).trim());
                                        headers.forEach(c => {
                                            if (c && !detectedCols.includes(c)) detectedCols.push(c);
                                        });

                                        // å¤„ç†æ•°æ®è¡Œ
                                        for (let i = hdrIdx + 1; i < matrix.length; i++) {
                                            const r = matrix[i];
                                            const first = (r.texts[0] || '').trim();

                                            if (HEADER_TOKENS.has(first) || r.hasMerge || first.startsWith('Design')) {
                                                continue;
                                            }

                                            const rowData = {};
                                            headers.forEach((h, idx2) => {
                                                rowData[h] = r.texts[idx2] != null ? String(r.texts[idx2]).trim() : '';
                                            });
                                            allRows.push(rowData);
                                        }
                                    } catch (err) {
                                        console.warn('è§£æHTMLè¡¨æ ¼å¤±è´¥ï¼Œå·²è·³è¿‡: è¡¨ç´¢å¼•', idx, err);
                                    }
                                });

                                return { rows: allRows, columns: detectedCols };
                            }

                            // ======================== Excelè§£æå·¥å…·å‡½æ•° ========================

                            // è§£æExcelæ–‡ä»¶æ•°æ®
                            async function parseExcelFile(fileBuffer, fileName) {
                                try {
                                    const workbook = new ExcelJS.Workbook();
                                    await workbook.xlsx.load(fileBuffer);

                                    const ws = workbook.worksheets[0];
                                    if (!ws) throw new Error('å·¥ä½œè¡¨ä¸ºç©º');

                                    const grid = [];
                                    const mergedRanges = new Set();

                                    // å¤„ç†åˆå¹¶å•å…ƒæ ¼
                                    ws.mergeCells && Object.keys(ws.mergeCells).forEach(range => {
                                        const match = range.match(/^([A-Z]+)(\d+):([A-Z]+)(\d+)$/);
                                        if (match) {
                                            const [, startCol, startRow, endCol, endRow] = match;
                                            const startColNum = columnToNumber(startCol);
                                            const endColNum = columnToNumber(endCol);
                                            for (let r = parseInt(startRow); r <= parseInt(endRow); r++) {
                                                for (let c = startColNum; c <= endColNum; c++) {
                                                    mergedRanges.add(`${r}-${c}`);
                                                }
                                            }
                                        }
                                    });

                                    // è¯»å–æ‰€æœ‰å•å…ƒæ ¼æ•°æ®
                                    let maxRow = 0, maxCol = 0;
                                    ws.eachRow({ includeEmpty: true }, (row, rowNumber) => {
                                        maxRow = Math.max(maxRow, rowNumber);
                                        row.eachCell({ includeEmpty: true }, (cell, colNumber) => {
                                            maxCol = Math.max(maxCol, colNumber);
                                            if (!grid[rowNumber]) grid[rowNumber] = [];
                                            const val = cell.value;
                                            grid[rowNumber][colNumber] = val != null ? String(val).trim() : '';
                                        });
                                    });

                                    // æŸ¥æ‰¾è¡¨å¤´
                                    let headerRowIndex = -1;
                                    let headers = [];
                                    for (let r = 1; r <= maxRow; r++) {
                                        const row = grid[r] || [];
                                        const firstCell = row[1] || '';
                                        if (HEADER_TOKENS.has(firstCell.trim())) {
                                            headerRowIndex = r;
                                            headers = row.slice(1).map(cell => String(cell || '').trim()).filter(h => h);
                                            break;
                                        }
                                    }

                                    if (headerRowIndex === -1) {
                                        // å›é€€ç­–ç•¥ï¼šä½¿ç”¨åˆ—ç´¢å¼•ä½œä¸ºåˆ—å
                                        headers = [];
                                        for (let c = 1; c <= maxCol; c++) {
                                            headers.push(`åˆ—${c}`);
                                        }
                                        headerRowIndex = 0;
                                    }

                                    // æå–æ•°æ®è¡Œ
                                    const rows = [];
                                    for (let r = headerRowIndex + 1; r <= maxRow; r++) {
                                        const row = grid[r] || [];
                                        const firstCell = (row[1] || '').trim();

                                        // è·³è¿‡æ— æ•ˆè¡Œ
                                        const hasMergedCell = row.some((_, colIdx) =>
                                            colIdx > 0 && mergedRanges.has(`${r}-${colIdx}`)
                                        );

                                        if (!firstCell ||
                                            HEADER_TOKENS.has(firstCell) ||
                                            firstCell.startsWith('Design') ||
                                            hasMergedCell) {
                                            continue;
                                        }

                                        const rowData = {};
                                        headers.forEach((header, idx) => {
                                            rowData[header] = row[idx + 1] != null ? String(row[idx + 1]).trim() : '';
                                        });
                                        rows.push(rowData);
                                    }

                                    return { rows, columns: headers };
                                } catch (err) {
                                    throw new Error(`Excelè§£æå¤±è´¥: ${err.message}`);
                                }
                            }

                            // åˆ—åè½¬æ•°å­—ï¼ˆA=1, B=2, etcï¼‰
                            function columnToNumber(col) {
                                let result = 0;
                                for (let i = 0; i < col.length; i++) {
                                    result = result * 26 + (col.charCodeAt(i) - 64);
                                }
                                return result;
                            }

                            // ======================== æ•°æ®å¤„ç†æµæ°´çº¿ ========================

                            // å¯¹åŸå§‹æ•°æ®æ‰§è¡Œå®Œæ•´çš„å¤„ç†æµç¨‹
                            function processRawData(rawRows, rawColumns) {
                                try {
                                    // 1. é›¶ä»¶å·å¡«å……å’Œæ•°æ®æ¸…ç†
                                    let rows = processPartNumbers(rawRows, rawColumns);
                                    let columns = [...rawColumns];

                                    // 2. å¯¼çº¿ç±»å‹è§„èŒƒåŒ–
                                    processWireTypes(rows, columns);

                                    // 3. æŒ‰é›¶ä»¶å·èšåˆ
                                    rows = aggregateByPartNumber(rows, columns);

                                    // 4. æ’åºï¼ˆæŒ‰é›¶ä»¶å·è‡ªç„¶å‡åºï¼‰
                                    const colPN = columns.find(c => c === COLUMN_NAMES.PART_NUMBER);
                                    if (colPN) {
                                        rows.sort((a, b) => {
                                            const aVal = String(a[colPN] || '').trim();
                                            const bVal = String(b[colPN] || '').trim();
                                            return aVal.localeCompare(bVal, undefined, {
                                                numeric: true,
                                                sensitivity: 'accent'
                                            });
                                        });
                                    }

                                    return { rows, columns };
                                } catch (err) {
                                    console.error('æ•°æ®å¤„ç†å¤±è´¥:', err);
                                    throw new Error(`æ•°æ®æ¸…æ´—å¤±è´¥: ${err.message || 'æœªçŸ¥é”™è¯¯'}`);
                                }
                            }

                            // ======================== å¯¼å‡ºå·¥å…·å‡½æ•° ========================

                            // Excelæ ·å¼å¸¸é‡
                            const EXCEL_COLORS = {
                                LIGHT_GRAY: 'FFF0F0F0',
                                RED: 'FFFF9999',
                                ORANGE: 'FFFFCC99',
                                BLUE: 'FF99CCFF',
                                GREEN: 'FF99FF99'
                            };

                            // åˆ›å»ºçº¯è‰²å¡«å……
                            function createSolidFill(color) {
                                return { type: 'pattern', pattern: 'solid', fgColor: { argb: color } };
                            }

                            // åº”ç”¨è¾¹æ¡†åˆ°æŒ‡å®šèŒƒå›´
                            function applyBordersToRange(worksheet, startRow, startCol, endRow, endCol) {
                                for (let r = startRow; r <= endRow; r++) {
                                    for (let c = startCol; c <= endCol; c++) {
                                        const cell = worksheet.getCell(r, c);
                                        cell.border = {
                                            top: { style: 'thin' },
                                            left: { style: 'thin' },
                                            bottom: { style: 'thin' },
                                            right: { style: 'thin' }
                                        };
                                    }
                                }
                            }

                            // è‡ªåŠ¨è°ƒæ•´åˆ—å®½
                            function autoFitColumns(worksheet) {
                                worksheet.columns.forEach(column => {
                                    let maxLength = 0;
                                    column.eachCell({ includeEmpty: true }, (cell) => {
                                        const length = cell.value ? String(cell.value).length : 0;
                                        maxLength = Math.max(maxLength, length);
                                    });
                                    column.width = Math.min(Math.max(maxLength + 2, 10), 50);
                                });
                            }

                            // æ¸…ç†æ–‡ä»¶åç”¨äºExcelå·¥ä½œè¡¨
                            function sanitizeSheetName(name, usedNames) {
                                let cleaned = String(name).replace(/[\\\/:\*\?\[\]]/g, '_');
                                cleaned = cleaned.substring(0, 31); // Excelå·¥ä½œè¡¨åé™åˆ¶

                                let candidate = cleaned;
                                let counter = 1;
                                while (usedNames.has(candidate)) {
                                    const suffix = `_${counter}`;
                                    const maxBase = 31 - suffix.length;
                                    candidate = cleaned.substring(0, maxBase) + suffix;
                                    counter++;
                                }
                                usedNames.add(candidate);
                                return candidate;
                            }

                            // æ¸…ç†æ–‡ä»¶åç”¨äºä¸‹è½½
                            function sanitizeFileName(name) {
                                return String(name).replace(/[\\\/:\*\?\[\]<>|"]/g, '_');
                            }

                            // ä¸‹è½½å·¥ä½œç°¿
                            async function downloadWorkbook(workbook, filename) {
                                const buffer = await workbook.xlsx.writeBuffer();
                                const blob = new Blob([buffer], {
                                    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                                });
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = sanitizeFileName(filename);
                                a.click();
                                URL.revokeObjectURL(url);
                            }
                            // é¢„è§ˆå®¹å™¨æ˜¾ç¤ºæ§åˆ¶ï¼šä¸ selectedFiles è§£è€¦
                            const containerVisible = ref(false);
                            const displayedSelectedFiles = ref([]);
                            const previewWrap = ref(null);
                            const subtitle = ref('V2.6 - Beta ç½‘é¡µç‰ˆ');
                            const loading = ref(false);
                            const compareMode = ref(false);
                            const multiCompareMode = ref(false);
                            const compareBusy = ref(false);
                            const sheetReady = ref(false);
                            const faReady = ref(false);
                            // ç»Ÿä¸€çš„æç¤ºå¾½æ ‡ï¼ˆå„ä¸€ä¸ªï¼‰ï¼šåŠ è½½ä¸­ä¸ºè“è‰²ï¼ŒåŠ è½½å®Œæˆåˆ‡æ¢ä¸ºç»¿è‰²å¹¶æ·¡å‡º
                            const sheetBadge = reactive({ show: true, bgClass: 'bg-blue-600', text: 'ExcelJS åŠ è½½ä¸­...' });
                            const faBadge = reactive({ show: true, bgClass: 'bg-blue-600', text: 'å›¾æ ‡åº“åŠ è½½ä¸­...' });                            // é¢œè‰²ç­›é€‰ï¼šæ¯ä¸ªæ–‡ä»¶æœ€å¤šé€‰ä¸€ç§é¢œè‰²åˆ†ç±»ï¼ˆå†æ¬¡ç‚¹å‡»æ¸…é™¤ï¼‰
                            const colorFilters = reactive({}); // { [fileName]: 'red'|'orange'|'blue'|'green' }

                            // åˆ‡æ¢æŸä¸ªæ–‡ä»¶çš„é¢œè‰²åˆ†ç±»ç­›é€‰ï¼ˆåŒä¸€æ–‡ä»¶ä»…å¯é€‰ä¸€ç§ï¼›å†æ¬¡ç‚¹å‡»å…³é—­ï¼‰
                            function toggleColorFilter(fileName, color) {
                                if (!compareMode.value || displayedSelectedFiles.value.length !== 2) return;
                                colorFilters[fileName] = (colorFilters[fileName] === color) ? undefined : color;
                            }
                            // æ ¹æ®æ˜¯å¦é€‰ä¸­è¿”å›è‰²å—æŒ‰é’®çš„æ ·å¼ç±»å
                            function badgeClass(fileName, color) {
                                const active = colorFilters[fileName] === color;
                                const base = 'text-[10px] px-1.5 py-0.5 rounded min-w-[1.75rem] text-center border transition';
                                const map = {
                                    red: active ? 'bg-red-600 text-white border-red-600' : 'bg-red-50 text-red-700 border-red-100',
                                    orange: active ? 'bg-orange-500 text-white border-orange-500' : 'bg-orange-50 text-orange-700 border-orange-100',
                                    blue: active ? 'bg-blue-600 text-white border-blue-600' : 'bg-blue-50 text-blue-700 border-blue-100',
                                    green: active ? 'bg-green-600 text-white border-green-600' : 'bg-green-50 text-green-700 border-green-100',
                                };
                                return base + ' ' + map[color];
                            }

                            // æ£€æµ‹ Font Awesome å­—ä½“åŠ è½½ï¼ˆä¼˜å…ˆæ£€æµ‹å­—ä½“ï¼Œè€ŒéCSSï¼‰
                            function detectFontAwesome() {
                                if (document.fonts && document.fonts.load) {
                                    const markReady = () => {
                                        if (!faReady.value) faReady.value = true;
                                        faBadge.bgClass = 'bg-green-600';
                                        faBadge.text = 'å›¾æ ‡åº“åŠ è½½å®Œæ¯•';
                                        setTimeout(() => { faBadge.show = false; }, 2000);
                                        console.log('Font Awesome å­—ä½“å·²åŠ è½½');
                                    };
                                    const poll = async () => {
                                        try {
                                            // å°è¯•æ£€æµ‹ solid 900 å­—é‡
                                            const r1 = await document.fonts.load('900 1em "Font Awesome 6 Free"');
                                            if (r1 && r1.length > 0) return markReady();
                                            // é€€åŒ–æ£€æµ‹å¸¸è§„æƒé‡
                                            const r2 = await document.fonts.load('400 1em "Font Awesome 6 Free"');
                                            if (r2 && r2.length > 0) return markReady();
                                            // å“ç‰Œå­—åº“ï¼ˆå¯é€‰ï¼‰
                                            const r3 = await document.fonts.load('400 1em "Font Awesome 6 Brands"');
                                            if (r3 && r3.length > 0) return markReady();
                                        } catch { }
                                        setTimeout(poll, 200);
                                    };
                                    poll();
                                } else {
                                    // åå¤‡ï¼šé€€å›åˆ°link onloadï¼ˆæå°‘æ•°æ—§æµè§ˆå™¨ï¼‰
                                    try {
                                        const links = Array.from(document.getElementsByTagName('link'));
                                        const faLink = links.find(l => (l.href || '').includes('font-awesome') || (l.href || '').includes('all.min.css'));
                                        if (faLink) {
                                            const fallbackMark = () => { if (!faReady.value) faReady.value = true; faBadge.bgClass = 'bg-green-600'; faBadge.text = 'å›¾æ ‡åº“åŠ è½½å®Œæ¯•'; setTimeout(() => { faBadge.show = false; }, 2000); };
                                            if (faLink.sheet) { fallbackMark(); }
                                            else { faLink.addEventListener('load', fallbackMark); }
                                        }
                                    } catch { }
                                }
                            }
                            detectFontAwesome();

                            // è½®è¯¢æ£€æµ‹ ExcelJS æ˜¯å¦å·²åŠ è½½
                            const checkTimer = setInterval(() => {
                                if (window && window.ExcelJS) {
                                    sheetReady.value = true;
                                    sheetBadge.bgClass = 'bg-green-600';
                                    sheetBadge.text = 'ExcelJS åŠ è½½å®Œæ¯•';
                                    setTimeout(() => { sheetBadge.show = false; }, 2000);
                                    clearInterval(checkTimer);
                                    console.log('ExcelJS å·²åŠ è½½');
                                }
                            }, 100);

                            // å›åˆ°é¡¶éƒ¨ï¼šæ˜¾ç¤º/éšè—é€»è¾‘ï¼ˆä¸ä¾èµ–å…·ä½“æ»šåŠ¨å®¹å™¨ï¼Œæ•è·ä»»ä½•æ»šåŠ¨ï¼‰
                            const showTop = ref(false);
                            const atTop = () => {
                                const y = window.scrollY || document.documentElement.scrollTop || document.body.scrollTop || 0;
                                if (y > 0) return false;
                                // æ£€æŸ¥å¸¸è§å¯æ»šå®¹å™¨æ˜¯å¦æ»šåŠ¨
                                const scrollers = document.querySelectorAll('[class*="overflow-"], [style*="overflow"], table, tbody');
                                for (const el of scrollers) {
                                    try {
                                        const cs = getComputedStyle(el);
                                        const oy = cs.overflowY || cs.overflow;
                                        if (/(auto|scroll)/.test(oy) && el.scrollHeight > el.clientHeight && el.scrollTop > 0) {
                                            return false;
                                        }
                                    } catch { }
                                }
                                return true;
                            };
                            const updateBackTop = () => { showTop.value = !atTop(); };
                            const forceShowBackTop = () => {
                                // ä¸å¼ºåˆ¶æ˜¾ç¤ºï¼Œå»¶åä¸€æ¬¡åˆ¤æ–­ï¼Œé¿å…åœ¨é¡¶ç«¯ä¸Šæ»šæ—¶è¯¯æ˜¾
                                if (typeof requestAnimationFrame === 'function') {
                                    requestAnimationFrame(updateBackTop);
                                } else {
                                    setTimeout(updateBackTop, 0);
                                }
                            };
                            // å›åˆ°é¡µé¢é¡¶éƒ¨ï¼ˆå¹³æ»‘æ»šåŠ¨ï¼‰
                            function scrollToTop() { window.scrollTo({ top: 0, behavior: 'smooth' }); }
                            onMounted(() => {
                                window.addEventListener('scroll', updateBackTop, { passive: true });
                                document.addEventListener('scroll', updateBackTop, { passive: true, capture: true });
                                document.addEventListener('wheel', forceShowBackTop, { passive: true });
                                document.addEventListener('touchmove', forceShowBackTop, { passive: true });
                                // ç‚¹å‡»å¤–éƒ¨å…³é—­ç­›é€‰é¢æ¿
                                const onDocClick = (e) => {
                                    const path = e.composedPath ? e.composedPath() : [];
                                    const isPanel = path.some(el => el && el.classList && el.classList.contains('filter-panel'));
                                    const isBtn = path.some(el => el && el.classList && el.classList.contains('filter-btn'));
                                    if (isPanel || isBtn) return;
                                    Object.keys(filterUI).forEach(fn => {
                                        const cols = filterUI[fn] || {};
                                        Object.keys(cols).forEach(cn => { cols[cn].open = false; });
                                    });
                                    openDropdownKey.value = '';
                                };
                                document.addEventListener('click', onDocClick, { capture: true });
                                // æ»šåŠ¨/ç¼©æ”¾æ—¶é‡ç®—æ‰“å¼€é¢æ¿ä½ç½®
                                const recompute = () => {
                                    const key = openDropdownKey.value;
                                    if (!key) return;
                                    const btn = document.querySelector(`.filter-btn[data-filter-key="${CSS.escape(key)}"]`);
                                    if (!btn) return;
                                    const rect = btn.getBoundingClientRect();
                                    dropdownPositions[key] = { top: rect.bottom + 4, left: rect.left };
                                };
                                window.addEventListener('resize', recompute, { passive: true });
                                window.addEventListener('scroll', recompute, { passive: true });
                                updateBackTop();
                                // å­˜åˆ°å®ä¾‹ä¸Šä»¥ä¾¿å¸è½½æ—¶ç§»é™¤
                                window.__bom_onDocClick = onDocClick;
                                window.__bom_recompute = recompute;
                            });
                            onUnmounted(() => {
                                window.removeEventListener('scroll', updateBackTop);
                                document.removeEventListener('scroll', updateBackTop, { capture: true });
                                document.removeEventListener('wheel', forceShowBackTop);
                                document.removeEventListener('touchmove', forceShowBackTop);
                                if (window.__bom_onDocClick) document.removeEventListener('click', window.__bom_onDocClick, { capture: true });
                                if (window.__bom_recompute) {
                                    window.removeEventListener('resize', window.__bom_recompute);
                                    window.removeEventListener('scroll', window.__bom_recompute);
                                }
                            });

                            // æ§åˆ¶é¢„è§ˆå®¹å™¨çš„æ˜¾ç¤º/éšè—ä¸å†…å®¹åˆ‡æ¢ - ä¼˜åŒ–ç‰ˆæœ¬ï¼š
                            // - å±•å¼€ï¼šå®¹å™¨å…ˆå±•å¼€ï¼Œå†…å®¹å»¶è¿Ÿæ·¡å…¥
                            // - æ”¶å›ï¼šå†…å®¹å…ˆæ·¡å‡ºä½†ä¿æŒåŠé€æ˜ï¼Œå®¹å™¨å†æ”¶å›
                            watch(selectedFiles, (newVal, oldVal) => {
                                const n = (newVal || []).length;
                                const o = (oldVal || []).length;

                                // è®¡ç®—é¢„è§ˆæ–‡ä»¶åˆ—è¡¨ï¼ˆæœ€å¤š2ä¸ªï¼Œéµå¾ªæŒ¤æ‰è§„åˆ™ï¼‰
                                let previewFiles = [];
                                if (n > 0) {
                                    if (n <= 2) {
                                        // 1-2ä¸ªæ–‡ä»¶ï¼šç›´æ¥é¢„è§ˆ
                                        previewFiles = [...newVal];
                                    } else {
                                        // è¶…è¿‡2ä¸ªæ–‡ä»¶ï¼šåªé¢„è§ˆæœ€å2ä¸ªï¼ˆæœ€æ–°é€‰æ‹©çš„2ä¸ªï¼‰
                                        previewFiles = newVal.slice(-2);
                                    }
                                }

                                if (previewFiles.length > 0 && !containerVisible.value) {
                                    // åˆæ¬¡æ˜¾ç¤ºï¼šç«‹å³æ¸²æŸ“å†…å®¹å¹¶å±•å¼€å¤–å±‚
                                    displayedSelectedFiles.value = [...previewFiles];
                                    containerVisible.value = true;
                                    return;
                                }
                                if (previewFiles.length === 0) {
                                    // æ— é¢„è§ˆï¼šç«‹å³æ¸…ç©ºé¢„è§ˆå†…å®¹ï¼Œè®©é¢„è§ˆåˆ—è¡¨åŠ¨ç”»ç”Ÿæ•ˆ
                                    compareMode.value = false;
                                    displayedSelectedFiles.value = []; // ç«‹å³æ¸…ç©ºï¼Œè§¦å‘é¢„è§ˆåˆ—è¡¨çš„é€€å‡ºåŠ¨ç”»
                                    if (containerVisible.value) {
                                        // å»¶è¿Ÿä¸€ç‚¹å†å…³é—­å®¹å™¨ï¼Œè®©é¢„è§ˆåˆ—è¡¨åŠ¨ç”»å…ˆå®Œæˆ
                                        setTimeout(() => {
                                            containerVisible.value = false;
                                        }, 100);
                                    }
                                    return;
                                }
                                // å…¶ä»–æƒ…å†µï¼šç›´æ¥æ›´æ–°é¢„è§ˆå†…å®¹
                                displayedSelectedFiles.value = [...previewFiles];
                            }, { deep: true });                            // é¢„è§ˆå®¹å™¨è¿‡æ¸¡ç¦»å¼€åæ¸…ç©ºå†…éƒ¨å†…å®¹ - ä¼˜åŒ–ç‰ˆæœ¬
                            function onPreviewContainerAfterLeave() {
                                // å¤–å±‚å®¹å™¨æ”¶å›å®Œæ¯•åæ¸…ç©ºå†…å®¹ï¼Œä¸ºä¸‹æ¬¡å±•å¼€åšå‡†å¤‡
                                if ((selectedFiles.value || []).length === 0) {
                                    displayedSelectedFiles.value = [];
                                }
                            }

                            // é¢„è§ˆå®¹å™¨è‡ªé€‚åº”é«˜åº¦è¿‡æ¸¡é’©å­å‡½æ•°
                            function onBeforeEnter(el) {
                                el.style.height = '0';
                                el.style.opacity = '0';
                            }

                            function onEnter(el, done) {
                                // å¼ºåˆ¶é‡ç»˜
                                el.offsetHeight;

                                // è·å–è‡ªç„¶é«˜åº¦
                                el.style.height = 'auto';
                                const height = el.offsetHeight;

                                // é‡ç½®ä¸º0å¼€å§‹åŠ¨ç”»
                                el.style.height = '0';

                                // ä¸‹ä¸€å¸§å¼€å§‹åŠ¨ç”»
                                requestAnimationFrame(() => {
                                    el.style.height = height + 'px';
                                    el.style.opacity = '1';

                                    // åŠ¨ç”»å®Œæˆåè°ƒç”¨done
                                    setTimeout(done, 600);
                                });
                            }

                            function onAfterEnter(el) {
                                // åŠ¨ç”»å®Œæˆåç§»é™¤å›ºå®šé«˜åº¦ï¼Œæ¢å¤è‡ªé€‚åº”
                                el.style.height = 'auto';
                            }

                            function onBeforeLeave(el) {
                                // è®°å½•å½“å‰é«˜åº¦
                                el.style.height = el.offsetHeight + 'px';
                                el.style.opacity = '1';
                            } function onLeave(el, done) {
                                // å¼ºåˆ¶é‡ç»˜
                                el.offsetHeight;

                                // ä¸‹ä¸€å¸§å¼€å§‹æ”¶èµ·åŠ¨ç”»
                                requestAnimationFrame(() => {
                                    el.style.height = '0';
                                    el.style.opacity = '0';

                                    // åŠ¨ç”»å®Œæˆåè°ƒç”¨done
                                    setTimeout(done, 600);
                                });
                            }

                            // è®¡ç®—å¡ç‰‡å®½åº¦ï¼šå•å¡ 100%ï¼ŒåŒå¡ç­‰åˆ†
                            function cardWidth(idx, fileName) {
                                const len = displayedSelectedFiles.value.length;
                                if (len === 1) return '100%';
                                // len >= 2 æ—¶ï¼Œç›´æ¥è¿”å›åŠå®½ï¼Œç¡®ä¿1â†’2å’Œ2â†’3æ—¶æ–°å¡ç‰‡å®½åº¦ä¸€è‡´
                                return 'calc((100% - 1.5rem) / 2)';
                            }

                            // è¿”å›å¡ç‰‡æ ·å¼ï¼ˆå®½åº¦ã€æŠ˜è¡Œæ§åˆ¶ç­‰ï¼‰
                            function cardStyle(idx, fileName) {
                                const w = cardWidth(idx, fileName);
                                return {
                                    width: w,
                                    flexBasis: w,
                                    flexShrink: 0,
                                    minWidth: 0,
                                    overflow: 'hidden'
                                };
                            }                            // æ–‡ä»¶è§£æä¸æ•°æ®è£…è½½å…¥å£
                            async function handleFiles(e) {
                                // å¯¼å…¥æµç¨‹æ€»è§ˆï¼ˆæ–°ç‰ˆè§„åˆ™ï¼‰ï¼š
                                // 1) ç”Ÿæˆå”¯ä¸€æ˜¾ç¤ºåï¼ˆå…è®¸é‡å¤å¯¼å…¥ï¼Œname, name (2), name (3)...ï¼‰
                                // 2) HTMLï¼šåœ¨æ¯ä¸ª <table> å†…å¯»æ‰¾â€œç¬¬ä¸€åˆ—ä¸º é›¶ä»¶å·/ä¾›åº”å•†é›¶ä»¶å·/å®¢æˆ·é›¶ä»¶å·â€çš„è¡Œä½œä¸ºè¡¨å¤´ï¼›
                                //    åˆ é™¤åç»­è¯¯å…¥çš„è¡¨å¤´è¡Œã€åŒ…å«åˆå¹¶å•å…ƒæ ¼çš„è¡Œï¼ˆcolspan/rowspan>1ï¼‰ã€ç¬¬ä¸€åˆ—ä»¥ Design å¼€å¤´çš„è¡Œï¼›æŒ‰è¡¨å¤´å¯¹é½å¡«å……æ•°æ®ã€‚
                                // 3) Excelï¼šè¯»å–å®Œæ•´ç½‘æ ¼å¹¶è¯†åˆ«åˆå¹¶åŒºåŸŸï¼›åŒæ ·æŒ‰â€œç¬¬ä¸€åˆ—ä»¤ç‰Œâ€è¯†åˆ«è¡¨å¤´å¹¶åˆ é™¤è¯¯å…¥è¡¨å¤´/åˆå¹¶/Design è¡Œï¼›
                                //    è‹¥æ‰¾ä¸åˆ°è¡¨å¤´åˆ™å›é€€åˆ°â€œåˆ—1..åˆ—Nâ€çš„ä¸´æ—¶åˆ—åç­–ç•¥ï¼Œå°½é‡ä¿è¯å¯ç”¨ã€‚
                                // 4) PN å¡«å……ï¼šè‹¥â€œé›¶ä»¶å·â€ä¸ºç©ºä¸”â€œä¾›åº”å•†é›¶ä»¶å·â€ä¹Ÿä¸ºç©ºï¼Œåˆ™ä¸¢å¼ƒè¯¥è¡Œï¼›è‹¥â€œé›¶ä»¶å·â€ä¸ºç©ºä½†â€œä¾›åº”å•†é›¶ä»¶å·â€æœ‰å€¼ï¼Œåˆ™å°†â€œé›¶ä»¶å·â€å¡«ä¸ºã€ä¾›åº”å•†é›¶ä»¶å·ã€‘ã€‚
                                // 5) è§„èŒƒåŒ–ä¸èšåˆï¼šå¯¹å¯¼çº¿/WIRE/çº¿æŸä¸‰æ®µå·è§„èŒƒä¸ºå‰ä¸¤æ®µï¼›æŒ‰â€œé›¶ä»¶å·â€èšåˆå¹¶æ±‡æ€»â€œæ•°é‡â€ã€‚
                                // 6) æ’åºï¼šæŒ‰â€œé›¶ä»¶å·â€è‡ªç„¶å‡åºï¼ˆæ•°å­—å‹å¥½ã€å¿½ç•¥ä¸­è‹±æ–‡å¤§å°å†™å·®å¼‚ï¼‰ã€‚
                                if (!sheetReady.value || !window.ExcelJS) {
                                    alert('ExcelJS è¿˜åœ¨åŠ è½½ä¸­ï¼Œè¯·åˆ·æ–°é¡µé¢åé‡æ–°å°è¯•');
                                    return;
                                }
                                const files = Array.from(e.target.files);
                                if (!files.length) return;
                                loading.value = true;
                                await Promise.all(files.map(file => new Promise(resolve => {
                                    // ä¸å†è·³è¿‡åŒåæ–‡ä»¶ï¼šç”Ÿæˆä¸€ä¸ªå”¯ä¸€å¯æ˜¾ç¤ºåç§°ï¼ˆname, name (2), name (3)...ï¼‰
                                    const displayName = generateUniqueFileName(file.name);
                                    const table = { name: displayName, columns: [], data: [], status: 'pending', errorMsg: '' };
                                    tables.push(table);
                                    fileList.push({ name: displayName, rows: 0, status: 'pending', errorMsg: '' });
                                    const reader = new FileReader();
                                    reader.onload = async (evt) => {
                                        try {
                                            let rows = [];
                                            let columns = [];
                                            if (file.name.endsWith('.html') || file.name.endsWith('.htm')) {
                                                const html = evt.target.result;
                                                // åœ¨ç¦»å±å®¹å™¨ä¸­è§£æï¼ŒæŒ‰â€œç¬¬ä¸€åˆ—ä¸º é›¶ä»¶å·/ä¾›åº”å•†é›¶ä»¶å·/å®¢æˆ·é›¶ä»¶å· çš„è¡Œâ€è¯†åˆ«è¡¨å¤´
                                                const container = document.createElement('div');
                                                container.innerHTML = html;
                                                const tbls = Array.from(container.getElementsByTagName('table'));
                                                const TOKENS = new Set(['é›¶ä»¶å·', 'ä¾›åº”å•†é›¶ä»¶å·', 'å®¢æˆ·é›¶ä»¶å·']);
                                                const allRows = [];
                                                let detectedCols = [];
                                                tbls.forEach((tbl, idx) => {
                                                    try {
                                                        const trs = Array.from(tbl.querySelectorAll('tr'));
                                                        if (trs.length === 0) return;
                                                        // å°†æ¯ä¸€è¡Œè§£æä¸º æ–‡æœ¬æ•°ç»„ + æ˜¯å¦åˆå¹¶å•å…ƒæ ¼ æ ‡è®°
                                                        const matrix = trs.map(tr => {
                                                            const tds = Array.from(tr.children);
                                                            const texts = tds.map(td => (td.textContent || '').trim());
                                                            const hasMerge = tds.some(td => {
                                                                const cs = parseInt(td.getAttribute('colspan') || '1', 10);
                                                                const rs = parseInt(td.getAttribute('rowspan') || '1', 10);
                                                                return (cs > 1 || rs > 1);
                                                            });
                                                            return { texts, hasMerge };
                                                        });
                                                        const hdrIdx = matrix.findIndex(r => (r.texts[0] || '') && TOKENS.has(String(r.texts[0]).trim()));
                                                        if (hdrIdx === -1) return; // éæ•°æ®è¡¨
                                                        const headers = matrix[hdrIdx].texts.map(s => String(s).trim());
                                                        // åˆå¹¶åˆ—é›†åˆï¼ˆä¿æŒé¡ºåºï¼Œé¿å…é‡å¤ï¼‰
                                                        headers.forEach(c => { if (!detectedCols.includes(c)) detectedCols.push(c); });
                                                        // é€è¡Œå†™å…¥æ•°æ®ï¼ˆè·³è¿‡åç»­è¯¯å…¥çš„è¡¨å¤´è¡Œï¼›åˆ é™¤åˆå¹¶è¡Œï¼›åˆ é™¤Designå¼€å¤´è¡Œï¼‰
                                                        for (let i = hdrIdx + 1; i < matrix.length; i++) {
                                                            const r = matrix[i];
                                                            const first = String((r.texts[0] || '')).trim();
                                                            if (TOKENS.has(first)) continue; // åˆ é™¤è¯¯å…¥çš„è¡¨å¤´è¡Œ
                                                            if (r.hasMerge) continue; // åˆ é™¤åˆå¹¶å•å…ƒæ ¼çš„è¡Œ
                                                            if (first.startsWith('Design')) continue; // åˆ é™¤ç¬¬ä¸€åˆ—ä»¥Designå¼€å¤´
                                                            const o = {};
                                                            headers.forEach((h, idx2) => {
                                                                o[h] = (r.texts[idx2] != null ? String(r.texts[idx2]).trim() : '');
                                                            });
                                                            allRows.push(o);
                                                        }
                                                    } catch (err) {
                                                        console.warn('è§£æHTMLè¡¨æ ¼å¤±è´¥ï¼Œå·²è·³è¿‡: è¡¨ç´¢å¼•', idx, err);
                                                    }
                                                });
                                                const parsed = parseHTMLTables(html);
                                                rows = parsed.rows;
                                                columns = parsed.columns;
                                            } else {
                                                const lower = file.name.toLowerCase();
                                                if (lower.endsWith('.xls')) {
                                                    throw new Error('æš‚ä¸æ”¯æŒ .xlsï¼ˆè¯·å¦å­˜ä¸º .xlsx åå¯¼å…¥ï¼‰');
                                                }
                                                const wb = new ExcelJS.Workbook();
                                                await wb.xlsx.load(evt.target.result);
                                                if (!wb.worksheets || wb.worksheets.length === 0) {
                                                    throw new Error('Excelæ–‡ä»¶æ— æœ‰æ•ˆSheet');
                                                }
                                                const ws = wb.worksheets[0];
                                                // â€”â€” è§£æç­–ç•¥è¦ç‚¹ â€”â€”
                                                // 1) ä½¿ç”¨ actualColumnCount/actualRowCount è·å–ç½‘æ ¼èŒƒå›´ï¼Œé€æ ¼æ ‡å‡†åŒ–è¯»å–ï¼ˆé¿å…ç©ºæ ¼/å¯Œæ–‡æœ¬/å…¬å¼å€¼æ··ä¹±ï¼‰ã€‚
                                                // 2) è¯†åˆ«åˆå¹¶åŒºåŸŸå¹¶ä»¥â€œè¡Œâ€ä¸ºç²’åº¦åˆ é™¤åˆå¹¶è¡Œï¼›æŒ‰â€œç¬¬ä¸€åˆ—ä»¤ç‰Œâ€å®šä½è¡¨å¤´å¹¶é‡å»ºæ•°æ®ï¼›æœªè¯†åˆ«åˆ°è¡¨å¤´æ—¶å›é€€åˆ°ä¸´æ—¶åˆ—åã€‚
                                                const colCount = ws.actualColumnCount || ws.columnCount || 0;
                                                const rowCount = ws.actualRowCount || ws.rowCount || 0;
                                                if (colCount === 0 || rowCount === 0) throw new Error('Excelä¸ºç©º');
                                                const normalize = (v) => {
                                                    if (v == null) return '';
                                                    if (typeof v === 'object') {
                                                        if (v.text != null) return String(v.text).trim();
                                                        if (v.result != null) return String(v.result).trim();
                                                        if (Array.isArray(v.richText)) return String(v.richText.map(t => t.text).join('')).trim();
                                                    }
                                                    // æ—¥æœŸ/æ•°å­—ç­‰ç»Ÿä¸€è½¬æˆå­—ç¬¦ä¸²
                                                    try { return String(v).trim(); } catch { return ''; }
                                                };
                                                const arr = [];
                                                // è®°å½•åˆå¹¶å•å…ƒæ ¼æ‰€åœ¨çš„â€œè¡Œâ€é›†åˆï¼Œç”¨äºåç»­æ•´ä½“å‰”é™¤ï¼ˆåŒä¸€è¡Œä¸­åªè¦å­˜åœ¨åˆå¹¶å•å…ƒæ ¼å°±è§†ä¸ºä¸å¯é ï¼‰ã€‚
                                                const mergedRowSet = new Set();
                                                try {
                                                    const merges = ws._merges || ws._mergesMap || ws.model && ws.model.merges;
                                                    // æ”¯æŒå¤šç§å†…éƒ¨è¡¨ç¤º
                                                    if (merges) {
                                                        const values = Array.isArray(merges) ? merges : (typeof merges === 'object' ? Object.values(merges) : []);
                                                        values.forEach(m => {
                                                            // m å¯èƒ½æ˜¯ "A1:B2" æˆ–å¯¹è±¡ {top,left,bottom,right}
                                                            if (m && typeof m === 'string') {
                                                                // è§£æèŒƒå›´å­—ç¬¦ä¸²
                                                                const m2 = m.split(':');
                                                                const toRC = (addr) => {
                                                                    const match = addr.match(/([A-Z]+)(\d+)/);
                                                                    if (!match) return { r: 0, c: 0 };
                                                                    const colStr = match[1];
                                                                    const rowStr = match[2];
                                                                    let c = 0;
                                                                    for (let i = 0; i < colStr.length; i++) {
                                                                        c = c * 26 + (colStr.charCodeAt(i) - 64);
                                                                    }
                                                                    return { r: parseInt(rowStr, 10) || 0, c };
                                                                };
                                                                const a = toRC(m2[0] || 'A1');
                                                                const b = toRC(m2[1] || m2[0] || 'A1');
                                                                const r1 = Math.min(a.r, b.r), r2 = Math.max(a.r, b.r);
                                                                for (let rr = r1; rr <= r2; rr++) mergedRowSet.add(rr);
                                                            } else if (m && typeof m === 'object' && m.top != null && m.bottom != null) {
                                                                for (let rr = m.top; rr <= m.bottom; rr++) mergedRowSet.add(rr);
                                                            }
                                                        });
                                                    }
                                                } catch { }

                                                for (let r = 1; r <= rowCount; r++) {
                                                    const row = ws.getRow(r);
                                                    // å…œåº•ï¼šè‹¥æœªè¯†åˆ«åˆ° mergesï¼Œåˆ™å°è¯•é€æ ¼åˆ¤æ–­
                                                    if (!mergedRowSet.has(r)) {
                                                        try {
                                                            let hasMerge = false;
                                                            for (let c = 1; c <= colCount; c++) {
                                                                const cell = row.getCell(c);
                                                                if (cell && (cell.isMerged || (cell.master && cell.address !== cell.master.address))) {
                                                                    hasMerge = true; break;
                                                                }
                                                            }
                                                            if (hasMerge) mergedRowSet.add(r);
                                                        } catch (mergeErr) {
                                                            console.warn(`æ£€æŸ¥ç¬¬${r}è¡Œåˆå¹¶å•å…ƒæ ¼æ—¶å‡ºé”™:`, mergeErr.message);
                                                        }
                                                    }
                                                    const one = new Array(colCount);
                                                    for (let c = 1; c <= colCount; c++) {
                                                        const cell = row.getCell(c);
                                                        one[c - 1] = normalize(cell && cell.value);
                                                    }
                                                    arr.push(one);
                                                }

                                                // è¯†åˆ«è¡¨å¤´ï¼šç¬¬ä¸€åˆ—ä¸ºâ€œä»¤ç‰Œâ€ï¼ˆé›¶ä»¶å·/ä¾›åº”å•†é›¶ä»¶å·/å®¢æˆ·é›¶ä»¶å·ï¼‰çš„ä¸€è¡Œå³ä¸ºè¡¨å¤´ï¼›å…¶åè‹¥å†å‡ºç°åŒç±»è¡Œï¼Œåˆ™è§†ä¸ºè¯¯å…¥è¡¨å¤´å¹¶åˆ é™¤ã€‚
                                                const TOKENS = new Set(['é›¶ä»¶å·', 'ä¾›åº”å•†é›¶ä»¶å·', 'å®¢æˆ·é›¶ä»¶å·']);
                                                let headerRowIdx = -1;
                                                for (let i = 0; i < arr.length; i++) {
                                                    const first = String((arr[i] && arr[i][0]) || '').trim();
                                                    if (TOKENS.has(first)) { headerRowIdx = i; break; }
                                                }
                                                if (headerRowIdx !== -1) {
                                                    const headerRow = arr[headerRowIdx];
                                                    columns = headerRow.map(v => String(v || '').trim());
                                                    const newRows = [];
                                                    for (let i = 0; i < arr.length; i++) {
                                                        if (i === headerRowIdx) continue;
                                                        const first = String((arr[i] && arr[i][0]) || '').trim();
                                                        // åˆ é™¤è¯¯å…¥è¡¨å¤´è¡Œ
                                                        if (TOKENS.has(first)) continue;
                                                        // åˆ é™¤åˆå¹¶å•å…ƒæ ¼çš„è¡Œ
                                                        if (mergedRowSet.has(i + 1)) continue;
                                                        // åˆ é™¤ç¬¬ä¸€åˆ—ä»¥ Design å¼€å¤´çš„è¡Œ
                                                        if (first.startsWith('Design')) continue;
                                                        const o = {};
                                                        for (let j = 0; j < columns.length; j++) {
                                                            o[columns[j]] = arr[i][j] != null ? String(arr[i][j]).trim() : '';
                                                        }
                                                        newRows.push(o);
                                                    }
                                                    rows = newRows;
                                                } else {
                                                    // åå¤‡ï¼šä¿æŒåŸæœ‰ç­–ç•¥ï¼ˆä¸´æ—¶åˆ—å + å…¨éƒ¨æ•°æ®ï¼‰ï¼Œä¸‹æ¸¸æ­¥éª¤ä¼šå°½é‡å…¼å®¹
                                                    columns = Array.from({ length: colCount }, (_, i) => `åˆ—${i + 1}`);
                                                    rows = arr.map(a => {
                                                        const o = {};
                                                        for (let i = 0; i < colCount; i++) o[columns[i]] = a[i] ?? '';
                                                        return o;
                                                    });
                                                }
                                            }
                                            // æ¸…æ´—é€»è¾‘ï¼ˆä¸æ–°è§„åˆ™ä¸€è‡´ï¼‰ï¼š
                                            // 1) è¡¨å¤´å·²åœ¨è§£æé˜¶æ®µæŒ‰â€œç¬¬ä¸€åˆ—=ä»¤ç‰Œâ€è¯†åˆ«ï¼Œå¹¶å·²ç§»é™¤è¯¯å…¥è¡¨å¤´è¡Œï¼›åˆå¹¶è¡Œä¸ç¬¬ä¸€åˆ—ä»¥ Design å¼€å¤´çš„è¡Œä¹Ÿå·²åˆ é™¤ã€‚
                                            // 2) å¯¹â€œé›¶ä»¶å·/ä¾›åº”å•†é›¶ä»¶å·â€åšç»Ÿä¸€è§„æ•´ + PN å¡«å……ï¼š
                                            //    - ä»…å¯¹è¿™ä¸¤åˆ—è¿›è¡Œï¼šå»é™¤ä¸å¯è§å­—ç¬¦(é›¶å®½/è½¯è¿å­—ç¬¦ç­‰)ï¼›å»é™¤å¤šä½™ç©ºç™½ï¼Œå† trimã€‚
                                            //    - è‹¥â€œé›¶ä»¶å·â€ä¸ºç©ºä¸”â€œä¾›åº”å•†é›¶ä»¶å·â€ä¹Ÿä¸ºç©º -> åˆ é™¤è¯¥è¡Œï¼›
                                            //    - è‹¥â€œé›¶ä»¶å·â€ä¸ºç©ºä½†â€œä¾›åº”å•†é›¶ä»¶å·â€æœ‰å€¼ -> å°†â€œé›¶ä»¶å·â€å¡«ä¸ºã€ä¾›åº”å•†é›¶ä»¶å·ã€‘ã€‚
                                            try {
                                                const hasPN = columns.includes('é›¶ä»¶å·');
                                                const hasSPN = columns.includes('ä¾›åº”å•†é›¶ä»¶å·');
                                                if (!hasPN) {
                                                    // ç¡®ä¿å­˜åœ¨â€œé›¶ä»¶å·â€åˆ—ï¼Œä¾¿äºåç»­æµç¨‹
                                                    columns = ['é›¶ä»¶å·', ...columns.filter(c => c !== 'é›¶ä»¶å·')];
                                                }
                                                if (hasPN || hasSPN) {
                                                    // ä»…ç”¨äºâ€œé›¶ä»¶å·/ä¾›åº”å•†é›¶ä»¶å·â€çš„è§„æ•´å‡½æ•°
                                                    const normalizeKey = (v) => {
                                                        if (v == null) return '';
                                                        let s = String(v);
                                                        // åˆ é™¤é›¶å®½å­—ç¬¦ä¸è½¯è¿å­—ç¬¦ï¼šU+200B..U+200D, U+FEFF, U+00AD
                                                        s = s.replace(/[\u200B-\u200D\uFEFF\u00AD]/g, '');
                                                        // åˆ é™¤æ‰€æœ‰ç©ºç™½ï¼ˆç©ºæ ¼/å›è½¦/åˆ¶è¡¨/ä¸é—´æ–­ç©ºæ ¼ç­‰ï¼‰ï¼Œä¸ä¿ç•™
                                                        s = s.replace(/[\s\u00A0]+/g, '').trim();
                                                        return s;
                                                    };
                                                    const kept = [];
                                                    rows.forEach(r => {
                                                        // å…ˆå¯¹ä¸¤åˆ—åšè§„æ•´ï¼ˆä»…è¿™ä¸¤åˆ—ï¼‰
                                                        const pn0 = (r && r['é›¶ä»¶å·']);
                                                        const spn0 = (r && r['ä¾›åº”å•†é›¶ä»¶å·']);
                                                        const pn = normalizeKey(pn0);
                                                        const spn = normalizeKey(spn0);
                                                        r['é›¶ä»¶å·'] = pn; // ç¡®ä¿â€œé›¶ä»¶å·â€åˆ—å†™å›ä¸ºè§„æ•´åçš„å€¼
                                                        if (hasSPN && ('ä¾›åº”å•†é›¶ä»¶å·' in r)) r['ä¾›åº”å•†é›¶ä»¶å·'] = spn;

                                                        if (!pn) {
                                                            if (!spn) {
                                                                // ä¸¤è€…éƒ½ç©ºï¼šä¸¢å¼ƒ
                                                                return;
                                                            }
                                                            // ä»… PN ä¸ºç©ºï¼šç”¨ã€ä¾›åº”å•†é›¶ä»¶å·ã€‘å¡«å……
                                                            r['é›¶ä»¶å·'] = `ã€${spn}ã€‘`;
                                                        }
                                                        //ï¼ˆç§»é™¤å†—ä½™ï¼‰æ­¤å¤„æ— éœ€å†æ¬¡ç¡®ä¿â€œé›¶ä»¶å·â€å­˜åœ¨ï¼Œå‰é¢å·²ç»Ÿä¸€å†™å›
                                                        kept.push(r);
                                                    });
                                                    rows = kept;
                                                }
                                            } catch (err) {
                                                throw new Error(`é›¶ä»¶å·æ•°æ®æ¸…ç†å¤±è´¥: ${err.message || 'é›¶ä»¶å·æˆ–ä¾›åº”å•†é›¶ä»¶å·æ•°æ®æ ¼å¼æœ‰è¯¯'}`);
                                            }

                                            // 4. åŸºäºâ€œç±»å‹â€åˆ—çš„è§„åˆ™å¤„ç†ä¸èšåˆï¼ˆåœ¨æ’åºä¹‹å‰ï¼ŒåŸºäºâ€œé›¶ä»¶å·â€å­—æ®µï¼‰
                                            try {
                                                const colPN = (columns && columns.includes('é›¶ä»¶å·')) ? 'é›¶ä»¶å·' : null;
                                                const colType = columns.includes('ç±»å‹') ? 'ç±»å‹' : null;
                                                const colQty = columns.includes('æ•°é‡') ? 'æ•°é‡' : null;
                                                const TYPE_SET = new Set(['WIRE', 'çº¿æŸ', 'å¯¼çº¿']);

                                                if (colPN && colType) {
                                                    // 4.1 PN è§„èŒƒåŒ–ï¼šå¯¹ ç±»å‹âˆˆ{WIRE, çº¿æŸ, å¯¼çº¿} çš„è¡Œï¼Œè‹¥ PN å½¢å¦‚ A-B-Cï¼ˆä¸‰æ®µï¼‰ï¼Œåˆ™è§„èŒƒä¸º â€œA-Bâ€ ä¾¿äºèšåˆã€‚
                                                    rows.forEach(r => {
                                                        const t = r && r[colType];
                                                        const aVal = r && r[colPN];
                                                        const aStr = (aVal == null ? '' : String(aVal)).trim();
                                                        if (TYPE_SET.has(String(t).trim())) {
                                                            const parts = aStr.split('-');
                                                            if (parts.length === 3) {
                                                                r[colPN] = parts[0] + '-' + parts[1];
                                                            }
                                                        }
                                                    });
                                                }

                                                // 4.2 æŒ‰â€œé›¶ä»¶å·â€èšåˆï¼šç›¸åŒ PN çš„â€œæ•°é‡â€ç›¸åŠ ï¼Œå…¶å®ƒå­—æ®µä¿ç•™é¦–è¡Œå€¼
                                                if (colPN && colQty) {
                                                    const map = new Map();
                                                    rows.forEach(row => {
                                                        const key = String((row && row[colPN]) ?? '').trim();
                                                        if (!map.has(key)) {
                                                            // æµ…æ‹·è´ä¸€ä»½ä½œä¸ºèšåˆåŸº
                                                            const base = { ...row };
                                                            base[colQty] = toNumber(base[colQty]);
                                                            map.set(key, base);
                                                        } else {
                                                            const agg = map.get(key);
                                                            agg[colQty] = toNumber(agg[colQty]) + toNumber(row[colQty]);
                                                        }
                                                    });
                                                    rows = Array.from(map.values());
                                                }
                                            } catch (e) {
                                                throw new Error(`å¯¼çº¿ç±»å‹å¤„ç†æˆ–æ•°æ®èšåˆå¤±è´¥: ${e && e.message ? e.message : 'ç±»å‹åˆ—æˆ–æ•°é‡åˆ—æ•°æ®æ ¼å¼æœ‰è¯¯'}`);
                                            }
                                            // 5. æ’åºï¼šä½¿ç”¨ Intl.Collator çš„ numeric è‡ªç„¶æ’åºï¼Œå…¼å®¹ä¸­è‹±æ–‡ä¸æ•°å­—æ··æ’ã€‚
                                            try {
                                                const primaryCol = (columns && columns.includes(COLUMN_NAMES.PART_NUMBER)) ? COLUMN_NAMES.PART_NUMBER : null;
                                                if (primaryCol) {
                                                    const collator = new Intl.Collator('zh-CN', { numeric: true, sensitivity: 'base' });
                                                    rows.sort((a, b) => {
                                                        const av = (a && typeof a === 'object') ? a[primaryCol] : '';
                                                        const bv = (b && typeof b === 'object') ? b[primaryCol] : '';
                                                        const as = av == null ? '' : String(av).trim();
                                                        const bs = bv == null ? '' : String(bv).trim();
                                                        return collator.compare(as, bs);
                                                    });
                                                }
                                            } catch (e) {
                                                throw new Error(`æ•°æ®æ’åºå¤±è´¥: ${e && e.message ? e.message : 'é›¶ä»¶å·åˆ—æ•°æ®æ— æ³•æ­£å¸¸æ’åº'}`);
                                            }
                                            table.columns = columns;
                                            table.data = rows;
                                            table.status = 'success';
                                            table.errorMsg = '';
                                            const f = fileList.find(f => f.name === displayName);
                                            f.rows = table.data.length;
                                            f.status = 'success';
                                            f.errorMsg = '';
                                        } catch (err) {
                                            // æ ¹æ®é”™è¯¯ç±»å‹æä¾›å…·ä½“çš„é”™è¯¯ä¿¡æ¯
                                            let errorMessage = '';
                                            const originalError = err && err.message ? err.message : err;

                                            if (typeof originalError === 'string') {
                                                if (originalError.includes('Excelè§£æå¤±è´¥')) {
                                                    errorMessage = `Excelæ–‡ä»¶æ ¼å¼é”™è¯¯: ${originalError.replace('Excelè§£æå¤±è´¥: ', '')}`;
                                                } else if (originalError.includes('é›¶ä»¶å·æ•°æ®æ¸…ç†å¤±è´¥')) {
                                                    errorMessage = `æ•°æ®æ¸…æ´—é˜¶æ®µ - ${originalError}`;
                                                } else if (originalError.includes('å¯¼çº¿ç±»å‹å¤„ç†æˆ–æ•°æ®èšåˆå¤±è´¥')) {
                                                    errorMessage = `æ•°æ®å¤„ç†é˜¶æ®µ - ${originalError}`;
                                                } else if (originalError.includes('æ•°æ®æ’åºå¤±è´¥')) {
                                                    errorMessage = `æ•°æ®æ•´ç†é˜¶æ®µ - ${originalError}`;
                                                } else if (originalError.includes('æš‚ä¸æ”¯æŒ')) {
                                                    errorMessage = `æ–‡ä»¶æ ¼å¼ä¸æ”¯æŒ: ${originalError}`;
                                                } else if (originalError.includes('Excelæ–‡ä»¶æ— æœ‰æ•ˆSheet')) {
                                                    errorMessage = `Excelæ–‡ä»¶ç»“æ„é”™è¯¯: æ–‡ä»¶ä¸­æ²¡æœ‰æœ‰æ•ˆçš„å·¥ä½œè¡¨`;
                                                } else if (originalError.includes('Excelä¸ºç©º')) {
                                                    errorMessage = `Excelæ–‡ä»¶å†…å®¹é”™è¯¯: å·¥ä½œè¡¨ä¸ºç©ºæˆ–æ²¡æœ‰æ•°æ®`;
                                                } else {
                                                    errorMessage = `æ–‡ä»¶è§£æå¤±è´¥: ${originalError}`;
                                                }
                                            } else {
                                                errorMessage = `æ–‡ä»¶è§£æè¿‡ç¨‹ä¸­å‡ºç°æœªçŸ¥é”™è¯¯`;
                                            }

                                            table.status = 'error';
                                            table.errorMsg = errorMessage;
                                            table.columns = [];
                                            table.data = [];
                                            const f = fileList.find(f => f.name === displayName);
                                            if (f) {
                                                f.rows = 0;
                                                f.status = 'error';
                                                f.errorMsg = errorMessage;
                                            }
                                            console.error('æ–‡ä»¶è§£æå¼‚å¸¸:', file.name, 'é”™è¯¯è¯¦æƒ…:', err);
                                        }
                                        resolve();
                                    };
                                    if (file.name.endsWith('.html') || file.name.endsWith('.htm')) {
                                        reader.readAsText(file);
                                    } else {
                                        reader.readAsArrayBuffer(file);
                                    }
                                })));
                                loading.value = false;
                            }

                            // åˆ é™¤æ–‡ä»¶
                            // ä»åˆ—è¡¨ä¸é€‰ä¸­é›†åˆä¸­ç§»é™¤æ–‡ä»¶
                            function removeFile(idx) {
                                if (idx < 0 || idx >= fileList.length) return;
                                const name = fileList[idx].name;
                                const tIdx = tables.findIndex(t => t.name === name);
                                if (tIdx !== -1) tables.splice(tIdx, 1);
                                fileList.splice(idx, 1);
                                const selIdx = selectedFiles.value.indexOf(name);
                                if (selIdx !== -1) selectedFiles.value.splice(selIdx, 1);
                            }

                            //ï¼ˆå·²ç§»é™¤ï¼‰ç‚¹å‡»æ–‡ä»¶æ¡ç›®åˆ‡æ¢é¢„è§ˆåŠŸèƒ½ç”± onFileCheckboxChange ç»Ÿä¸€å¤„ç†

                            // æ–‡ä»¶é€‰æ‹©é€»è¾‘ - åˆ†ç¦»é€‰æ‹©å’Œé¢„è§ˆï¼š
                            // 1. æ–‡ä»¶é€‰æ‹©ï¼šå¤šé€‰æ¨¡å¼ä¸‹æ— é™åˆ¶ï¼Œæ™®é€šæ¨¡å¼ä¸‹æœ€å¤š2ä¸ª
                            // 2. æ–‡ä»¶é¢„è§ˆï¼šæ— è®ºå“ªç§æ¨¡å¼ï¼Œé¢„è§ˆåŒºæœ€å¤šæ˜¾ç¤º2ä¸ªæ–‡ä»¶ï¼Œéµå¾ªæŒ¤æ‰è§„åˆ™
                            function onFileCheckboxChange(name, checked, status) {
                                if (status === 'error') return;
                                const i = selectedFiles.value.indexOf(name);

                                if (checked) {
                                    if (i === -1) {
                                        // æ–‡ä»¶é€‰æ‹©é€»è¾‘
                                        if (multiCompareMode.value) {
                                            // å¤šé€‰æ¨¡å¼ï¼šå¯ä»¥é€‰æ‹©æ— é™ä¸ªæ–‡ä»¶
                                            selectedFiles.value.push(name);
                                        } else {
                                            // æ™®é€šæ¨¡å¼ï¼šæœ€å¤šé€‰æ‹©2ä¸ªæ–‡ä»¶
                                            if (selectedFiles.value.length >= 2) {
                                                selectedFiles.value.shift(); // ç§»é™¤æœ€æ—©é€‰æ‹©çš„æ–‡ä»¶
                                            }
                                            selectedFiles.value.push(name);
                                        }
                                    }
                                } else {
                                    // å–æ¶ˆé€‰æ‹©
                                    if (i >= 0) selectedFiles.value.splice(i, 1);
                                }
                            }
                            // å¤šæ–‡ä»¶å¯¹æ¯”æ¨¡å¼å¼€å…³ - æ”¹è¿›ç‰ˆæœ¬ï¼š
                            // - è¿›å…¥æ—¶ï¼šä¿æŒå·²é€‰æ‹©çš„æ–‡ä»¶å’Œé¢„è§ˆçŠ¶æ€
                            // - é€€å‡ºæ—¶ï¼šä¿æŒå·²é€‰æ‹©çš„æ–‡ä»¶å’Œé¢„è§ˆçŠ¶æ€ï¼Œå¹¶æ¸…ç©ºæ‰€æœ‰é€‰ä¸­æ–‡ä»¶
                            function toggleMultiCompare() {
                                multiCompareMode.value = !multiCompareMode.value;
                                if (multiCompareMode.value) {
                                    // è¿›å…¥å¤šé€‰æ¨¡å¼ï¼šä¿æŒé¢„è§ˆçŠ¶æ€å’Œå·²é€‰æ‹©çš„æ–‡ä»¶
                                    compareMode.value = false;
                                    // ä¸å…³é—­é¢„è§ˆå®¹å™¨ï¼Œä¸æ¸…ç©ºå·²é€‰æ‹©æ–‡ä»¶
                                } else {
                                    // é€€å‡ºå¤šé€‰æ¨¡å¼ï¼ˆç‚¹å‡»"å–æ¶ˆå¤šé€‰"ï¼‰ï¼šæ¸…ç©ºæ‰€æœ‰å·²é€‰æ‹©çš„æ–‡ä»¶
                                    selectedFiles.value = [];
                                    containerVisible.value = false;
                                    compareMode.value = false;
                                }
                            }

                            // å¤šé€‰æ¨¡å¼ä¸‹ä¸€é”®å…¨é€‰ï¼ˆè¿‡æ»¤è§£æå¤±è´¥çš„é¡¹ï¼‰
                            function selectAllFiles() {
                                if (!multiCompareMode.value) return;
                                const all = fileList.filter(f => f.status !== 'error').map(f => f.name);
                                selectedFiles.value.splice(0, selectedFiles.value.length, ...all);
                            }

                            // è·å–è¡¨æ ¼
                            // æ ¹æ®æ˜¾ç¤ºåè·å–è¡¨å¯¹è±¡ï¼ˆcolumnsã€data ç­‰ï¼‰
                            function getTable(name) {
                                const t = tables.find(t => t.name === name);
                                if (!t || !t.columns || !t.data) {
                                    return { columns: [], data: [], status: 'error', errorMsg: 'æœªæ‰¾åˆ°' };
                                }
                                return t;
                            }

                            const filterUI = reactive({}); // ä¸‹æ‹‰å¼€å…³ä¸ä¸´æ—¶æœç´¢/é€‰æ‹©
                            const activeFilters = reactive({}); // ç”Ÿæ•ˆçš„æŒ‰åˆ—ç­›é€‰: { [fileName]: { [col]: Set(values) } }
                            // Teleport ç­›é€‰é¢æ¿å®šä½ï¼ˆfixed åˆ°è§†å£ï¼‰ï¼Œkey ç”± fileName__col ç»„æˆ
                            const dropdownPositions = reactive({}); // { [key]: { top, left } }
                            const openDropdownKey = ref('');

                            // è·å–ç­›é€‰é¢æ¿çš„ä¸´æ—¶çŠ¶æ€å¯¹è±¡ï¼ˆä¸å­˜åœ¨åˆ™åˆå§‹åŒ–ï¼‰
                            function keyOf(fileName, col) {
                                if (!filterUI[fileName]) filterUI[fileName] = {};
                                if (!filterUI[fileName][col]) filterUI[fileName][col] = { open: false, search: '', temp: new Set() };
                                return filterUI[fileName][col];
                            }

                            // æ‰“å¼€/å…³é—­åˆ—ç­›é€‰ä¸‹æ‹‰é¢æ¿ï¼Œå¹¶è®¡ç®—å®šä½
                            function toggleFilterDropdown(fileName, col, evt) {
                                const k = keyOf(fileName, col);
                                k.open = !k.open;
                                // åˆå§‹åŒ–ä¸´æ—¶é›†åˆä¸ºå½“å‰å·²é€‰å€¼
                                const selected = activeFilters[fileName] && activeFilters[fileName][col] ? activeFilters[fileName][col] : new Set();
                                k.temp = new Set(Array.from(selected));
                                // è®°å½•æ‰“å¼€çš„é¢æ¿ä½ç½®ï¼ˆæŒ‰é’®çš„å¯è§†åŒºåŸŸ rectï¼‰
                                const key = `${fileName}__${col}`;
                                if (k.open && evt && evt.currentTarget) {
                                    const rect = evt.currentTarget.getBoundingClientRect();
                                    dropdownPositions[key] = { top: rect.bottom + 4, left: rect.left };
                                    openDropdownKey.value = key;
                                } else if (!k.open && openDropdownKey.value === key) {
                                    openDropdownKey.value = '';
                                }
                            }
                            // å…³é—­åˆ—ç­›é€‰é¢æ¿
                            function closeDropdown(fileName, col) {
                                const k = keyOf(fileName, col);
                                k.open = false;
                                if (openDropdownKey.value === `${fileName}__${col}`) openDropdownKey.value = '';
                            }
                            // åˆ¤æ–­åˆ—ç­›é€‰é¢æ¿æ˜¯å¦æ‰“å¼€
                            function isDropdownOpen(fileName, col) { return !!(filterUI[fileName] && filterUI[fileName][col] && filterUI[fileName][col].open); }

                            // è·å–åˆ—ç­›é€‰çš„ä¸´æ—¶çŠ¶æ€ï¼ˆå«æœç´¢ä¸ä¸´æ—¶å‹¾é€‰ï¼‰
                            function getFilterState(fileName, col) { return keyOf(fileName, col); }

                            // è®¡ç®—ä¸‹æ‹‰ç­›é€‰é¢æ¿çš„ fixed å®šä½æ ·å¼
                            function dropdownStyle(fileName, col) {
                                const key = `${fileName}__${col}`;
                                const pos = dropdownPositions[key] || { top: 0, left: 0 };
                                const panelWidth = 256; // w-64
                                const panelHeight = 320; // ä¼°ç®—é«˜åº¦ï¼Œå†…éƒ¨æ»šåŠ¨
                                let top = pos.top;
                                let left = pos.left;
                                const vw = window.innerWidth || document.documentElement.clientWidth;
                                const vh = window.innerHeight || document.documentElement.clientHeight;
                                if (left + panelWidth > vw - 8) left = Math.max(8, vw - panelWidth - 8);
                                if (top + panelHeight > vh - 8) top = Math.max(8, vh - panelHeight - 8);
                                return `top:${top}px;left:${left}px;`;
                            }

                            // æ”¶é›†æŒ‡å®šåˆ—çš„å»é‡å€¼åˆ—è¡¨ï¼ˆåŸºäºå½“å‰è¡¨æ•°æ®ï¼Œä¸å—åˆ—ç­›é€‰å½±å“ï¼‰
                            function collectDistinctValues(fileName, col) {
                                const table = getTable(fileName);
                                const set = new Set();
                                (table.data || []).forEach(r => set.add(String((r && r[col]) ?? '')));
                                return Array.from(set);
                            }

                            // åœ¨å»é‡å€¼åŸºç¡€ä¸Šåº”ç”¨æœç´¢è¿‡æ»¤å¹¶æ’åºï¼ˆä¾›ä¸‹æ‹‰é¢æ¿æ˜¾ç¤ºï¼‰
                            function filteredDistinctValues(fileName, col) {
                                const state = getFilterState(fileName, col);
                                const search = (state.search || '').toLowerCase();
                                const collator = new Intl.Collator('zh-CN', { numeric: true, sensitivity: 'base' });
                                return collectDistinctValues(fileName, col)
                                    .filter(v => v.toLowerCase().includes(search))
                                    .sort((a, b) => collator.compare(a, b));
                            }

                            // åˆ¤æ–­å€¼æ˜¯å¦åœ¨ä¸´æ—¶å‹¾é€‰é›†åˆä¸­
                            function isValueChecked(fileName, col, val) { return getFilterState(fileName, col).temp.has(String(val ?? '')); }
                            // åˆ‡æ¢ä¸‹æ‹‰é¡¹çš„ä¸´æ—¶å‹¾é€‰çŠ¶æ€
                            function onToggleValue(fileName, col, val, checked) {
                                const state = getFilterState(fileName, col);
                                const key = String(val ?? '');
                                if (checked) state.temp.add(key); else state.temp.delete(key);
                            }
                            // å‹¾é€‰å½“å‰åˆ—çš„å…¨éƒ¨å¯é€‰å€¼
                            function selectAllValues(fileName, col) {
                                const state = getFilterState(fileName, col);
                                state.temp = new Set(collectDistinctValues(fileName, col).map(v => String(v ?? '')));
                            }
                            // æ¸…é™¤å½“å‰åˆ—çš„å…¨éƒ¨å‹¾é€‰å€¼
                            function clearAllValues(fileName, col) { getFilterState(fileName, col).temp = new Set(); }

                            // åº”ç”¨åˆ—ç­›é€‰ï¼ˆå°†ä¸´æ—¶å‹¾é€‰å†™å…¥æ­£å¼ç­›é€‰é›†åˆï¼‰
                            function applyFilter(fileName, col) {
                                if (!activeFilters[fileName]) activeFilters[fileName] = {};
                                activeFilters[fileName][col] = new Set(Array.from(getFilterState(fileName, col).temp));
                                closeDropdown(fileName, col);
                            }

                            // åˆ¤æ–­æŸåˆ—æ˜¯å¦å­˜åœ¨æœ‰æ•ˆçš„ç­›é€‰æ¡ä»¶
                            function isColumnFiltered(fileName, col) {
                                return !!(activeFilters[fileName] && activeFilters[fileName][col] && activeFilters[fileName][col].size > 0);
                            }

                            // æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä»»æ„åˆ—ç­›é€‰
                            function hasActiveFilters(fileName) {
                                const f = activeFilters[fileName] || {};
                                return Object.values(f).some(set => set && set.size > 0);
                            }

                            // ä»…åº”ç”¨åˆ—å€¼ç­›é€‰ï¼ˆä¸åº”ç”¨é¢œè‰²ç­›é€‰ï¼‰ï¼Œç”¨äºè®¡æ•°ç­‰
                            function baseFilteredRows(fileName) {
                                const table = getTable(fileName);
                                const rows = table.data || [];
                                const filters = activeFilters[fileName] || {};
                                const cols = table.columns || [];
                                const hasAny = Object.values(filters).some(set => set && set.size > 0);
                                return hasAny ? rows.filter(r => cols.every(col => {
                                    const set = filters[col];
                                    if (!set || set.size === 0) return true;
                                    const key = String((r && r[col]) ?? '');
                                    return set.has(key);
                                })) : rows;
                            }

                            // ç»¼åˆåˆ—ç­›é€‰ä¸é¢œè‰²åˆ†ç±»ç­›é€‰ï¼Œè¿”å›æœ€ç»ˆç”¨äºæ¸²æŸ“çš„è¡Œ
                            function filteredRows(fileName) {
                                const table = getTable(fileName);
                                const cols = table.columns || [];
                                let result = baseFilteredRows(fileName);
                                // é¢œè‰²åˆ†ç±»ç­›é€‰ï¼ˆä»…åœ¨å¯¹æ¯”æ¨¡å¼ä¸”é€‰äº†ä¸¤è¡¨æ—¶ç”Ÿæ•ˆï¼‰
                                if (compareMode.value && displayedSelectedFiles.value.length === 2 && colorFilters[fileName]) {
                                    const want = COLOR_TO_PRIORITY[colorFilters[fileName]];
                                    result = result.filter(r => categoryPriority(fileName, r) === want);
                                }
                                // å¯¹æ¯”æ¨¡å¼ä¸‹ï¼ŒæŒ‰åº•è‰²ä¼˜å…ˆçº§æ’åºï¼šçº¢(0) æ©™(1) è“(2) ç»¿(3)
                                if (compareMode.value && displayedSelectedFiles.value.length === 2 && cols.includes('é›¶ä»¶å·')) {
                                    const collator = new Intl.Collator('zh-CN', { numeric: true, sensitivity: 'base' });
                                    result = [...result].sort((a, b) => {
                                        const pa = categoryPriority(fileName, a);
                                        const pb = categoryPriority(fileName, b);
                                        if (pa !== pb) return pa - pb;
                                        const as = String((a && a['é›¶ä»¶å·']) ?? '').trim();
                                        const bs = String((b && b['é›¶ä»¶å·']) ?? '').trim();
                                        return collator.compare(as, bs);
                                    });
                                }
                                return result;
                            }

                            // å¼€å…³å¯¹æ¯”æ¨¡å¼ï¼›å¼€å¯æ—¶çŸ­æš‚è¿›å…¥å¿™ç¢Œæ€
                            async function toggleCompare() {
                                if (compareMode.value) {
                                    // å…³é—­å¯¹æ¯”ï¼šç›´æ¥é€€å‡º
                                    compareMode.value = false;
                                    return;
                                }
                                // å¯åŠ¨å¯¹æ¯”ï¼šè¿›å…¥å¿™ç¢Œæ€ï¼ŒçŸ­æš‚åˆ†æåå¼€å¯
                                if (compareBusy.value) return;
                                compareBusy.value = true;
                                try {
                                    // å¯ä»¥åœ¨æ­¤é¢„çƒ­ç´¢å¼•/ç¼“å­˜åˆ†ç±»ï¼Œå½“å‰åšä¸€ä¸ªå°å»¶æ—¶æ¨¡æ‹Ÿåˆ†æ
                                    await new Promise(r => setTimeout(r, 500));
                                    compareMode.value = true;
                                } finally {
                                    compareBusy.value = false;
                                }
                            }

                            // è·å–ä¸å½“å‰æ–‡ä»¶æˆå¯¹çš„å¦ä¸€ä¸ªæ–‡ä»¶åï¼ˆä»…åœ¨é¢„è§ˆäº†ä¸¤ä¸ªæ–‡ä»¶æ—¶æœ‰æ•ˆï¼‰
                            function getOtherFileName(current) {
                                if (displayedSelectedFiles.value.length !== 2) return null;
                                return displayedSelectedFiles.value[0] === current ? displayedSelectedFiles.value[1] : displayedSelectedFiles.value[0];
                            }

                            // å°†æ•°é‡å­—æ®µè½¬æ¢ä¸ºæ•°å­—ï¼ˆå…¼å®¹åƒä½åˆ†éš”é€—å·ï¼Œç©ºå€¼ä¸º 0ï¼‰
                            function toNumber(v) {
                                if (v == null || v === '') return 0;
                                const n = parseFloat(String(v).replace(/,/g, ''));
                                return isNaN(n) ? 0 : n;
                            }

                            // ä¸ºå¯¹è¡¨æ„å»ºæŒ‰â€œé›¶ä»¶å·/ä¾›åº”å•†é›¶ä»¶å·â€çš„å¿«é€Ÿç´¢å¼•
                            function buildIndexes(otherName) {
                                const other = getTable(otherName);
                                const byPN = new Map();
                                const bySupplier = new Map();
                                if (other && Array.isArray(other.data)) {
                                    other.data.forEach(r => {
                                        const pn = String((r && r['é›¶ä»¶å·']) ?? '').trim();
                                        const spn = String((r && r['ä¾›åº”å•†é›¶ä»¶å·']) ?? '').trim();
                                        if (pn) byPN.set(pn, r);
                                        if (spn) bySupplier.set(spn, r);
                                    });
                                }
                                return { byPN, bySupplier };
                            }

                            // æ„å»ºâ€œäº¤å‰ç´¢å¼•â€ï¼šç”¨äºæŒ‰ä½ çš„å®šä¹‰è®¡ç®—â€œæ©™è‰²â€ï¼ˆåŒæ–¹å‡ä¸ºçº¢çš„ä¾›åº”å•†é›¶ä»¶å·äº¤é›†ï¼‰
                            // æ„å»ºäº¤å‰ç´¢å¼•ï¼šç”¨äºåˆ¤æ–­æ©™è‰²ï¼ˆæœ¬è¡¨çº¢ã€ä¸”ä¾›åº”å•†å·è½åœ¨å¯¹è¡¨çº¢é›†åˆå†…ï¼‰ä¸è“ç»¿
                            function buildCrossIndex(currentName) {
                                const otherName = getOtherFileName(currentName);
                                const current = getTable(currentName);
                                const other = getTable(otherName);
                                const currentPNSet = new Set();
                                const otherByPN = new Map();
                                const otherRedSupplierSet = new Set();
                                if (current && Array.isArray(current.data)) {
                                    current.data.forEach(r => {
                                        const pn = String((r && r['é›¶ä»¶å·']) ?? '').trim();
                                        if (pn) currentPNSet.add(pn);
                                    });
                                }
                                if (other && Array.isArray(other.data)) {
                                    other.data.forEach(r => {
                                        const pn = String((r && r['é›¶ä»¶å·']) ?? '').trim();
                                        if (pn) otherByPN.set(pn, r);
                                    });
                                    // å¦ä¸€å¼ è¡¨çš„â€œçº¢è‰²â€é›†åˆï¼ˆç›¸å¯¹äºå½“å‰è¡¨ï¼‰ï¼šPN ä¸åœ¨å½“å‰è¡¨ä¸­
                                    other.data.forEach(r => {
                                        const pn = String((r && r['é›¶ä»¶å·']) ?? '').trim();
                                        const spn = String((r && r['ä¾›åº”å•†é›¶ä»¶å·']) ?? '').trim();
                                        if (!pn || !spn) return;
                                        if (!currentPNSet.has(pn)) {
                                            otherRedSupplierSet.add(spn);
                                        }
                                    });
                                }
                                return { otherByPN, otherRedSupplierSet };
                            }

                            // è®¡ç®—ä¸€è¡Œçš„å¯¹æ¯”åˆ†ç±»ä¼˜å…ˆçº§ï¼šçº¢(0)/æ©™(1)/è“(2)/ç»¿(3)
                            function categoryPriority(fileName, row) {
                                if (!compareMode.value) return 3; // é»˜è®¤å½“ä½œç»¿è‰²
                                const otherName = getOtherFileName(fileName);
                                if (!otherName) return 3;
                                const pn = String((row && row['é›¶ä»¶å·']) ?? '').trim();
                                const { otherByPN, otherRedSupplierSet } = buildCrossIndex(fileName);
                                const otherRow = pn ? otherByPN.get(pn) : undefined;
                                if (!otherRow) {
                                    // æœ¬è¡¨çº¢ï¼šè‹¥ä¾›åº”å•†é›¶ä»¶å·è½åœ¨å¯¹è¡¨çº¢é›†åˆå†…ï¼Œåˆ™æ©™ï¼Œå¦åˆ™çº¢
                                    const spn = String((row && row['ä¾›åº”å•†é›¶ä»¶å·']) ?? '').trim();
                                    if (spn && otherRedSupplierSet.has(spn)) return 1; // æ©™
                                    return 0; // çº¢
                                }
                                // PN å‘½ä¸­ï¼šæ¯”è¾ƒæ•°é‡
                                const q1 = toNumber(row['æ•°é‡']);
                                const q2 = toNumber(otherRow['æ•°é‡']);
                                if (q1 === q2) return 3; // ç»¿
                                return 2; // è“
                            }

                            // æ ¹æ®åˆ†ç±»ä¼˜å…ˆçº§è¿”å›è¡¨æ ¼è¡Œçš„èƒŒæ™¯è‰² class
                            function rowBgClass(fileName, row) {
                                const p = categoryPriority(fileName, row);
                                switch (p) {
                                    case 0: return 'bg-red-50';
                                    case 1: return 'bg-orange-50';
                                    case 2: return 'bg-blue-50';
                                    case 3: return 'bg-green-50';
                                    default: return '';
                                }
                            }

                            // ç»Ÿè®¡å½“å‰æ–‡ä»¶åœ¨å››ç§åˆ†ç±»ä¸‹çš„è¡Œæ•°ï¼ˆåŸºäºåŸºç¡€åˆ—ç­›é€‰ï¼Œä¸å«é¢œè‰²ç­›é€‰ï¼‰
                            function categoryCounts(fileName) {
                                const counts = { red: 0, orange: 0, blue: 0, green: 0 };
                                const table = getTable(fileName);
                                if (!compareMode.value || displayedSelectedFiles.value.length !== 2 || !(table.columns || []).includes('é›¶ä»¶å·')) {
                                    return counts;
                                }
                                const { otherByPN, otherRedSupplierSet } = buildCrossIndex(fileName);
                                // ç”¨ä¸å«é¢œè‰²ç­›é€‰çš„åŸºç¡€ç»“æœæ¥ç»Ÿè®¡æ•°é‡
                                const rows = baseFilteredRows(fileName) || [];
                                rows.forEach(row => {
                                    const pn = String((row && row['é›¶ä»¶å·']) ?? '').trim();
                                    const otherRow = pn ? otherByPN.get(pn) : undefined;
                                    if (!otherRow) {
                                        const spn = String((row && row['ä¾›åº”å•†é›¶ä»¶å·']) ?? '').trim();
                                        if (spn && otherRedSupplierSet.has(spn)) counts.orange++; else counts.red++;
                                    } else {
                                        const q1 = toNumber(row['æ•°é‡']);
                                        const q2 = toNumber(otherRow['æ•°é‡']);
                                        if (q1 === q2) counts.green++; else counts.blue++;
                                    }
                                });
                                return counts;
                            }

                            // è®¡ç®—â€œå¯¼çº¿æ•°é‡å·®å€¼â€åˆ—è¡¨ï¼ˆè“è‰²ç±»ä¸”ç±»å‹ä¸ºå¯¼çº¿/WIRE/çº¿æŸï¼‰ï¼Œè¿”å› [{ pn, type, q1, q2, diff }]
                            // è®¡ç®—å¯¼çº¿ç±»çš„æ•°é‡å·®å€¼åˆ—è¡¨ï¼ˆåŒ…å«æ‰€æœ‰å¯¼çº¿ç±»å‹ï¼Œå³è¡¨æœªæ‰¾åˆ°æ—¶æ•°é‡ä¸º0ï¼‰
                            function wiresDiff(fileName) {
                                if (!compareMode.value || displayedSelectedFiles.value.length !== 2) return [];
                                const table = getTable(fileName);
                                if (!table || !(table.columns || []).includes('é›¶ä»¶å·')) return [];
                                const TYPE_SET = new Set(['WIRE', 'çº¿æŸ', 'å¯¼çº¿']);
                                const otherName = getOtherFileName(fileName);
                                const { byPN } = buildIndexes(otherName);
                                const rows = filteredRows(fileName) || [];
                                const list = [];
                                rows.forEach(row => {
                                    const pn = String((row && row['é›¶ä»¶å·']) ?? '').trim();
                                    const tp = String((row && row['ç±»å‹']) ?? '').trim();
                                    if (!pn || !TYPE_SET.has(tp)) return;
                                    const otherRow = byPN.get(pn);
                                    const q1 = toNumber(row['æ•°é‡']);
                                    const q2 = otherRow ? toNumber(otherRow['æ•°é‡']) : 0; // å³è¡¨æœªæ‰¾åˆ°æ—¶æ•°é‡ä¸º0
                                    // åŒ…å«æ‰€æœ‰å¯¼çº¿ç±»å‹é›¶ä»¶ï¼Œæ— è®ºæ˜¯å¦æ‰¾åˆ°å¯¹åº”é¡¹
                                    list.push({ pn, type: tp, q1, q2, diff: q1 - q2 });
                                });
                                return list;
                            }

                            // ======================== é€šç”¨å¯¼å‡ºå·¥å…·ï¼ˆå¯å¤ç”¨ï¼‰ ========================
                            const COLORS = {
                                LIGHT_RED: 'FFFFC8C8',   // #FFC8C8 - æœªæ‰¾åˆ°
                                ORANGE: 'FFF4B382',      // #F4B382 - ä¾›åº”å•†é›¶ä»¶å·åŒ¹é…
                                LIGHT_BLUE: 'FF99CCFF',  // #99CCFF - æ•°é‡ä¸ä¸€è‡´
                                LIGHT_GREEN: 'FFC8FFC8', // #C8FFC8 - å®Œå…¨ä¸€è‡´
                                GRAY: 'FFDCDCDC',        // #DCDCDC - æ ‡é¢˜èƒŒæ™¯
                                LIGHT_GRAY: 'FFF0F0F0',  // #F0F0F0 - è¡¨å¤´èƒŒæ™¯
                            };
                            const fillSolid = (argb) => ({ type: 'pattern', pattern: 'solid', fgColor: { argb } });
                            function priorityFill(p) {
                                switch (p) {
                                    case 0: return fillSolid(COLORS.LIGHT_RED);
                                    case 1: return fillSolid(COLORS.ORANGE);
                                    case 2: return fillSolid(COLORS.LIGHT_BLUE);
                                    case 3: return fillSolid(COLORS.LIGHT_GREEN);
                                    default: return undefined;
                                }
                            }
                            function markText(p) { return ['æœªæ‰¾åˆ°', 'ä¾›åº”å•†åŒ¹é…', 'æ•°é‡ä¸åŒ', 'æ•°é‡ç›¸åŒ'][p] || ''; }

                            // ä½¿ç”¨å½“å‰ UI é€‰æ‹©ä¸æ’åºå¯¼å‡ºï¼ˆæ¨¡æ‹Ÿâ€œå¯åŠ¨å¯¹æ¯”åç‚¹å‡»å¯¼å‡ºâ€çš„è¡Œä¸ºï¼‰
                            async function exportCurrentSelection() {
                                const n = selectedFiles.value.length;
                                if (n === 0) return;
                                const wb = new ExcelJS.Workbook();
                                if (n === 1) {
                                    const f = selectedFiles.value[0];
                                    const t = getTable(f);
                                    const cols = (t.columns || []).slice();
                                    const rows = filteredRows(f) || [];
                                    const ws = wb.addWorksheet(sanitizeSheetName(f, new Set()));
                                    ws.addRow(cols); ws.getRow(1).font = { bold: true }; ws.getRow(1).fill = fillSolid(COLORS.LIGHT_GRAY);
                                    rows.forEach(r => ws.addRow(cols.map(c => r[c])));
                                    applyBordersForRange(ws, 1, 1, rows.length + 1, cols.length);
                                    autoFitColumns(ws);
                                    await downloadWorkbook(wb, `${sanitizeFileBase(f)}.xlsx`);
                                    return;
                                }

                                const [f1, f2] = selectedFiles.value;
                                const t1 = getTable(f1), t2 = getTable(f2);
                                const cols1 = (t1.columns || []).slice();
                                const cols2 = (t2.columns || []).slice();
                                if (compareMode.value) {
                                    // ç€è‰²å¯¹æ¯”è¡¨ A
                                    const wsA = wb.addWorksheet(sanitizeSheetName(f1, new Set()));
                                    wsA.addRow([...cols1, 'å¯¹æ¯”æ ‡è®°']); wsA.getRow(1).font = { bold: true }; wsA.getRow(1).fill = fillSolid(COLORS.LIGHT_GRAY);
                                    (filteredRows(f1) || []).forEach(r => {
                                        const p = categoryPriority(f1, r);
                                        const vals = [...cols1.map(c => r[c]), markText(p)];
                                        const row = wsA.addRow(vals);
                                        const fill = priorityFill(p); if (fill) for (let c = 1; c <= vals.length; c++) row.getCell(c).fill = fill;
                                    });
                                    applyBordersForRange(wsA, 1, 1, wsA.rowCount, wsA.columnCount);
                                    autoFitColumns(wsA);

                                    // ç€è‰²å¯¹æ¯”è¡¨ B
                                    const wsB = wb.addWorksheet(sanitizeSheetName(f2, new Set(wb.worksheets.map(w => w.name))));
                                    wsB.addRow([...cols2, 'å¯¹æ¯”æ ‡è®°']); wsB.getRow(1).font = { bold: true }; wsB.getRow(1).fill = fillSolid(COLORS.LIGHT_GRAY);
                                    (filteredRows(f2) || []).forEach(r => {
                                        const p = categoryPriority(f2, r);
                                        const vals = [...cols2.map(c => r[c]), markText(p)];
                                        const row = wsB.addRow(vals);
                                        const fill = priorityFill(p); if (fill) for (let c = 1; c <= vals.length; c++) row.getCell(c).fill = fill;
                                    });
                                    applyBordersForRange(wsB, 1, 1, wsB.rowCount, wsB.columnCount);
                                    autoFitColumns(wsB);

                                    // æ±‡æ€»é¡µï¼ˆä½¿ç”¨ç°æœ‰ç»Ÿè®¡ä¸å·®å€¼å‡½æ•°ï¼‰
                                    const wsS = wb.addWorksheet(sanitizeSheetName('å¯¹æ¯”ç»“æœ', new Set(wb.worksheets.map(w => w.name))));
                                    wsS.getCell('A1').value = 'å›¾ä¾‹'; wsS.getCell('A1').fill = fillSolid(COLORS.GRAY);
                                    const legends = [
                                        { text: 'é›¶ä»¶å·ä¸å­˜åœ¨', color: COLORS.LIGHT_RED },
                                        { text: 'ä¾›åº”å•†é›¶ä»¶å·åŒ¹é…', color: COLORS.ORANGE },
                                        { text: 'æ•°é‡ä¸ä¸€è‡´', color: COLORS.LIGHT_BLUE },
                                        { text: 'å®Œå…¨ä¸€è‡´', color: COLORS.LIGHT_GREEN },
                                    ];
                                    for (let i = 0; i < legends.length; i++) { const r = 3 + i; wsS.getCell(r, 1).value = legends[i].text; wsS.getCell(r, 1).fill = fillSolid(legends[i].color); }
                                    const cntA = categoryCounts(f1); const cntB = categoryCounts(f2);
                                    const colsBase = ['é›¶ä»¶å·', 'ä¾›åº”å•†é›¶ä»¶å·', 'ç±»å‹', 'æ•°é‡'];
                                    // A é¢è®¡æ•° + æ˜ç»†ï¼ˆæŒ‰å½“å‰ filteredRows é¡ºåºï¼‰
                                    wsS.getCell('C1').value = sanitizeSheetName(f1); wsS.getCell('C1').fill = fillSolid(COLORS.GRAY);
                                    [cntA.red, cntA.orange, cntA.blue, cntA.green].forEach((val, i) => { const cell = wsS.getCell(2, 3 + i); cell.value = val; cell.fill = fillSolid([COLORS.LIGHT_RED, COLORS.ORANGE, COLORS.LIGHT_BLUE, COLORS.LIGHT_GREEN][i]); });
                                    colsBase.forEach((c, k) => { const cell = wsS.getCell(3, 3 + k); cell.value = c; cell.fill = fillSolid(COLORS.LIGHT_GRAY); cell.font = { bold: true }; });
                                    (filteredRows(f1) || []).forEach((r, i) => {
                                        const p = categoryPriority(f1, r);
                                        const vals = [r['é›¶ä»¶å·'], r['ä¾›åº”å•†é›¶ä»¶å·'], r['ç±»å‹'], r['æ•°é‡']];
                                        for (let j = 0; j < vals.length; j++) { const cell = wsS.getCell(4 + i, 3 + j); cell.value = vals[j]; const fill = priorityFill(p); if (fill) cell.fill = fill; }
                                    });
                                    // B é¢
                                    wsS.getCell('H1').value = sanitizeSheetName(f2); wsS.getCell('H1').fill = fillSolid(COLORS.GRAY);
                                    [cntB.red, cntB.orange, cntB.blue, cntB.green].forEach((val, i) => { const cell = wsS.getCell(2, 8 + i); cell.value = val; cell.fill = fillSolid([COLORS.LIGHT_RED, COLORS.ORANGE, COLORS.LIGHT_BLUE, COLORS.LIGHT_GREEN][i]); });
                                    colsBase.forEach((c, k) => { const cell = wsS.getCell(3, 8 + k); cell.value = c; cell.fill = fillSolid(COLORS.LIGHT_GRAY); cell.font = { bold: true }; });
                                    (filteredRows(f2) || []).forEach((r, i) => {
                                        const p = categoryPriority(f2, r);
                                        const vals = [r['é›¶ä»¶å·'], r['ä¾›åº”å•†é›¶ä»¶å·'], r['ç±»å‹'], r['æ•°é‡']];
                                        for (let j = 0; j < vals.length; j++) { const cell = wsS.getCell(4 + i, 8 + j); cell.value = vals[j]; const fill = priorityFill(p); if (fill) cell.fill = fill; }
                                    });
                                    // å¯¼çº¿å·®å€¼åˆ—è¡¨ï¼ˆå¤ç”¨ wiresDiff æ’åºä¸è¿‡æ»¤ï¼‰
                                    wsS.getCell('M1').value = 'å¯¼çº¿é•¿åº¦å·®å€¼è®¡ç®—'; wsS.getCell('M1').fill = fillSolid(COLORS.GRAY);
                                    const head3 = ['é›¶ä»¶å·', 'ç±»å‹', 'å·¦è¡¨æ•°é‡', 'å³è¡¨æ•°é‡', 'å·®å€¼(å·¦-å³)'];
                                    head3.forEach((h, k) => { const cell = wsS.getCell(3, 13 + k); cell.value = h; cell.fill = fillSolid(COLORS.LIGHT_GRAY); cell.font = { bold: true }; });
                                    (wiresDiff(f1) || []).forEach((d, i) => {
                                        const vals = [d.pn, d.type, d.q1, d.q2, d.diff];
                                        const fill = d.diff > 0 ? fillSolid(COLORS.LIGHT_GREEN) : (d.diff < 0 ? fillSolid(COLORS.LIGHT_RED) : undefined);
                                        for (let j = 0; j < vals.length; j++) { const cell = wsS.getCell(4 + i, 13 + j); cell.value = vals[j]; if (fill) cell.fill = fill; }
                                    });
                                    const maxRow = Math.max(6, wsS.rowCount);
                                    applyBordersForRange(wsS, 1, 1, maxRow, 17);
                                    autoFitColumns(wsS);
                                    await downloadWorkbook(wb, `å¯¹æ¯”ç»“æœ_${sanitizeFileBase(f1)}_VS_${sanitizeFileBase(f2)}.xlsx`);
                                } else {
                                    // ä¸¤è¡¨åŸæ ·å¯¼å‡ºï¼ˆæŒ‰ filteredRows å½“å‰é¡ºåºï¼‰
                                    const ws1 = wb.addWorksheet(sanitizeSheetName(f1, new Set()));
                                    ws1.addRow(cols1); ws1.getRow(1).font = { bold: true }; ws1.getRow(1).fill = fillSolid(COLORS.LIGHT_GRAY);
                                    (filteredRows(f1) || []).forEach(r => ws1.addRow(cols1.map(c => r[c])));
                                    applyBordersForRange(ws1, 1, 1, ws1.rowCount, ws1.columnCount); autoFitColumns(ws1);

                                    const ws2 = wb.addWorksheet(sanitizeSheetName(f2, new Set(wb.worksheets.map(w => w.name))));
                                    ws2.addRow(cols2); ws2.getRow(1).font = { bold: true }; ws2.getRow(1).fill = fillSolid(COLORS.LIGHT_GRAY);
                                    (filteredRows(f2) || []).forEach(r => ws2.addRow(cols2.map(c => r[c])));
                                    applyBordersForRange(ws2, 1, 1, ws2.rowCount, ws2.columnCount); autoFitColumns(ws2);

                                    await downloadWorkbook(wb, `ä¸¤è¡¨å¯¼å‡º_${sanitizeFileBase(f1)}_ä¸_${sanitizeFileBase(f2)}.xlsx`);
                                }
                            }

                            async function downloadWorkbook(wb, filename) {
                                const buffer = await wb.xlsx.writeBuffer();
                                const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url; a.download = filename; a.click();
                                URL.revokeObjectURL(url);
                            }

                            // å¯¼å‡ºï¼šä½¿ç”¨ç°æœ‰ UI é€»è¾‘ï¼›å¤šé€‰æ—¶æ¨¡æ‹Ÿäººå·¥â€œå¯åŠ¨å¯¹æ¯”+å¯¼å‡ºâ€çš„é€å¯¹æµç¨‹
                            async function exportCompare() {
                                try {
                                    if (!window.ExcelJS || selectedFiles.value.length === 0) return;
                                    const n = selectedFiles.value.length;
                                    // å¤šäºä¸¤ä¸ªæ–‡ä»¶ï¼šä¸¤ä¸¤æˆå¯¹åˆ†åˆ«å¯¼å‡ºï¼ˆæ¨¡æ‹Ÿäººå·¥æ“ä½œï¼‰
                                    if (n > 2) {
                                        const originalSel = [...selectedFiles.value];
                                        const originalCompare = compareMode.value;
                                        try {
                                            for (let i = 0; i < originalSel.length - 1; i++) {
                                                for (let j = i + 1; j < originalSel.length; j++) {
                                                    const a = originalSel[i];
                                                    const b = originalSel[j];
                                                    selectedFiles.value = [a, b];
                                                    if (!compareMode.value) await toggleCompare();
                                                    await exportCurrentSelection();
                                                }
                                            }
                                        } finally {
                                            selectedFiles.value = originalSel;
                                            compareMode.value = originalCompare && originalSel.length === 2; // ä»…å½“åŸæœ¬æ˜¯åŒé€‰æ—¶ä¿ç•™
                                        }
                                        return;
                                    }

                                    // å•ä¸ªæ–‡ä»¶ï¼šå¯¼å‡ºå•è¡¨
                                    if (n === 1) {
                                        await exportCurrentSelection();
                                        return;
                                    }

                                    // æ°å¥½ä¸¤ä¸ªæ–‡ä»¶
                                    await exportCurrentSelection();
                                } catch (e) {
                                    alert('å¯¼å‡ºå¤±è´¥ï¼š' + (e && e.message ? e.message : e));
                                }
                            }
                            // è‡ªåŠ¨é€‚é…åˆ—å®½ï¼ˆåŸºäºæ–‡æœ¬é•¿åº¦ï¼Œè®¾ç½®ä¸Šä¸‹é™ï¼‰
                            function autoFitColumns(ws, minWidth = 10, maxWidth = 40) {
                                const cols = ws.columns || [];
                                cols.forEach(col => {
                                    let maxLen = 0;
                                    col.eachCell({ includeEmpty: true }, cell => {
                                        const v = cell.value;
                                        let l = 0;
                                        if (v == null) l = 0;
                                        else if (typeof v === 'object') {
                                            if (Array.isArray(v.richText)) {
                                                l = v.richText.map(t => t.text || '').join('').length;
                                            } else if (v.text != null) {
                                                l = String(v.text).length;
                                            } else {
                                                l = String(v).length;
                                            }
                                        } else {
                                            l = String(v).length;
                                        }
                                        if (l > maxLen) maxLen = l;
                                    });
                                    col.width = Math.min(maxWidth, Math.max(minWidth, maxLen + 2));
                                });
                            }

                            function applyBordersForRange(ws, r1, c1, r2, c2) {
                                // å®¹é”™ï¼šç¡®ä¿è¾¹ç•Œæœ‰æ•ˆ
                                r1 = Math.max(1, Math.floor(r1));
                                c1 = Math.max(1, Math.floor(c1));
                                r2 = Math.max(r1, Math.floor(r2));
                                c2 = Math.max(c1, Math.floor(c2));
                                for (let r = r1; r <= r2; r++) {
                                    for (let c = c1; c <= c2; c++) {
                                        const cell = ws.getCell(r, c);
                                        cell.border = {
                                            top: { style: 'thin' },
                                            left: { style: 'thin' },
                                            bottom: { style: 'thin' },
                                            right: { style: 'thin' },
                                        };
                                    }
                                }
                            }

                            //ï¼ˆç§»é™¤æœªä½¿ç”¨çš„ labelForCategoryï¼‰

                            // æ¸…æ´—ä¸ºåˆæ³•çš„ Excel å·¥ä½œè¡¨åï¼Œå¹¶é¿å…é‡åå†²çª
                            function sanitizeSheetName(name, existing = new Set()) {
                                const invalid = /[\\\/*?:\[\]]/g;
                                const baseRaw = String(name).replace(invalid, ' ').trim() || 'Sheet';
                                const cut = (s) => s.length > 31 ? s.slice(0, 31) : s;
                                let candidate = cut(baseRaw);
                                // å¦‚æœå†²çªï¼Œå°è¯•è¿½åŠ  (2),(3)...ï¼Œå¹¶ä¿è¯æ€»é•¿<=31
                                let idx = 2;
                                while (existing.has(candidate)) {
                                    const suffix = ` (${idx})`;
                                    const maxLen = 31 - suffix.length;
                                    candidate = cut(baseRaw.slice(0, Math.max(1, maxLen)) + suffix);
                                    idx++;
                                }
                                existing.add(candidate);
                                return candidate;
                            }

                            // ç”Ÿæˆå¯ç”¨äºæ–‡ä»¶åçš„åŸºç¡€ä¸²ï¼ˆå»æ‰©å±•åå¹¶æ›¿æ¢éæ³•å­—ç¬¦ï¼‰
                            function sanitizeFileBase(name) {
                                return String(name).replace(/\.[^.]+$/, '').replace(/[^\u4e00-\u9fa5\w-]+/g, '_');
                            }

                            // ç”Ÿæˆå”¯ä¸€æ˜¾ç¤ºåï¼šname, name (2), name (3)...

                            return {
                                tables,
                                fileList,
                                selectedFiles,
                                subtitle,
                                loading,
                                compareMode,
                                multiCompareMode,
                                compareBusy,
                                sheetReady,
                                faReady,
                                sheetBadge,
                                faBadge,
                                // å›åˆ°é¡¶éƒ¨
                                showTop,
                                scrollToTop,
                                // é¢œè‰²åˆ†ç±»ç­›é€‰
                                toggleColorFilter,
                                badgeClass,
                                handleFiles,
                                exportCompare,
                                toggleCompare,
                                toggleMultiCompare,
                                onFileCheckboxChange,
                                selectAllFiles,
                                getTable,
                                removeFile,
                                toggleFilterDropdown,
                                isDropdownOpen,
                                getFilterState,
                                closeDropdown,
                                filteredDistinctValues,
                                isValueChecked,
                                onToggleValue,
                                selectAllValues,
                                clearAllValues,
                                applyFilter,
                                isColumnFiltered,
                                hasActiveFilters,
                                dropdownStyle,
                                filteredRows,
                                rowBgClass,
                                categoryCounts,
                                wiresDiff,
                                // é¢„è§ˆå®¹å™¨æ§åˆ¶
                                containerVisible,
                                displayedSelectedFiles,
                                onPreviewContainerAfterLeave,
                                onBeforeEnter,
                                onEnter,
                                onAfterEnter,
                                onBeforeLeave,
                                onLeave,
                                cardWidth,
                                cardStyle,
                                previewWrap
                            };
                        }
                    }).mount('#app');

                    // ========== é¡µé¢å¢å¼ºåŠŸèƒ½ ==========

                    // æ€§èƒ½ç›‘æ§
                    if (window.performance) {
                        window.addEventListener('load', () => {
                            const perfData = performance.getEntriesByType('navigation')[0];
                            console.log(`é¡µé¢åŠ è½½æ—¶é—´: ${(perfData.loadEventEnd - perfData.fetchStart).toFixed(2)}ms`);
                        });
                    }

                    // ç§»åŠ¨ç«¯é€‚é…
                    if (/Mobile|Android|iPhone|iPad/i.test(navigator.userAgent)) {
                        document.body.classList.add('mobile-device');

                        // ç§»åŠ¨ç«¯è¡¨æ ¼æ¨ªå‘æ»šåŠ¨æç¤º
                        const addSwipeHint = () => {
                            const tables = document.querySelectorAll('.overflow-auto');
                            tables.forEach(container => {
                                if (container.scrollWidth > container.clientWidth) {
                                    container.setAttribute('data-swipe-hint', 'ğŸ‘ˆ å·¦å³æ»‘åŠ¨æŸ¥çœ‹æ›´å¤š');
                                }
                            });
                        };

                        // å»¶è¿Ÿæ‰§è¡Œï¼Œç­‰å¾…è¡¨æ ¼æ¸²æŸ“
                        setTimeout(addSwipeHint, 1000);
                    }

                    // é”®ç›˜å¿«æ·é”®æ”¯æŒ
                    document.addEventListener('keydown', (e) => {
                        // Ctrl/Cmd + Enter å¿«é€Ÿå¯¼å…¥æ–‡ä»¶
                        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                            e.preventDefault();
                            document.getElementById('fileInput')?.click();
                        }

                        // Esc é”®å…³é—­æ‰€æœ‰ä¸‹æ‹‰èœå•
                        if (e.key === 'Escape') {
                            const app = document.getElementById('app').__vue_app__;
                            if (app && app._instance) {
                                const vm = app._instance.ctx;
                                // å…³é—­æ‰€æœ‰ç­›é€‰é¢æ¿
                                Object.keys(vm.filterUI || {}).forEach(fileName => {
                                    const cols = vm.filterUI[fileName] || {};
                                    Object.keys(cols).forEach(colName => {
                                        cols[colName].open = false;
                                    });
                                });
                                vm.openDropdownKey = '';
                            }
                        }
                    });

                    // PWA æ”¯æŒæ£€æµ‹
                    if ('serviceWorker' in navigator) {
                        console.log('æµè§ˆå™¨æ”¯æŒ Service Workerï¼Œå¯ä»¥è€ƒè™‘æ·»åŠ ç¦»çº¿æ”¯æŒ');
                    }

                </script>

                <!-- å¢å¼ºçš„æ— éšœç¢æ”¯æŒ -->
                <div id="sr-status" class="sr-only" aria-live="polite" aria-atomic="true"></div>

            </main>
        </div>
    </body>

</html>